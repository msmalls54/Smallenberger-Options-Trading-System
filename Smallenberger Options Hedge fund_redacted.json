{
  "name": "Smallenberger Options Hedge fund",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// PREOPEN \u2014 Ticker Emitter (RSS + yfinance only)\n// Outputs ONE item per ticker: { json: { symbol } } \u2014 no filters.\n// Exception: include ETF \"SPY\" (must be FIRST).\n\n// === Base universe (original) ===\nconst UNIVERSE = [\n  // Big Tech / Megacaps\n  \"AAPL\",\"MSFT\",\"NVDA\",\"AMZN\",\"META\",\"GOOGL\",\"TSLA\",\"AVGO\",\"ORCL\",\"CRM\",\n  // Semis / Chips\n  \"AMD\",\"INTC\",\"TSM\",\"QCOM\",\"MU\",\n  // Cloud / Security / SaaS\n  \"ADBE\",\"NOW\",\"PANW\",\"SNOW\",\"NET\",\"DDOG\",\"ZM\",\"AI\",\"BBAI\",\"PLTR\",\"DOCU\",\n  // Fintech / Payments / Crypto infra\n  \"XYZ\",\"PYPL\",\"AFRM\",\"SOFI\",\"CRCL\",\"UPST\",\"KLAR\",\"CHYM\",\"BLSH\",\"BULL\",\"NU\",\"TOST\",\n  // Rides / Travel / Trading / Crypto\n  \"UBER\",\"LYFT\",\"ABNB\",\"COIN\",\"HOOD\",\"MSTR\",\"RIOT\",\"MARA\",\"GEMI\",\"IREN\",\"CLSK\",\n  // Consumer / Retail / Apparel / CPG / Autos\n  \"WMT\",\"TGT\",\"COST\",\"NKE\",\"LULU\",\"AEO\",\"HSY\",\"BABA\",\"RL\",\"SJM\",\"BBW\",\"UAA\",\"CROX\",\"CVNA\",\"GPRO\",\n  // Beverage / Alt-protein / Food\n  \"KO\",\"PEP\",\"CELH\",\"MNST\",\"OTLY\",\"BYND\",\"CALM\",\"TSN\",\n  // Pets\n  \"WOOF\",\"FRPT\",\n  // EVs / Autos / Charging / Energy\n  \"NIO\",\"LI\",\"RIVN\",\"LCID\",\"RACE\",\"BLNK\",\"XPEV\",\"PLUG\",\n  // Media / Sports / Social / Gaming / Dating / Education\n  \"NFLX\",\"FOXA\",\"TKO\",\"YELP\",\"RDDT\",\"RBLX\",\"SNAP\",\"TTWO\",\"PENN\",\"DKNG\",\"FUBO\",\"WYNN\",\"FUN\",\n  \"MTCH\",\"GME\",\"CZR\",\"BMBL\",\"GRND\",\"CHGG\",\"DUOL\",\n  // Restaurants (core)\n  \"MCD\",\"SBUX\",\"BROS\",\"DPZ\",\"WING\",\"CAKE\",\"CMG\",\"CAVA\",\"SG\",\"RR\",\n  \"RRGB\",\"DNUT\",\"CBRL\",\"SHAK\",\"TXRH\",\"WEN\",\"PZZA\",\"DRI\",\"BJRI\",\"PLAY\",\"JACK\",\n  \"PTLO\",\"QSR\",\"EAT\",\"YUM\",\n  // Grocers & Club\n  \"ACI\",\"SFM\",\n  // Exchange / Platforms\n  \"CME\",\"DASH\",\"PGY\",\n  // Industrials / Utility\n  \"BA\",\"PCG\",\"ED\",\n  // Contract food service\n  \"ARMK\",\n  // Health & Wellness\n  \"PTON\",\"PLBY\",\"PLNT\",\"WW\",\"HIMS\",\n  // Design / Ordering rails\n  \"FIG\"\n];\n\n// === Additions pack (validated; includes SPY by request) ===\nconst APPENDS = [\n  // ETF exception\n  \"SPY\",\n\n  // Europe / UK (ADRs or foreign-domiciled w/ US options)\n  \"ASML\",\"NVO\",\"SAP\",\"SHEL\",\"BP\",\"BTI\",\"AZN\",\"GSK\",\"TTE\",\n  \"RIO\",\"BHP\",\"STM\",\"PHG\",\"NOK\",\"ERIC\",\"ING\",\"SAN\",\"BBVA\",\"DB\",\n  \"UBS\",\"BUD\",\"RYAAY\",\"VOD\",\"SNY\",\"NVS\",\n\n  // Japan / Taiwan\n  \"TM\",\"HMC\",\"SONY\",\"TAK\",\"UMC\",\"ASX\",\n\n  // China / HK (US-listed)\n  \"PDD\",\"JD\",\"BIDU\",\"NTES\",\"TME\",\"IQ\",\"BILI\",\"YUMC\",\"BEKE\",\n\n  // LatAm (US-listed)\n  \"MELI\",\"PBR\",\"VALE\",\"ITUB\",\"BBD\",\"SQM\",\"FMX\",\"AMX\",\"PAGS\",\"STNE\",\"DLO\",\n\n  // Canada (US-listed)\n  \"SHOP\",\"CNQ\",\"SU\",\"ENB\",\"RY\",\"TD\",\"BNS\",\"CP\",\"CNI\",\"TECK\",\"NTR\",\"CCJ\",\"KGC\",\"AG\",\n\n  // Nordics / Israel / Middle East\n  \"EQNR\",\"E\",\"HSBC\",\"TEVA\",\"NICE\",\"WIX\",\"MNDY\",\"GLBE\",\"ZIM\",\n\n  // Korea / SEA (US-listed)\n  \"CPNG\",\"FLUT\",\n\n  // Solar & materials\n  \"JKS\",\"DQ\",\"CSIQ\",\n\n  // Airlines / transport (international)\n  \"CPA\",\n\n  // U.S. high-beta / technical favorites\n  \"SMCI\",\"ARM\",\"CRWD\",\"ZS\",\"OKTA\",\"MDB\",\"TTD\",\"U\",\"PATH\",\"PINS\",\"ROKU\",\"ETSY\",\"XYZ\",\"SOUN\",\"IONQ\",\"NKLA\",\"ASTS\",\"SPCE\",\"JOBY\",\n\n  // Meme pack (optionable)\n  \"AMC\",\"BB\",\"TLRY\",\"CGC\",\"SNDL\",\"DJT\",\"RUM\",\"QS\",\"CLOV\",\"KOSS\",\"RKT\",\"GCT\",\"ENVX\",\"SAVA\",\"VFS\"\n];\n\n// === Extra user adds (intimates/lifestyle + restaurants + fun small caps) ===\nconst APPENDS_MORE = [\n  \"RICK\",\"VSCO\",\"HBI\",\"CHD\",\n  \"PBPB\",\"NDLS\",\n  \"LOVE\",\"FIGS\",\"GDRX\"\n];\n\n// --- Build final set (dedupe + normalize) and force SPY first ---\nconst combined = [...new Set([...UNIVERSE, ...APPENDS, ...APPENDS_MORE].map(t => String(t).toUpperCase()))];\nconst ordered = combined.includes(\"SPY\") ? [\"SPY\", ...combined.filter(t => t !== \"SPY\")] : combined;\n\n// n8n requires: return array of { json: { symbol } }\nreturn ordered.map(symbol => ({ json: { symbol } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        160
      ],
      "id": "8ee6e7ba-01cb-4188-94c7-69e60beecae9",
      "name": "02 Expand Tickers"
    },
    {
      "parameters": {
        "jsCode": "/**\n * RSS News Parser \u2014 Forward-Looking v3 (n8n SAFE)\n * Forgiving coverage + forward signals (earnings window, OPEX, sector cycles)\n * Extracts insider sells/buys, price targets (PT\u2191/PT\u2193), rating changes, guidance/product/regulatory.\n * Emits clean headlines & compact fresh bullets; adds signals & forward objects for Agent scoring.\n */\n\n//// ============================ CONFIG ============================ ////\nconst MAX_PER_TICKER = 20;\nconst BASE_MAX_AGE_DAYS = 3;\nconst FALLBACK_MAX_AGE_DAYS = 7;\nconst MAX_SYMBOLS_PER_ARTICLE = 3;\nconst EMIT_ALL_SYMBOLS = true;\n\nconst ACCEPT_MISSING_TIME = true;\nconst ACCEPT_MISSING_TIME_MIN_TIER = 2;\n\nconst SYMBOL_AGE_OVERRIDE = { AAPL: 10 };\n\nconst VARS = (typeof $vars !== 'undefined' && $vars) ? $vars : {};\nconst EXTRA_TIER3 = String(VARS.PUBLISHER_TIER3_ADD ?? \"\")\n  .split(\",\").map(s => s.trim().toLowerCase()).filter(Boolean);\n\n//// ========================== UNIVERSE ============================ ////\n// Includes original universe + all new adds (SPY, international ADRs, meme pack, plus: RICK, VSCO, HBI, CHD, PBPB, NDLS, LOVE, FIGS, GDRX)\nlet UNIVERSE_FALLBACK = [\n  // ETF exception \u2014 keep first for visibility\n  \"SPY\",\n\n  // Big Tech / Megacaps\n  \"AAPL\",\"MSFT\",\"NVDA\",\"AMZN\",\"META\",\"GOOGL\",\"TSLA\",\"AVGO\",\"ORCL\",\"CRM\",\n\n  // Semis / Chips\n  \"AMD\",\"INTC\",\"TSM\",\"QCOM\",\"MU\",\n\n  // Cloud / Security / SaaS\n  \"ADBE\",\"NOW\",\"PANW\",\"SNOW\",\"NET\",\"DDOG\",\"ZM\",\"AI\",\"BBAI\",\"PLTR\",\"DOCU\",\n\n  // Fintech / Payments / Crypto infra\n  \"XYZ\",\"PYPL\",\"AFRM\",\"SOFI\",\"CRCL\",\"UPST\",\"KLAR\",\"CHYM\",\"BLSH\",\"BULL\",\"NU\",\"TOST\",\n\n  // Rides / Travel / Trading / Crypto\n  \"UBER\",\"LYFT\",\"ABNB\",\"COIN\",\"HOOD\",\"MSTR\",\"RIOT\",\"MARA\",\"GEMI\",\"IREN\",\"CLSK\",\n\n  // Consumer / Retail / Apparel / CPG / Autos\n  \"WMT\",\"TGT\",\"COST\",\"NKE\",\"LULU\",\"AEO\",\"HSY\",\"BABA\",\"RL\",\"SJM\",\"BBW\",\"UAA\",\"CROX\",\"CVNA\",\"GPRO\",\n\n  // Beverage / Alt-protein / Food\n  \"KO\",\"PEP\",\"CELH\",\"MNST\",\"OTLY\",\"BYND\",\"CALM\",\"TSN\",\n\n  // Pets\n  \"WOOF\",\"FRPT\",\n\n  // EVs / Autos / Charging / Energy\n  \"NIO\",\"LI\",\"RIVN\",\"LCID\",\"RACE\",\"BLNK\",\"XPEV\",\"PLUG\",\n\n  // Media / Sports / Social / Gaming / Dating / Education\n  \"NFLX\",\"FOXA\",\"TKO\",\"YELP\",\"RDDT\",\"RBLX\",\"SNAP\",\"TTWO\",\"PENN\",\"DKNG\",\"FUBO\",\"WYNN\",\"FUN\",\n  \"MTCH\",\"GME\",\"CZR\",\"BMBL\",\"GRND\",\"CHGG\",\"DUOL\",\n\n  // Restaurants (core)\n  \"MCD\",\"SBUX\",\"BROS\",\"DPZ\",\"WING\",\"CAKE\",\"CAVA\",\"SG\",\"CMG\",\"RR\",\n  \"RRGB\",\"DNUT\",\"CBRL\",\"SHAK\",\"TXRH\",\"WEN\",\"PZZA\",\"DRI\",\"BJRI\",\"PLAY\",\"JACK\",\n  \"PTLO\",\"QSR\",\"EAT\",\"YUM\",\n\n  // Grocers & Club\n  \"ACI\",\"SFM\",\n\n  // Exchange / Platforms\n  \"CME\",\"DASH\",\"PGY\",\n\n  // Industrials / Utility\n  \"BA\",\"PCG\",\"ED\",\n\n  // Contract food service\n  \"ARMK\",\n\n  // Health & Wellness\n  \"PTON\",\"PLBY\",\"PLNT\",\"WW\",\"HIMS\",\n\n  // Design / Ordering rails (kept for internal refs)\n  \"FIG\",\n\n  // ================= Added \u2014 Europe/UK/Global ADRs =================\n  \"ASML\",\"NVO\",\"SAP\",\"SHEL\",\"BP\",\"BTI\",\"AZN\",\"GSK\",\"TTE\",\n  \"RIO\",\"BHP\",\"STM\",\"PHG\",\"NOK\",\"ERIC\",\"ING\",\"SAN\",\"BBVA\",\"DB\",\n  \"UBS\",\"BUD\",\"RYAAY\",\"VOD\",\"SNY\",\"NVS\",\n\n  // Japan / Taiwan\n  \"TM\",\"HMC\",\"SONY\",\"TAK\",\"UMC\",\"ASX\",\n\n  // China / HK (US-listed)\n  \"PDD\",\"JD\",\"BIDU\",\"NTES\",\"TME\",\"IQ\",\"BILI\",\"YUMC\",\"BEKE\",\n\n  // LatAm (US-listed)\n  \"MELI\",\"PBR\",\"VALE\",\"ITUB\",\"BBD\",\"SQM\",\"FMX\",\"AMX\",\"PAGS\",\"STNE\",\"DLO\",\n\n  // Canada (US-listed)\n  \"SHOP\",\"CNQ\",\"SU\",\"ENB\",\"RY\",\"TD\",\"BNS\",\"CP\",\"CNI\",\"TECK\",\"NTR\",\"CCJ\",\"KGC\",\"AG\",\n\n  // Nordics / Israel / Middle East\n  \"EQNR\",\"E\",\"HSBC\",\"TEVA\",\"NICE\",\"WIX\",\"MNDY\",\"GLBE\",\"ZIM\",\n\n  // Korea / SEA\n  \"CPNG\",\"FLUT\",\n\n  // Solar & Materials\n  \"JKS\",\"DQ\",\"CSIQ\",\n\n  // Airlines / Transport (international)\n  \"CPA\",\n\n  // US high-beta / technical favorites\n  \"SMCI\",\"ARM\",\"CRWD\",\"ZS\",\"OKTA\",\"MDB\",\"TTD\",\"U\",\"PATH\",\"PINS\",\"ROKU\",\"ETSY\",\"SOUN\",\"IONQ\",\"NKLA\",\"ASTS\",\"SPCE\",\"JOBY\",\n\n  // Meme pack (optionable)\n  \"AMC\",\"BB\",\"TLRY\",\"CGC\",\"SNDL\",\"DJT\",\"RUM\",\"QS\",\"CLOV\",\"KOSS\",\"RKT\",\"GCT\",\"ENVX\",\"SAVA\",\"VFS\",\n\n  // New \u201cintimates + lifestyle\u201d adds + small-cap restaurants + fun small caps\n  \"RICK\",\"VSCO\",\"HBI\",\"CHD\",\"PBPB\",\"NDLS\",\"LOVE\",\"FIGS\",\"GDRX\"\n];\n\ntry {\n  if (VARS.UNIVERSE_TICKERS) {\n    const u = JSON.parse(VARS.UNIVERSE_TICKERS);\n    if (Array.isArray(u) && u.length) {\n      UNIVERSE_FALLBACK = [...new Set(u.map(x => String(x).toUpperCase().trim()).filter(Boolean))];\n    }\n  }\n} catch {/* ignore */}\nconst SYMBOLS = [...new Set(UNIVERSE_FALLBACK.filter(Boolean))];\nconst SYMBOL_SET = new Set(SYMBOLS);\n\n//// =================== ALIASES / AMBIG / DOMAINS =================== ////\nconst ALIASES = {\n  // Existing\n  \"PLAY\":[\"Dave & Buster\",\"Dave & Buster's\"], \"WING\":[\"Wingstop\"], \"CAKE\":[\"Cheesecake Factory\"],\n  \"NET\":[\"Cloudflare\"], \"NOW\":[\"ServiceNow\"], \"SNOW\":[\"Snowflake\"], \"PG\":[\"Procter & Gamble\"], \"T\":[\"AT&T\"], \"V\":[\"Visa\"],\n  \"MCD\":[\"McDonald's\"], \"SBUX\":[\"Starbucks\"], \"DPZ\":[\"Domino's\",\"Domino's Pizza\"], \"CMG\":[\"Chipotle\"], \"CAVA\":[\"CAVA\"], \"SG\":[\"Sweetgreen\"],\n  \"WEN\":[\"Wendy's\"], \"PZZA\":[\"Papa John's\"], \"DRI\":[\"Darden\"], \"BJRI\":[\"BJ's Restaurants\"], \"JACK\":[\"Jack in the Box\"],\n  \"PTLO\":[\"Portillo's\"], \"QSR\":[\"Restaurant Brands\"],\n  \"RRGB\":[\"Red Robin\"], \"CBRL\":[\"Cracker Barrel\"], \"SHAK\":[\"Shake Shack\"], \"TXRH\":[\"Texas Roadhouse\"], \"DNUT\":[\"Krispy Kreme\"], \"BROS\":[\"Dutch Bros\"],\n  \"CELH\":[\"Celsius Holdings\"], \"MNST\":[\"Monster Beverage\"], \"OTLY\":[\"Oatly\"], \"BYND\":[\"Beyond Meat\"], \"CALM\":[\"Cal-Maine\"], \"HSY\":[\"Hershey\"],\n  \"LULU\":[\"Lululemon\"], \"AEO\":[\"American Eagle\"], \"UAA\":[\"Under Armour\"], \"BBW\":[\"Build-A-Bear\"],\n  \"NIO\":[\"NIO\"], \"LI\":[\"Li Auto\"], \"RIVN\":[\"Rivian\"], \"LCID\":[\"Lucid\"], \"RACE\":[\"Ferrari\"], \"BLNK\":[\"Blink Charging\"],\n  \"FOXA\":[\"Fox\"], \"TKO\":[\"TKO Group\",\"UFC\",\"WWE\"],\n  \"YELP\":[\"Yelp\"], \"RDDT\":[\"Reddit\"], \"RBLX\":[\"Roblox\"], \"NFLX\":[\"Netflix\"], \"GME\":[\"GameStop\"], \"CZR\":[\"Caesars Entertainment\"], \"MTCH\":[\"Match Group\"],\n  \"XYZ\":[\"Block\",\"Square\"], \"PYPL\":[\"PayPal\"], \"AFRM\":[\"Affirm\"], \"SOFI\":[\"SoFi\"], \"COIN\":[\"Coinbase\"], \"HOOD\":[\"Robinhood\"], \"CRCL\":[\"Circle\"], \"NU\":[\"Nubank\"],\n  \"AI\":[\"C3.ai\"], \"BBAI\":[\"BigBear.ai\"], \"PLTR\":[\"Palantir\"], \"DDOG\":[\"Datadog\"], \"ADBE\":[\"Adobe\"], \"PANW\":[\"Palo Alto Networks\"], \"ZM\":[\"Zoom\"],\n  \"AAPL\":[\"Apple\"], \"MSFT\":[\"Microsoft\"], \"NVDA\":[\"NVIDIA\"], \"AMZN\":[\"Amazon\"], \"META\":[\"Meta\",\"Facebook\"],\n  \"GOOGL\":[\"Alphabet\",\"Google\"], \"TSLA\":[\"Tesla\"], \"AVGO\":[\"Broadcom\"], \"ORCL\":[\"Oracle\"], \"CRM\":[\"Salesforce\"],\n  \"AMD\":[\"AMD\",\"Advanced Micro Devices\"], \"INTC\":[\"Intel\"], \"TSM\":[\"TSMC\"], \"QCOM\":[\"Qualcomm\"], \"MU\":[\"Micron\"],\n  \"CME\":[\"CME Group\"], \"DASH\":[\"DoorDash\"], \"PGY\":[\"Pagaya\"],\n  \"BULL\":[\"Webull\"], \"BLSH\":[\"Bullish\"], \"CHYM\":[\"Chime\"],\n  \"UBER\":[\"Uber\"], \"LYFT\":[\"Lyft\"], \"ABNB\":[\"Airbnb\"], \"MSTR\":[\"MicroStrategy\"],\n  \"PCG\":[\"PG&E\"], \"BA\":[\"Boeing\"], \"PTON\":[\"Peloton\"], \"PLBY\":[\"Playboy\"],\n  \"WMT\":[\"Walmart\"], \"TGT\":[\"Target\"], \"COST\":[\"Costco\"], \"NKE\":[\"Nike\"], \"BABA\":[\"Alibaba\"], \"KO\":[\"Coca-Cola\"], \"PEP\":[\"PepsiCo\"],\n  \"RL\":[\"Ralph Lauren\"], \"SJM\":[\"J. M. Smucker\"], \"PLNT\":[\"Planet Fitness\"], \"ED\":[\"Con Edison\"], \"EAT\":[\"Brinker\"], \"DOCU\":[\"DocuSign\"],\n  \"TSN\":[\"Tyson\"], \"XPEV\":[\"XPeng\"], \"PLUG\":[\"Plug Power\"], \"BMBL\":[\"Bumble\"], \"GRND\":[\"Grindr\"], \"CHGG\":[\"Chegg\"], \"DUOL\":[\"Duolingo\"],\n  \"YUM\":[\"Yum! Brands\"], \"WW\":[\"WW International\"], \"FIG\":[\"Figma\"], \"ARMK\":[\"Aramark\"],\n  \"GEMI\":[\"Gemini\"], \"IREN\":[\"Iris Energy\"], \"CLSK\":[\"CleanSpark\"], \"CROX\":[\"Crocs\"],\n  \"WOOF\":[\"Petco\"], \"FRPT\":[\"Freshpet\"], \"RR\":[\"Richtech Robotics\"], \"GPRO\":[\"GoPro\"], \"TOST\":[\"Toast\"], \"CVNA\":[\"Carvana\"], \"HIMS\":[\"Hims & Hers\"], \"TTWO\":[\"Take-Two\"],\n\n  // New helpful aliases for latest adds (light coverage)\n  \"RICK\":[\"RCI Hospitality\"],\n  \"VSCO\":[\"Victoria's Secret\"],\n  \"HBI\":[\"Hanesbrands\"],\n  \"CHD\":[\"Church & Dwight\",\"Trojan\"],\n  \"PBPB\":[\"Potbelly\"],\n  \"NDLS\":[\"Noodles & Company\",\"Noodles & Co\"],\n  \"LOVE\":[\"Lovesac\"],\n  \"FIGS\":[\"FIGS\"],\n  \"GDRX\":[\"GoodRx\"],\n  \"ARM\":[\"Arm Holdings\"],\n  \"SHOP\":[\"Shopify\"],\n  \"ASML\":[\"ASML\"],\n  \"NVO\":[\"Novo Nordisk\"],\n  \"SAP\":[\"SAP\"],\n  \"SHEL\":[\"Shell\"],\n  \"TTE\":[\"TotalEnergies\"],\n  \"RIO\":[\"Rio Tinto\"],\n  \"BHP\":[\"BHP\"],\n  \"UBS\":[\"UBS\"],\n  \"BUD\":[\"AB InBev\"],\n  \"CPNG\":[\"Coupang\"],\n  \"FLUT\":[\"Flutter\"]\n};\n\nconst DOMAIN_HINTS = {};\n\nconst AMBIGUOUS = new Set([\"T\",\"V\",\"PG\",\"NET\",\"NOW\",\"SNOW\",\"WING\",\"CAKE\",\"SG\",\"PLAY\",\"CALM\",\"AI\",\"EAT\",\"WW\",\"FIG\"]);\n\nconst AMBIG_POLICY = {\n  default: { threshold: 2 },\n  special: {\n    \"PLAY\": { threshold: 5 }, \"NET\": { threshold: 4 }, \"NOW\": { threshold: 4 }, \"SNOW\": { threshold: 4 },\n    \"PG\": { threshold: 4 },   \"T\": { threshold: 4 },   \"V\": { threshold: 4 },\n    \"WING\": { threshold: 4 }, \"CAKE\": { threshold: 4 }, \"SG\": { threshold: 4 },\n    \"AI\": { threshold: 5 },   \"EAT\": { threshold: 4 }, \"WW\": { threshold: 4 }, \"FIG\": { threshold: 4 }\n  }\n};\n\n// Publisher tiers (promote common aggregators)\nconst PUBLISHER_TIER1 = [\n  \"reuters.com\",\"bloomberg.com\",\"wsj.com\",\"ft.com\",\"apnews.com\",\n  \"cnbc.com\",\"marketwatch.com\",\"finance.yahoo.com\",\"seekingalpha.com\",\"sec.gov\"\n];\nconst PUBLISHER_TIER2 = [\n  \"theverge.com\",\"9to5mac.com\",\"pcmag.com\",\"computerworld.com\",\"patentlyapple.com\",\"techradar.com\",\"engadget.com\",\"arstechnica.com\",\"wired.com\",\"macrumors.com\",\n  \"theglobeandmail.com\",\"benzinga.com\",\"barrons.com\",\"fool.com\",\n  \"msn.com\",\"marketbeat.com\",\"tipranks.com\",\"investors.com\",\"barchart.com\"\n];\nconst PUBLISHER_TIER3 = [\"newser.com\", ...EXTRA_TIER3];\nconst PR_DOMAINS = [\"globenewswire.com\",\"prnewswire.com\",\"businesswire.com\"];\n\n//// ============================ HELPERS ============================ ////\nfunction normUp(s){ return String(s || \"\").toUpperCase(); }\nfunction normWS(s){ return String(s || \"\").replace(/\\s+/g,\" \").trim(); }\nfunction toISO(d){ const dt=new Date(d); return Number.isFinite(dt.getTime())?dt.toISOString():null; }\nfunction ageDays(ts){ return ts ? Math.max(0,(Date.now()-new Date(ts).getTime())/86400000) : Infinity; }\nfunction hostOf(u){ try{ const h=new URL(u).hostname.toLowerCase(); return h.startsWith(\"www.\")?h.slice(4):h; } catch{ return \"\"; } }\nfunction matchesHost(h, list){ h=String(h||\"\").toLowerCase(); return list.some(x=> h===x || h.endsWith(`.${x}`)); }\nfunction siteTierHostOrUrl(uOrHost){ const s=String(uOrHost||\"\"); const h=/^https?:\\/\\//i.test(s)?hostOf(s):s.toLowerCase(); if(!h) return 0;\n  if(matchesHost(h,PUBLISHER_TIER1))return 1; if(matchesHost(h,PUBLISHER_TIER2))return 2; if(matchesHost(h,PUBLISHER_TIER3))return 3; return 0; }\nfunction isPR(u){ return matchesHost(hostOf(u), PR_DOMAINS); }\n\n// De-aggregate Google News / MSN via title suffix\nconst NAME_TO_DOMAIN = {\n  \"reuters\":\"reuters.com\",\"bloomberg\":\"bloomberg.com\",\"wall street journal\":\"wsj.com\",\"financial times\":\"ft.com\",\n  \"ap news\":\"apnews.com\",\"associated press\":\"apnews.com\",\"cnbc\":\"cnbc.com\",\"marketwatch\":\"marketwatch.com\",\"yahoo finance\":\"finance.yahoo.com\",\n  \"seeking alpha\":\"seekingalpha.com\",\"investor's business daily\":\"investors.com\",\"investors business daily\":\"investors.com\",\n  \"barron's\":\"barrons.com\",\"the motley fool\":\"fool.com\",\"the globe and mail\":\"theglobeandmail.com\",\"benzinga\":\"benzinga.com\",\n  \"marketbeat\":\"marketbeat.com\",\"barchart\":\"barchart.com\",\"msn\":\"msn.com\",\"tipranks\":\"tipranks.com\"\n};\nfunction extractPublisherNameFromTitle(t){\n  const s=String(t||\"\"); for(const sep of [\" - \", \" \u2014 \"]){ const i=s.lastIndexOf(sep); if(i>10) return s.slice(i+sep.length).trim(); } return \"\";\n}\n\nfunction extractTextSurfaces(it){\n  const j=it?.json ?? it ?? {}; const title=j.title||\"\"; const summary=j.summary || j.contentSnippet || j.description || \"\";\n  const content=j.content || j[\"content:encoded\"] || \"\"; const categories=Array.isArray(j.categories)? j.categories.join(\" \") : (j.category || \"\");\n  const combined=[title,summary,content,categories].filter(Boolean).join(\" \");\n  return { title, summary, content, categories, combined };\n}\nfunction extractLinkAndTime(it){\n  const j=it?.json ?? it ?? {};\n  const link=j.link?.href || j.link || j.guid || j.url || (Array.isArray(j.links)&&(j.links[0]?.href||j.links[0])) || \"\";\n  const ts=j.publishedAt || j.isoDate || j.pubDate || j.published || j.date || j.updatedISO || j.updated || j[\"dc:date\"] || j[\"atom:updated\"] || null;\n  const iso=toISO(ts); return { link, iso };\n}\n\n// URL/alias/ticker detection\nfunction extractSymbolsFromUrl(u){\n  const out=new Set(); if(!u) return out; let host=\"\"; let s=\"\";\n  try{ const url=new URL(u); host=(url.hostname||\"\").toLowerCase(); s=url.toString().toLowerCase(); }\n  catch{ s=String(u||\"\").toLowerCase(); host=\"\"; }\n  let m;\n  const p1=/\\/(quote|symbol|stocks?|ticker|security)\\/([A-Z.\\-]{1,6})(?=[\\/?]|$)/ig; while((m=p1.exec(s))) out.add(m[2].toUpperCase());\n  if(host.endsWith(\"reuters.com\")){ const p2=/-([a-z]{1,6})\\.(?:o|oq|n|k|l|ax|ti|pa|de|br|mx|to|vz)\\b/ig; while((m=p2.exec(s))) out.add(m[1].toUpperCase()); }\n  const queryHosts=new Set([\"finance.yahoo.com\",\"seekingalpha.com\",\"marketwatch.com\"]);\n  if(queryHosts.has(host)){ const p3=/(?:[?&](?:s|symbol|p|ticker)=)([A-Z.\\-]{1,6})(?=[&#]|$)/ig; while((m=p3.exec(s))) out.add(m[1].toUpperCase()); }\n  for(const sym of Array.from(out)) if(!SYMBOL_SET.has(sym)) out.delete(sym);\n  return out;\n}\nfunction strictTickerHits_inTitleSummary(title, summary){\n  const text=`${title||\"\"} ${summary||\"\"}`; const all=new Set(); const detail=Object.create(null);\n  const add=(sym,kind)=>{ all.add(sym); detail[sym]=detail[sym]||{dollar:false,paren:false,exchange:false}; detail[sym][kind]=true; };\n  let m; const rxDollar=/\\$([A-Z]{1,6})\\b/g; while((m=rxDollar.exec(text))) add(m[1].toUpperCase(),\"dollar\");\n  const rxParen=/\\(([A-Z]{1,6})\\)/g; while((m=rxParen.exec(text))) add(m[1].toUpperCase(),\"paren\");\n  const rxExch=/\\b(?:NASDAQ|NYSE|AMEX|NYSEARCA)\\s*:\\s*([A-Z]{1,6})\\b/gi; while((m=rxExch.exec(text))) add(m[1].toUpperCase(),\"exchange\");\n  return { all, detail };\n}\nfunction exactAliasRegex(str){ const s=str.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\"); return new RegExp(`(?:^|[\\\\s\"'-])${s}(?=$|[\\\\s\"'.;,:!?\\\\-])`,\"i\"); }\nfunction aliasHits(text){ const found=new Set(); const T=String(text||\"\"); for(const sym of SYMBOLS){ const al=ALIASES[sym]||[]; for(const a of al){ if(exactAliasRegex(a).test(T)){ found.add(sym); break; } } } return found; }\nfunction categoryAliasHits(categories){ return aliasHits(categories); }\nfunction domainHits(u){ const found=new Set(); if(!u) return found; const s=String(u).toLowerCase(); for(const sym of SYMBOLS){ const hints=(DOMAIN_HINTS[sym]||[]); for(const h of hints){ if(s.includes(String(h).toLowerCase())){ found.add(sym); break; } } } return found; }\n\nfunction catalystBoost(text){ const s=String(text||\"\").toLowerCase(); let b=0;\n  const KEYS=[\"guidance\",\"earnings\",\"eps\",\"revenue\",\"acquisition\",\"merger\",\"m&a\",\"buyback\",\"dividend\",\"downgrade\",\"upgrade\",\"price target\",\"pt\",\"rating\",\n              \"lawsuit\",\"ftc\",\"doj\",\"sec\",\"probe\",\"investigation\",\"resigns\",\"layoffs\",\"bankruptcy\",\"recall\",\"fda\",\"outlook\",\"forecast\",\"prelim\",\n              \"miss\",\"beat\",\"warning\",\"contract\",\"order\",\"backlog\",\"antitrust\",\"data breach\",\"hack\",\"event\",\"launch\",\"unveil\",\"keynote\",\"livestream\",\"announcement\"];\n  for(const k of KEYS) if(s.includes(k)) b+=2;\n  if(/\\bq[1-4]\\s?[- ]?\\d{4}|fiscal|fy|quarter\\b/.test(s)) b+=1;\n  return b;\n}\nfunction normalizeTitle(t){ return normUp(String(t||\"\").replace(/\\s+/g,\" \").replace(/[\"']/g,\"\").trim()); }\n\nfunction domainPriority(h){\n  if(!h) return -1; h=h.toLowerCase();\n  if(/^sec\\.gov$/.test(h)) return 6;\n  if(/^(investor(s)?|ir)\\./.test(h)) return 5;\n  if(matchesHost(h,PUBLISHER_TIER1)) return 4;\n  if(matchesHost(h,PUBLISHER_TIER2)) return 3;\n  if(matchesHost(h,PUBLISHER_TIER3)) return 2;\n  if(matchesHost(h,PR_DOMAINS)) return 1;\n  return 0;\n}\nfunction relevanceScore(it){\n  const h=it.source || hostOf(it.link) || \"\"; const tier=siteTierHostOrUrl(h); let s=0;\n  s += catalystBoost(it.title)||0;\n  s += domainPriority(h)*1.2;\n  if(tier===1) s += 0.8; else if(tier===2) s += 0.4;\n  if(/\\b[A-Z]{1,6}\\b/.test(it.title)) s += 0.6;\n  if(Number.isFinite(it.age_days)) s += Math.max(0,3 - 0.2*it.age_days);\n  if(isPR(it.link)) s -= 0.5;\n  if(/^sec\\.gov$/i.test(h)) s += 1.5;\n  if(/^(investor(s)?|ir)\\./i.test(h)) s += 1.0;\n  return s;\n}\n\n// Promote corroborated Tier-3 (\u22652 hosts within 48h) if no Tier-1/2\nfunction promoteTier3Corroborated(items){\n  const byKey=new Map();\n  for(const it of items){ const k=storyKey(it.title_norm); if(!byKey.has(k)) byKey.set(k,[]); byKey.get(k).push(it); }\n  const promoted=new Set();\n  for(const arr of byKey.values()){\n    const has12=arr.some(a => (a.accept_level && a.accept_level <= 2));\n    if(has12) continue;\n    const t3=arr.filter(a=>a.accept_level===3);\n    if(t3.length<2) continue;\n    const hosts=new Set(t3.map(a=>a.source || hostOf(a.link) || \"\"));\n    if(hosts.size<2) continue;\n    const times=t3.map(a=>+new Date(a.published_at)).sort((a,b)=>a-b);\n    const within48 = (times.length>=2) && ((times[times.length-1]-times[0]) <= 48*3600*1000);\n    if(within48) for(const a of t3) promoted.add(a);\n  }\n  return promoted;\n}\nfunction storyKey(titleNorm){\n  return String(titleNorm||\"\")\n    .replace(/\\b(at|the|a|an|and|or|to|of|for|with)\\b/gi,\" \")\n    .replace(/[\\d$\u20ac\u00a3\u00a5.,:%]+/g,\" \")\n    .replace(/[^A-Z ]/gi,\" \")\n    .replace(/\\s+/g,\" \")\n    .trim().toUpperCase();\n}\nfunction pickCanonical(group){\n  let best=null,bestScore=-1e9;\n  for(const it of group){ const sc=relevanceScore(it); if(sc>bestScore){best=it;bestScore=sc;} it.__score=sc; }\n  best.__score=bestScore; return best;\n}\nfunction buildTop10(items){\n  const accepted=items.filter(a=>a.accept_level && a.accept_level<=2);\n  const base = accepted.length ? accepted.slice() : items.slice();\n  if(!accepted.length){\n    const promos=promoteTier3Corroborated(items);\n    if(promos.size) base.push(...items.filter(a=>promos.has(a)));\n  }\n  const clusters=new Map();\n  for(const it of base){ const k=storyKey(it.title_norm); if(!clusters.has(k)) clusters.set(k,[]); clusters.get(k).push(it); }\n  const reps=[]; for(const arr of clusters.values()) reps.push(pickCanonical(arr));\n  reps.sort((a,b)=> (b.__score - a.__score));\n  const top=reps.slice(0,10);\n  const top_text=top.map((h,i)=>`${i+1}. ${h.title} (${h.source || hostOf(h.link) || \"unknown\"}, ${h.published_at ? h.published_at.slice(0,10) : \"n/a\"}) \u2014 ${h.link}`).join(\"\\n\");\n  const top_titles_text=top.map((h,i)=>`${i+1}. ${h.title.replace(/\\s-\\s([^-]+)$/,'').trim()} (${h.published_at ? h.published_at.slice(0,10) : \"n/a\"})`).join(\"\\n\");\n  return { top, top_text, top_titles_text };\n}\n\n// Per-article symbol score (for assignment)\nfunction scoreSymbolForArticle(sym, ctx){\n  const { link, title, summary } = ctx;\n  let reasons=[]; let score=0;\n  const tier=siteTierHostOrUrl(ctx.tierHost || link);\n  if(ctx.urlSyms.has(sym))        { score+=4; reasons.push(\"url_symbol\"); }\n  if(ctx.strictTitleSyms.has(sym)){ score+=3; reasons.push(\"strict_ticker\"); }\n  if(ctx.aliasTextSyms.has(sym))  { score+=2; reasons.push(\"alias_text\"); }\n  if(ctx.aliasCatSyms.has(sym))   { score+=2; reasons.push(\"alias_category\"); }\n  if(ctx.domainSyms.has(sym))     { score+=2; reasons.push(\"domain_hint\"); }\n\n  if(sym===\"AI\" && reasons.includes(\"strict_ticker\")){\n    const d=ctx.strictDetail?.[\"AI\"]||{}; if(d.paren && !d.dollar && !d.exchange){ score-=3; reasons=reasons.filter(r=>r!==\"strict_ticker\"); }\n  }\n  score += catalystBoost(`${title} ${summary}`);\n  if(tier===1) score+=1; else if(tier===2) score+=0.5;\n  if(isPR(link)) score-=0.5;\n\n  if(tier===3){\n    const hasTitleHit = reasons.includes(\"strict_ticker\") || reasons.includes(\"alias_text\");\n    const hasCatalyst = catalystBoost(`${title} ${summary}`) > 0;\n    if(!hasTitleHit || !hasCatalyst) return { score:-1, pass:false };\n  }\n  if(tier===0 && !(reasons.includes(\"strict_ticker\") || reasons.includes(\"alias_text\"))) return { score:-1, pass:false };\n\n  const isAmb=AMBIGUOUS.has(sym); const policy=AMBIG_POLICY.special[sym]||AMBIG_POLICY.default;\n  let threshold=isAmb ? Math.max(policy.threshold||4,4) : (policy.threshold||2);\n  if(isAmb && (ctx.urlSyms.has(sym) || ctx.domainSyms.has(sym))) threshold=Math.max(2,threshold-1);\n\n  return { score, pass:(score>=threshold), tier };\n}\n\n//// ================== CLASSIFIERS (tags & signals) ================== ////\n// classify rich: tag + direction + PT dollars + rating keywords + insider\nfunction classifyRich(title){\n  const s=String(title||'').toLowerCase();\n\n  // PT\n  let ptDir=null;\n  if (/(price target|pt)\\s*(raised|hiked|lifted|boosted|to)/.test(s)) ptDir=\"up\";\n  if (/(price target|pt)\\s*(cut|lowered|reduced|trimmed|to)/.test(s))  ptDir=ptDir||\"down\";\n  const ptVals=[...title.matchAll(/\\$([0-9]+(?:\\.[0-9]+)?)/g)].map(m=>+m[1]);\n  if (/(to\\s*\\$[0-9])/i.test(title)) { /* captured above */ }\n\n  // rating\n  let rating=null, ratingDir=null;\n  if (/upgrade|upgraded|raises rating|raised to (buy|overweight|outperform)/.test(s)) ratingDir=\"up\";\n  if (/downgrade|downgraded|lowered to (hold|sell|underweight|underperform)/.test(s)) ratingDir=ratingDir||\"down\";\n  if (/\\b(overweight|outperform|buy|strong buy)\\b/.test(s)) rating=\"buyish\";\n  else if (/\\b(neutral|hold|market perform)\\b/.test(s)) rating=\"holdish\";\n  else if (/\\b(underweight|underperform|sell)\\b/.test(s)) rating=\"sellish\";\n\n  // insider\n  let insider=null;\n  if (/\\b(insider|form 4|director|ceo|cfo|chair|officer|sen\\.)\\b/.test(s)) {\n    if (/\\b(sell|sells|sold|disposes|trims|reduces)\\b/.test(s)) insider=\"sell\";\n    if (/\\b(buy|buys|bought|purchases|adds|increases)\\b/.test(s)) insider=insider||\"buy\";\n  }\n\n  // guidance\n  let guide=null;\n  if (/\\b(raises|boosts|hikes)\\b.*\\b(guidance|outlook|forecast)\\b/.test(s)) guide=\"up\";\n  if (/\\b(cuts|lowers|trims|reduces|warns)\\b.*\\b(guidance|outlook|forecast)\\b/.test(s)) guide=guide||\"down\";\n\n  // product/regulatory/M&A\n  const isProduct = /\\b(iphone|ipad|mac|watch|airpods|vision pro|launch|release|preorder|announce|event|keynote)\\b/.test(s);\n  const isReg     = /\\b(antitrust|ftc|doj|sec|probe|investigation|lawsuit|class action|fine|settlement|recall|fda)\\b/.test(s);\n  const isMA      = /\\b(acquire|acquisition|merger|takeover|deal|bid)\\b/.test(s);\n  const isBuyback = /\\b(buyback|repurchase)\\b/.test(s);\n  const isDiv     = /\\b(dividend)\\b/.test(s);\n  const isEarn    = /\\b(earnings|results|eps|revenue|quarter|q[1-4]\\b|fiscal)\\b/.test(s);\n\n  // primary tag\n  let tag = \"other\";\n  if (insider===\"sell\") tag=\"insider_sell\";\n  else if (insider===\"buy\") tag=\"insider_buy\";\n  else if (ptDir===\"up\") tag=\"PT\u2191\";\n  else if (ptDir===\"down\") tag=\"PT\u2193\";\n  else if (ratingDir===\"up\") tag=\"rating\u2191\";\n  else if (ratingDir===\"down\") tag=\"rating\u2193\";\n  else if (guide===\"up\") tag=\"guide\u2191\";\n  else if (guide===\"down\") tag=\"guide\u2193\";\n  else if (isProduct) tag=\"product\";\n  else if (isReg) tag=\"reg\";\n  else if (isMA) tag=\"M&A\";\n  else if (isEarn) tag=\"earn\";\n\n  return { tag, ptDir, ptVals, rating, ratingDir, insider, guide, isProduct, isReg, isMA, isBuyback, isDiv, isEarn };\n}\n\nfunction stripUrls(s){ return String(s||'').replace(/\\s*https?:\\/\\/\\S+/g,'').trim(); }\nfunction stripParens(s){ return String(s||'').replace(/\\s*\\([^)]*\\)/g,'').trim(); }\nfunction cleanText(s){ return stripParens(stripUrls(s)).replace(/\\s{2,}/g,' ').trim(); }\nfunction publisherFrom(title, fallback){\n  if (fallback && fallback!==\"unknown\") return fallback;\n  const m = String(title||'').match(/\\s-\\s([^-]+)$/); return m ? m[1].trim() : '';\n}\nfunction gist(title){\n  let t = String(title||'').replace(/\\s-\\s([^-]+)$/,'').trim();\n  t = t.replace(/\\b(inc\\.?|nasdaq:?\\s*[a-z]+|nyse:?\\s*[a-z]+)\\b/ig,'').replace(/\\s{2,}/g,' ').trim();\n  return t.length>110 ? t.slice(0,110)+'\u2026' : t;\n}\n\n//// ============================= MAIN ============================== ////\nconst inputs = $input.all();\nconst rawArticles = [];\nfor (const it of inputs){\n  const v=it?.json ?? it; if(!v) continue;\n  if (Array.isArray(v)) for(const el of v) rawArticles.push(el?.json ?? el);\n  else if (v?.items && Array.isArray(v.items)) for(const el of v.items) rawArticles.push(el?.json ?? el);\n  else if (v?.articles && Array.isArray(v.articles)) for(const el of v.articles) rawArticles.push(el?.json ?? el);\n  else rawArticles.push(v);\n}\n\n// Parse forgiving: keep up to FALLBACK_MAX_AGE_DAYS (symbol fallback done later)\nconst parsed=[];\nfor(const it of rawArticles){\n  const { link, iso } = extractLinkAndTime(it);\n  let useISO = iso;\n  let source = hostOf(link) || \"unknown\";\n  // de-agg Google News & MSN\n  if (source===\"news.google.com\" || source.endsWith(\"msn.com\")){\n    const pubName = extractPublisherNameFromTitle(it?.title||\"\").toLowerCase().replace(/['']/g,\"'\");\n    if (NAME_TO_DOMAIN[pubName]) source = NAME_TO_DOMAIN[pubName];\n    else { for(const k of Object.keys(NAME_TO_DOMAIN)) if(pubName.includes(k)){ source=NAME_TO_DOMAIN[k]; break; } }\n  }\n  if(!useISO){\n    const tier=siteTierHostOrUrl(source||link);\n    if (ACCEPT_MISSING_TIME && tier>=ACCEPT_MISSING_TIME_MIN_TIER) useISO=new Date().toISOString();\n    else continue;\n  }\n  const { title, summary, content, categories, combined } = extractTextSurfaces(it);\n  const appleHint=/apple|iphone|ios/i.test(combined);\n  const forgivingCap=Math.max(FALLBACK_MAX_AGE_DAYS, appleHint ? (SYMBOL_AGE_OVERRIDE.AAPL || FALLBACK_MAX_AGE_DAYS) : FALLBACK_MAX_AGE_DAYS);\n  const a=ageDays(useISO); if (a>forgivingCap) continue;\n\n  parsed.push({ title:normWS(title), summary:normWS(summary), content, categories, combined,\n                link, source, published_at:useISO, age_days:+a.toFixed(2) });\n}\n\n// Assign symbols\nconst tickerData={}; // sym -> { items:[], seenKey:Set, seenTitle:Set }\nfor(const row of parsed){\n  const urlSyms = extractSymbolsFromUrl(row.link);\n  const strictTitle = strictTickerHits_inTitleSummary(row.title, row.summary);\n  const aliasText = aliasHits(row.combined);\n  const aliasCats = categoryAliasHits(row.categories);\n  const domainSyms = domainHits(row.link);\n\n  const ctx = { link:row.link, title:row.title, summary:row.summary,\n                urlSyms, strictTitleSyms:strictTitle.all, strictDetail:strictTitle.detail,\n                aliasTextSyms:aliasText, aliasCatSyms:aliasCats, domainSyms, tierHost:row.source };\n\n  const scored=[];\n  for(const sym of SYMBOLS){\n    const res=scoreSymbolForArticle(sym, ctx);\n    if(res.pass) scored.push({ sym, ...res });\n  }\n  if(!scored.length && urlSyms.size){\n    for(const sym of urlSyms) scored.push({ sym, score:3, tier:siteTierHostOrUrl(row.source||row.link), pass:true });\n  }\n  if(!scored.length) continue;\n\n  scored.sort((a,b)=>b.score-a.score);\n  const selected=scored.slice(0,MAX_SYMBOLS_PER_ARTICLE);\n\n  const titleNorm=normalizeTitle(row.title);\n  for(const pick of selected){\n    const sym=pick.sym;\n    if(!tickerData[sym]) tickerData[sym]={ items:[], seenKey:new Set(), seenTitle:new Set() };\n    if(tickerData[sym].seenTitle.has(titleNorm)) continue;\n    const key=`${normUp(row.title)}|${row.source}`; if(tickerData[sym].seenKey.has(key)) continue;\n    tickerData[sym].seenTitle.add(titleNorm); tickerData[sym].seenKey.add(key);\n\n    tickerData[sym].items.push({\n      title: row.title, source: row.source, link: row.link,\n      published_at: row.published_at, age_days: row.age_days,\n      accept_level: pick.tier, title_norm: titleNorm\n    });\n  }\n}\n\n// Build payload per symbol (forward-looking + signals)\nfunction buildPayload(sym, items, nowISO){\n  const sortedAll=[...items].sort((a,b)=> new Date(b.published_at) - new Date(a.published_at));\n  const now = new Date(nowISO || Date.now());\n\n  const baseCap=Math.max(BASE_MAX_AGE_DAYS, SYMBOL_AGE_OVERRIDE[sym] || BASE_MAX_AGE_DAYS);\n  const baseItems=sortedAll.filter(a=>a.age_days <= baseCap);\n\n  let { top, top_text, top_titles_text } = buildTop10(baseItems);\n  let news_sparse=false; let window_days=baseCap;\n\n  if(top.length<3){\n    const wideCap=Math.max(FALLBACK_MAX_AGE_DAYS, SYMBOL_AGE_OVERRIDE[sym] || FALLBACK_MAX_AGE_DAYS);\n    const wideItems=sortedAll.filter(a=>a.age_days <= wideCap);\n    const res=buildTop10(wideItems);\n    top=res.top; top_text=res.top_text; top_titles_text=res.top_titles_text;\n    news_sparse=true; window_days=wideCap;\n  }\n\n  // Build fresh (\u22645d) compact + source count\n  const seenKeys=new Set(top.map(h=>normalizeTitle(h.title)));\n  const fresh=sortedAll.filter(a=>a.age_days <= 5 && !seenKeys.has(normalizeTitle(a.title)));\n  const pubs=new Set();\n  const bullets=fresh.slice(0,10).map(a=>{\n    const pub=publisherFrom(a.title, a.source); if(pub) pubs.add(pub);\n    const rc=classifyRich(a.title);\n    return `- ${a.published_at.slice(0,10)} \u2022 ${rc.tag}${pub?` (${pub})`:''} \u2014 ${gist(a.title)}`;\n  });\n  const news_fresh_text = bullets.length ? bullets.join(\"\\n\") : \"(none)\";\n  const news_sources_count = pubs.size;\n  const news_event_window = fresh.length>0;\n\n  // Signals extraction (\u22647d)\n  const window7 = sortedAll.filter(a=>a.age_days <= 7);\n  const sig = {\n    insider: { sells:0, buys:0, items:[] },\n    pt: { up:0, down:0, upValues:[], downValues:[], last:null },\n    rating: { upgrades:0, downgrades:0, reiterates:0, initiations:0 },\n    guidance: { up:0, down:0 },\n    product: 0, regulatory: 0, MA: 0, buybackDiv: 0\n  };\n  for(const a of window7){\n    const pub=publisherFrom(a.title, a.source);\n    const rc=classifyRich(a.title);\n\n    if(rc.insider===\"sell\"){ sig.insider.sells++; if(sig.insider.items.length<6) sig.insider.items.push({date:a.published_at.slice(0,10), pub, action:\"sell\", t: gist(a.title)}); }\n    if(rc.insider===\"buy\"){ sig.insider.buys++; if(sig.insider.items.length<6) sig.insider.items.push({date:a.published_at.slice(0,10), pub, action:\"buy\", t: gist(a.title)}); }\n\n    if(rc.ptDir===\"up\"){ sig.pt.up++; if(rc.ptVals.length) sig.pt.upValues.push(...rc.ptVals); sig.pt.last = {date:a.published_at.slice(0,10), pub, dir:\"up\", v: rc.ptVals[0]||null, t:gist(a.title)}; }\n    if(rc.ptDir===\"down\"){ sig.pt.down++; if(rc.ptVals.length) sig.pt.downValues.push(...rc.ptVals); sig.pt.last = {date:a.published_at.slice(0,10), pub, dir:\"down\", v: rc.ptVals[0]||null, t:gist(a.title)}; }\n\n    if(rc.ratingDir===\"up\"){ sig.rating.upgrades++; }\n    else if(rc.ratingDir===\"down\"){ sig.rating.downgrades++; }\n    else if(/initiates|initiation|starts coverage/.test(a.title.toLowerCase())) sig.rating.initiations++;\n    else if(/reiterates|reaffirm/.test(a.title.toLowerCase())) sig.rating.reiterates++;\n\n    if(rc.guide===\"up\") sig.guidance.up++;\n    if(rc.guide===\"down\") sig.guidance.down++;\n\n    if(rc.isProduct) sig.product++;\n    if(rc.isReg) sig.regulatory++;\n    if(rc.isMA) sig.MA++;\n    if(rc.isBuyback || rc.isDiv) sig.buybackDiv++;\n  }\n  const mean = arr => arr.length ? +(arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2) : null;\n  sig.pt.meanUp = mean(sig.pt.upValues);\n  sig.pt.meanDown = mean(sig.pt.downValues);\n\n  // Forward heuristics (earnings window, opex, sector cycles)\n  function startOfDay(d){ const z=new Date(d); z.setHours(0,0,0,0); return z; }\n  function addDays(d,n){ const z=new Date(d); z.setDate(z.getDate()+n); return z; }\n  function isBiz(d){ const w=d.getDay(); return w>=1 && w<=5; }\n  function addBizDays(d,n){ let z=new Date(d), k=Math.abs(n), dir=n>=0?1:-1; while(k>0){ z=addDays(z,dir); if(isBiz(z)) k--; } return z; }\n  function thirdFriday(y,m){ const d=new Date(y,m,1); let cnt=0; while(d.getMonth()===m){ if(d.getDay()===5){ cnt++; if(cnt===3) return new Date(d); } d.setDate(d.getDate()+1);} return null; }\n  function nextOpex(from){ const y=from.getFullYear(), m=from.getMonth(); const tfThis=thirdFriday(y,m); if(tfThis && tfThis>=startOfDay(from)) return tfThis; return thirdFriday(m===11?y+1:y,(m+1)%12); }\n  function firstBizOfNextMonth(from){ const y=from.getFullYear(), m=from.getMonth(); let d=new Date(y,m+1,1); while(!isBiz(d)) d=addDays(d,1); return d; }\n  function thirdBizOfNextMonth(from){ const y=from.getFullYear(), m=from.getMonth(); let d=new Date(y,m+1,1), c=0; while(true){ if(isBiz(d)){ c++; if(c===3) return d; } d=addDays(d,1); } }\n\n  const EV_DELIVERY = new Set([\"TSLA\",\"NIO\",\"LI\",\"XPEV\",\"RIVN\"]);\n  const RETAIL_HOLIDAY = new Set([\"WMT\",\"TGT\",\"COST\",\"MCD\",\"SBUX\",\"DPZ\",\"CMG\",\"SG\",\"BROS\",\"RRGB\",\"DNUT\",\"CBRL\",\"SHAK\",\"TXRH\",\"WEN\",\"PZZA\",\"DRI\",\"BJRI\",\"PLAY\",\"JACK\",\"PTLO\",\"QSR\",\"EAT\",\"YUM\",\"LULU\",\"AEO\",\"UAA\",\"CROX\",\"RL\",\"SJM\",\"CELH\",\"MNST\",\"KO\",\"PEP\"]);\n  const TECH_MEGA = new Set([\"AAPL\",\"MSFT\",\"GOOGL\",\"AMZN\",\"META\",\"NVDA\",\"AVGO\"]);\n\n  function findLastEarningsDate(arr){\n    const KEY=/\\b(earnings?|results|eps|revenue|quarter|q[1-4]\\b|fiscal|guidance|conference call|prelim)\\b/i;\n    let best=null; for(const a of arr){ const t=String(a?.title_norm || a?.title || \"\"); if(KEY.test(t) && a?.published_at){ const dt=new Date(a.published_at); if(!best || dt>best) best=dt; } }\n    return best;\n  }\n\n  const lastEarn = findLastEarningsDate(sortedAll);\n  let earnEstDate=null, earnWinStart=null, earnWinEnd=null, earnConf=\"low\", earnMethod=null;\n  if(lastEarn){ earnEstDate=addDays(lastEarn,91); earnWinStart=addBizDays(earnEstDate,-5); earnWinEnd=addBizDays(earnEstDate,+5); earnConf=\"med\"; earnMethod=\"news_last_earnings+91d\"; }\n  const inEarningsWindow = (earnWinStart && earnWinEnd) ? (startOfDay(now)>=startOfDay(earnWinStart) && startOfDay(now)<=startOfDay(earnWinEnd)) : false;\n\n  const nextO = nextOpex(now); const dToOpex = nextO ? Math.round((startOfDay(nextO)-startOfDay(now))/86400000) : null;\n  const opexWindow = (dToOpex!=null) ? (dToOpex>=0 && dToOpex<=5) : false;\n\n  const m=now.getMonth();\n  const evDeliveries = EV_DELIVERY.has(sym) ? { first: firstBizOfNextMonth(now), third: thirdBizOfNextMonth(now) } : null;\n  const holidayRetail = RETAIL_HOLIDAY.has(sym) ? (m===10 || m===11) : null;\n  const aaplSeason = sym===\"AAPL\" ? (m===8 || m===9 || m===5) : null;\n\n  // Forward score (light touch)\n  let fwdScore=0; const fwdBullets=[];\n  if(inEarningsWindow){ fwdScore+=2; fwdBullets.push(`Earnings window ~${earnWinStart.toISOString().slice(0,10)}\u2013${earnWinEnd.toISOString().slice(0,10)}`); }\n  else if(earnEstDate){ const dte=Math.round((startOfDay(earnEstDate)-startOfDay(now))/86400000); if(dte>=0 && dte<=21){ fwdScore+=1; fwdBullets.push(`Earnings around ${earnEstDate.toISOString().slice(0,10)}`);} }\n  if(opexWindow && nextO){ fwdScore+=0.5; fwdBullets.push(`OPEX ${nextO.toISOString().slice(0,10)} (flow risk)`); }\n  if(evDeliveries){ const d1=evDeliveries.first.toISOString().slice(0,10), d3=evDeliveries.third.toISOString().slice(0,10); fwdScore+=0.5; fwdBullets.push(`EV deliveries window ${d1}\u2013${d3}`); }\n  if(holidayRetail){ fwdScore+=0.5; fwdBullets.push(`Holiday sales seasonality (Nov\u2013Dec)`); }\n  if(aaplSeason){ fwdScore+=0.3; fwdBullets.push(`AAPL product/WWDC seasonality`); }\n  // News-driven forward nudges:\n  if(sig.rating.upgrades) fwdScore+=0.3;\n  if(sig.rating.downgrades) fwdScore-=0.3;\n  if(sig.pt.up) fwdScore+=0.3;\n  if(sig.pt.down) fwdScore-=0.3;\n  if(sig.guidance.up) fwdScore+=0.5;\n  if(sig.guidance.down) fwdScore-=0.5;\n  if(sig.insider.sells>=2) fwdScore-=0.5;\n  if(sig.insider.buys>=2) fwdScore+=0.3;\n  if(sig.product>=1) fwdScore+=0.3;\n\n  const forward = {\n    earnings: { estimateDate: earnEstDate?earnEstDate.toISOString().slice(0,10):null,\n                windowStart: earnWinStart?earnWinStart.toISOString().slice(0,10):null,\n                windowEnd: earnWinEnd?earnWinEnd.toISOString().slice(0,10):null,\n                confidence: earnConf, method: earnMethod },\n    opex: { date: nextO?nextO.toISOString().slice(0,10):null, daysTo: dToOpex, inWindow5d: opexWindow },\n    sectorCycles: { evDeliveries: evDeliveries?{first:evDeliveries.first.toISOString().slice(0,10), third:evDeliveries.third.toISOString().slice(0,10)}:null,\n                    holidayRetail, aaplProductSeason: aaplSeason },\n    score: +fwdScore.toFixed(2),\n    bullets: fwdBullets\n  };\n  const forward_event_window = Boolean(inEarningsWindow || opexWindow || fwdBullets.length);\n\n  return {\n    symbol: sym,\n    top10_text: top_text || \"\",\n    top10_titles_text: top_titles_text || \"\",\n    top10: top || [],\n    articles: sortedAll || [],\n    news_fresh_text,\n    news_sources_count,\n    news_event_window,\n    news_sparse,\n    news_window_days: window_days,\n    signals: sig,\n    forward,\n    forward_score: forward.score,\n    forward_event_window,\n    bullets_forward: fwdBullets\n  };\n}\n\n// Emit results\nconst results=[];\nconst nowISO = new Date().toISOString();\nif(EMIT_ALL_SYMBOLS){\n  for(const sym of SYMBOLS){\n    const items=tickerData[sym]?.items ?? [];\n    results.push({ json: buildPayload(sym, items, nowISO) });\n  }\n} else {\n  for(const sym of Object.keys(tickerData)){\n    results.push({ json: buildPayload(sym, tickerData[sym].items, nowISO) });\n  }\n}\n\n// Sort by coverage\nresults.sort((a,b)=> ((b.json.top10?.length||0) - (a.json.top10?.length||0)));\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        208
      ],
      "id": "72932876-3511-4095-b1ec-e018e253f533",
      "name": "Headlines data",
      "retryOnFail": true,
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "url": "=https://news.google.com/rss/search?q={{$json.symbol}}%20stock&hl=en-US&gl=US&ceid=US:en&when=7d",
        "options": {
          "ignoreSSL": true
        }
      },
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        -80,
        208
      ],
      "id": "8fcef44b-a0f1-4111-a7d9-8845a9dbb551",
      "name": "Ticker Websites/News",
      "retryOnFail": false,
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "symbol",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        416,
        112
      ],
      "id": "ebf694be-42e3-4d02-bc60-ac17e7cd6df0",
      "name": "News/price movement"
    },
    {
      "parameters": {
        "jsCode": "// Signal Board \u2014 TA-aware ranking v2.1 (neutralized for direction bias)\n\nconst inputItems = $input.all();\n\nfunction nz(x, d=0){ return Number.isFinite(x) ? x : d; }\nfunction clamp01(x){ return Math.max(0, Math.min(1, x)); }\nfunction volRank(v){ v = String(v||\"\").toLowerCase(); return v===\"high\"?2 : v===\"med\"?1 : 0; }\nfunction agreeRank(a){ a = String(a||\"\").toLowerCase(); return a===\"agree\"?2 : a===\"mixed\"?1 : 0; }\nfunction alignRank(a){ a = String(a||\"\").toLowerCase(); return a===\"with\"?2 : a===\"unclear\"?1 : 0; }\nfunction evidenceOf(s){\n  return Number.isFinite(s.sources_count) ? s.sources_count\n       : Number.isFinite(s.evidence_count) ? s.evidence_count\n       : 0;\n}\nfunction hasInsider(redFlags=[]) {\n  const rf = (redFlags || []).map(x => String(x||'').toLowerCase());\n  return rf.some(x => x.includes('insider'));\n}\n\nconst recs = inputItems\n  .map(it => it.json?.signal || it.json)\n  .filter(s => s && s.symbol);\n\nconst scored = recs.map(s => {\n  const conf = clamp01(nz(s.confidence, 0.35));\n\n  // Direction strength (grade or |W|)\n  const gradeAbs = Math.abs(nz(s.direction_grade, 0));   // 0..2\n  const wAbs     = Math.abs(nz(s.direction_score, 0));   // 0..10\n  const gradeStr = clamp01(gradeAbs / 2);\n  const wStr     = clamp01(wAbs / 10);\n  const dirStrength = Math.max(gradeStr, wStr);\n\n  // Event freshness (<=5d) small positive\n  let eventBoost = 0;\n  if (s.event_window) {\n    const age = nz(s.news_age_days, 2.5);\n    const fresh = clamp01((5 - age) / 5);\n    eventBoost = 0.05 * fresh;\n  }\n\n  // Sources / evidence\n  const src = evidenceOf(s);\n  const sourcesBoost  = 0.05 * clamp01(src / 4);\n  const evidenceBoost = (!Number.isFinite(s.sources_count) && Number.isFinite(s.evidence_count))\n    ? 0.04 * clamp01(s.evidence_count / 6)\n    : 0;\n\n  // Agreement & price alignment (symmetric)\n  const agreement = String(s.agreement||'mixed').toLowerCase();\n  const agreeAdj  = agreement === 'agree' ? +0.02 : agreement === 'disagree' ? -0.02 : 0.00;\n\n  const palign = String(s.price_alignment||'unclear').toLowerCase();\n  const priceAdj = palign === 'with' ? +0.02 : palign === 'against' ? -0.02 : 0.00;\n\n  // Volatility context \u2014 tiny\n  const vRank = volRank(s.vol_bias);\n  const volAdj = vRank === 2 ? +0.01 : vRank === 1 ? +0.005 : 0;\n\n  // Polarity-aware flags\n  // Negative flags/insider SELL are risk to longs; for shorts they are supportive (no penalty; small bonus).\n  const reds = (s.red_flags || []).length;\n  const isLong  = s.direction_bias === 1;\n  const isShort = s.direction_bias === -1;\n\n  const redPenaltyLong = 0.02 * Math.min(reds, 3);   // up to -0.06, but only for longs\n  const redAdj = isLong ? -redPenaltyLong : 0.00;\n\n  const insider = hasInsider(s.red_flags);\n  const insiderAdj = insider\n    ? (isLong ? -0.04 : isShort ? +0.02 : 0.00)       // penalize longs; slight bonus to shorts\n    : 0.00;\n\n  let score = (0.70 * conf) + (0.20 * dirStrength)\n            + (eventBoost + sourcesBoost + evidenceBoost + agreeAdj + priceAdj + volAdj)\n            + (redAdj + insiderAdj);\n\n  score = clamp01(score);\n\n  return {\n    ...s,\n    _components: {\n      conf, dirStrength, eventBoost, sourcesBoost, evidenceBoost,\n      agreeAdj, priceAdj, volAdj, redAdj, insiderAdj\n    },\n    score\n  };\n});\n\nconst cmp = (a, b) =>\n  (b.score - a.score) ||\n  (Math.abs(nz(b.direction_grade,0)) - Math.abs(nz(a.direction_grade,0))) ||\n  (Math.abs(nz(b.direction_score,0)) - Math.abs(nz(a.direction_score,0))) ||\n  ((b.event_window?1:0) - (a.event_window?1:0)) ||\n  (b.confidence - a.confidence) ||\n  (evidenceOf(b) - evidenceOf(a)) ||\n  (agreeRank(b.agreement) - agreeRank(a.agreement)) ||\n  (volRank(b.vol_bias) - volRank(a.vol_bias)) ||\n  ((a.red_flags?.length||0) - (b.red_flags?.length||0)) ||\n  (alignRank(b.price_alignment) - alignRank(a.price_alignment)) ||\n  String(a.symbol).localeCompare(String(b.symbol));\n\nconst bullish = scored.filter(x => x.direction_bias === 1).sort(cmp);\nconst bearish = scored.filter(x => x.direction_bias === -1).sort(cmp);\nconst neutral = scored.filter(x => x.direction_bias === 0).sort(cmp);\n\nreturn [{\n  json: {\n    counts: {\n      total: scored.length,\n      bull: bullish.length,\n      bear: bearish.length,\n      neutral: neutral.length,\n      event_window: scored.filter(x=>x.event_window).length\n    },\n    top5_bull:  bullish.slice(0,5).map(({symbol, score, confidence, event_window}) => ({symbol, score, confidence, event_window})),\n    top5_bear:  bearish.slice(0,5).map(({symbol, score, confidence, event_window}) => ({symbol, score, confidence, event_window})),\n    top5_neutral: neutral.slice(0,5).map(({symbol, score, confidence, event_window}) => ({symbol, score, confidence, event_window})),\n    all_scored: scored\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        464
      ],
      "id": "fa0de12b-7318-49db-9850-2dd5a27392c6",
      "name": "Signal Board"
    },
    {
      "parameters": {
        "jsCode": "// Input: 1 item with { counts, all_scored: [...] }\n\nconst board = items[0].json;\n\n// IDs\nconst now = new Date();\nconst pad = n => String(n).padStart(2, '0');\nconst run_id = `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}`;\nconst asof = now.toISOString();\n\n// map boolean+age -> hard/soft/none\nfunction eventTag(x) {\n  if (!x.event_window) return 'none';\n  const d = x.news_age_days ?? 99;\n  if (d <= 1) return 'hard';\n  if (d <= 3) return 'soft';\n  return 'none';\n}\n\n// prune to non-neutral & shape per-symbol objects\nconst symbols = (board.all_scored || [])\n  .filter(x => Math.abs(x.direction_bias || 0) !== 0)\n  .map(x => ({\n    symbol: x.symbol,\n    direction_bias: x.direction_bias,\n    confidence: x.confidence,\n    vol_bias: x.vol_bias,\n    event_window: eventTag(x),\n    catalyst: x.catalyst_type_final || null,\n    news_age_days: x.news_age_days ?? null,\n    score: x.score,\n    red_flags: x.red_flags || [],\n    // keep raw for debugging if you want:\n    payload_json: x\n  }));\n\nreturn [{\n  json: {\n    run_id,\n    asof,\n    universe: 'restaurants20',\n    pruned_count: symbols.length,\n    counts: board.counts || {},\n    symbols\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        432,
        464
      ],
      "id": "20dd64de-275c-4da0-bee2-9418ab17d5d9",
      "name": "Finalize and Fan Out"
    },
    {
      "parameters": {
        "jsCode": "// Input from Webhook looks like: { headers, params, query, body:{...} }\n// This normalizes either Webhook (has .body) or direct object.\nconst src = items[0]?.json ?? {};\nconst b = src.body ?? src;\n\n// Expect b.symbols = [{ symbol, direction_bias, confidence, vol_bias, event_window, score, ... }]\nconst syms = Array.isArray(b.symbols) ? b.symbols : [];\nif (syms.length === 0) return []; // nothing to do on pure cron runs (until a board is posted)\n\nreturn syms.map(s => ({\n  json: {\n    // run metadata\n    run_id: b.run_id,\n    asof: b.asof,\n\n    // core fields for gating/scoring\n    symbol: s.symbol,\n    direction_bias: s.direction_bias,\n    confidence: s.confidence,\n    vol_bias: s.vol_bias,\n    event_window: s.event_window, // already hard/soft/none from the board step\n    score: s.score,\n\n    // extra signal context (for logs/reasons)\n    catalyst: s.catalyst ?? s.catalyst_type_final ?? s.payload_json?.catalyst_type_final ?? null,\n    news_age_days: s.news_age_days ?? s.payload_json?.news_age_days ?? null,\n    red_flags: s.red_flags ?? s.payload_json?.red_flags ?? [],\n    bullets: Array.isArray(s.bullets) ? s.bullets : (s.payload_json?.bullets ?? []),\n    evidence_count: s.payload_json?.evidence_count ?? null,\n    agreement: s.payload_json?.agreement ?? null,\n    price_alignment: s.payload_json?.price_alignment ?? null,\n    event_strength: s.payload_json?.event_strength ?? null,\n\n    // keep full raw signal for future use\n    signal_raw: s.payload_json ?? s\n  }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        976,
        448
      ],
      "id": "9074e0ef-67d9-439f-ab17-9383853b92f0",
      "name": "Emit Symbols"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 30,50 9 * * 1-5"
            },
            {
              "field": "cronExpression",
              "expression": "0 10,30,50 10-14 * * 1-5"
            },
            {
              "field": "cronExpression",
              "expression": "0 10,30,50 15 * * 1-5"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -368,
        -512
      ],
      "id": "91026512-a637-4da0-b37f-068bc146b3c1",
      "name": "Hourly Market Run",
      "notesInFlow": true,
      "notes": "Runs daily at 09:31 America/New_York. Kicks off Smallscap PREOPEN.\n"
    },
    {
      "parameters": {
        "jsCode": "/**\n * CandidateGen v3.4 \u2014 Directional-Only (Any Expiries) with Risk Appetite + SignalRaw passthrough\n * Strategy names normalized:\n *   \"Bull Call Spread\", \"Bull Put Spread\", \"Bear Call Spread\", \"Bear Put Spread\",\n *   \"Long Call\", \"Long Put\", \"Short Call\", \"Short Put\"\n * Keeps unlimited-risk shorts (Short Call). Short Put assumed CASH-SECURED (no naked SP).\n * Counter-trend plays are gated when signal is decisive.\n * Adds execution price ranges (target & worst) and mildly prefers spreads.\n * Output schema and field names are unchanged.\n */\n\n// ================= CONFIG =================\nconst CFG = {\n  riskAppetite: 0.8,   // 8/10 risk-on\n\n  dteMin: 1,\n  dteMax: 60,\n\n  thresholds: {\n    maxBA_single: 0.16,\n    maxBA_spread: 0.22,\n    minCredit: 0.12,\n    minDebit: 0.15,\n    rrFloorCredit: 0.22,\n    rrFloorDebit: 0.55\n  },\n\n  deltaTargets: {\n    creditShort: 0.25,\n    debitLong: 0.45,\n    cspDelta: 0.25\n  },\n\n  singleLeg: {\n    maxCost: 12.00,\n    preferredCost: 2.50,\n    deltaMin: 0.12,\n    deltaMax: 0.88\n  },\n\n  dtePeaks: [10, 30],\n  dteWidth: 10,\n\n  // Counter-trend gating\n  allowCounterTrend: false,\n  biasGate: { minAbs: 0.35, minConf: 0.55 },\n\n  // Structure bias (mild preference for spreads; softened to improve mix)\n  structure: {\n    spreadProfitBoost: 1.12,   // was 1.15\n    singleProfitCut: 0.95,     // was 0.90\n    spreadBonusPts: 3,         // was 4\n    singlePenaltyPts: -1       // was -2\n  },\n\n  // Profit symmetry for CREDIT & DEBIT spreads (balanced mix)\n  mix: {\n    spreadRRDivisor: 2.1\n  },\n\n  topN: 8\n};\n\nconst MEGA_STOCKS = new Set([\"AAPL\",\"MSFT\",\"NVDA\",\"AMZN\",\"META\",\"GOOG\",\"GOOGL\",\"TSLA\",\"AVGO\",\"AMD\",\"TSM\",\"QCOM\",\"NFLX\",\"SPY\",\"QQQ\"]);\n\n// ================= HELPERS =================\nconst asNum = (x, def = 0) => Number.isFinite(+x) ? +x : def;\nconst clamp = (x, min = 0, max = 1) => Math.min(max, Math.max(min, x));\nconst median = (arr) => { if (!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b), m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; };\nconst avg = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;\nconst round2 = (x) => Math.round(x*100)/100;\nconst round3 = (x) => Math.round(x*1000)/1000;\n\nconst now = new Date();\nconst toDate = (d) => { const t = new Date(d); return Number.isNaN(t.getTime()) ? null : t; };\nconst dte = (expDate) => { const t = toDate(expDate); return t ? Math.ceil((t - now) / 86400000) : Infinity; };\n\nconst normSym = (s) => String(s||'').toUpperCase().replace(/^O:/,'').replace(/[^A-Z0-9.\\-]/g,'');\n\nfunction dteScore(d) {\n  let best = 0;\n  for (const p of CFG.dtePeaks) {\n    const s = clamp(1 - Math.abs(d - p)/(CFG.dteWidth || 1), 0, 1);\n    best = Math.max(best, s);\n  }\n  const nearBias = clamp(1 - Math.abs(d - CFG.dtePeaks[0])/(CFG.dteWidth || 1), 0, 1);\n  return clamp(0.75*best + 0.25*nearBias*CFG.riskAppetite, 0, 1);\n}\n\nfunction averageBA(legs) {\n  const xs = legs.map(l => l.baPct ?? l.bidAsk ?? 0.2);\n  return avg(xs);\n}\n\nfunction opSign(strategy) {\n  if (strategy === 'Bull Put Spread' || strategy === 'Bull Call Spread' || strategy === 'Long Call' || strategy === 'Short Put') return +1;\n  if (strategy === 'Bear Call Spread' || strategy === 'Bear Put Spread' || strategy === 'Long Put' || strategy === 'Short Call') return -1;\n  return 0;\n}\n\nfunction allowedDirection(signal) {\n  const absBias = Math.abs(signal.bias || 0);\n  const conf = signal.conf || 0;\n  if (CFG.allowCounterTrend || absBias < CFG.biasGate.minAbs || conf < CFG.biasGate.minConf) return 'both';\n  return (signal.bias > 0) ? 'bull' : 'bear';\n}\n\nfunction matchesDirection(strategySign, allow) {\n  if (allow === 'both' || strategySign === 0) return true;\n  return (allow === 'bull' && strategySign > 0) || (allow === 'bear' && strategySign < 0);\n}\n\n// Expected execution range (no mid assumption) \u2014 cap BA to avoid absurd slips\nfunction buildExecution(side, mid, baPct) {\n  const b = Math.min(baPct ?? 0, 0.50);\n  const tSlip = Math.min(0.25*b + (side==='debit'?0.015:0.01), 0.30);\n  const wSlip = Math.min(0.65*b + (side==='debit'?0.02:0.015), 0.40);\n  const target = side==='debit' ? mid*(1+tSlip) : mid*(1 - tSlip);\n  const worst  = side==='debit' ? mid*(1+wSlip) : mid*(1 - wSlip);\n  return { side, mid: round2(mid), target: round2(target), worst: round2(worst) };\n}\n\n// ================= INPUT PARSING =================\nfunction parseContract(item) {\n  const data = item.json || item;\n  const c = data.results?.[0] || data;\n  if (!c.details) return null;\n\n  const d = c.details;\n  const g = c.greeks || {};\n  const day = c.day || {};\n\n  let underlying = c.underlying_asset?.ticker;\n  if (!underlying && d.ticker) {\n    const m = d.ticker.match(/O:([A-Z.]+)\\d{6}[CP]\\d{8}/);\n    underlying = m ? m[1] : d.ticker.replace(/^O:/,'').match(/^[A-Z.]+/)?.[0];\n  }\n  underlying = normSym(underlying);\n  if (!underlying) return null;\n\n  const qBid = asNum(c.bid ?? day.bid ?? 0, 0);\n  const qAsk = asNum(c.ask ?? day.ask ?? 0, 0);\n  let mid = asNum(c.mid ?? ((qBid > 0 && qAsk > 0) ? (qBid + qAsk) / 2 : (day.close ?? day.vwap ?? 0)), 0);\n  let baPct = asNum(c.baPct ?? ((qBid > 0 && qAsk > 0 && mid > 0) ? (qAsk - qBid) / mid : 0.99), 0.99);\n\n  if (mid <= 0) {\n    const marketPrice = asNum(day.close ?? day.vwap, 0);\n    const dayRange = (day.high && day.low) ? Math.abs(day.high - day.low) : 0;\n    const estBA = (dayRange > 0 && marketPrice > 0) ? Math.min(0.50, dayRange / marketPrice) : 0.10;\n    mid = marketPrice;\n    baPct = Math.min(estBA, 0.50);\n  }\n  if (mid <= 0) return null;\n\n  const iv = asNum(c.implied_volatility ?? g.implied_volatility, 0.40);\n\n  return {\n    ticker: d.ticker,\n    underlying,\n    expiration: d.expiration_date,\n    strike: asNum(d.strike_price, 0),\n    type: (d.contract_type || 'call').toUpperCase(),\n\n    bid: round3(qBid > 0 ? qBid : mid * (1 - baPct/2)),\n    ask: round3(qAsk > 0 ? qAsk : mid * (1 + baPct/2)),\n    mid: round3(mid),\n    baPct,\n\n    delta: asNum(g.delta, null),\n    gamma: asNum(g.gamma, null),\n    theta: asNum(g.theta, null),\n    vega: asNum(g.vega, null),\n    iv,\n\n    volume: asNum(day.volume, 0),\n    oi: asNum(c.open_interest, 0),\n\n    dte: Number.isFinite(c.dte) ? c.dte : dte(d.expiration_date),\n    dayChangePercent: asNum(day.change_percent, 0)\n  };\n}\n\nfunction analyzeChain(contracts) {\n  if (!contracts.length) return null;\n  const ivs = contracts.map(c=>c.iv).filter(Number.isFinite);\n  const spreads = contracts.map(c=>c.baPct).filter(v=>v<0.99);\n  const vols = contracts.map(c=>c.volume).filter(v=>v>0);\n  const ois = contracts.map(c=>c.oi).filter(v=>v>0);\n\n  const avgIV = ivs.length ? avg(ivs) : 0.40;\n  const medianSpread = median(spreads) || 0.15;\n  const totalVolume = vols.reduce((a,b)=>a+b,0);\n  const avgOI = ois.length ? avg(ois) : 0;\n\n  let regime = 'NORMAL';\n  if (avgIV > 0.65) regime = 'HIGH_VOL';\n  else if (avgIV < 0.25) regime = 'LOW_VOL';\n\n  const byExp = new Map();\n  for (const c of contracts) {\n    if (c.dte < CFG.dteMin || c.dte > CFG.dteMax) continue;\n    const k = c.expiration;\n    if (!byExp.has(k)) byExp.set(k, { calls:[], puts:[], dte:c.dte });\n    (c.type === 'CALL' ? byExp.get(k).calls : byExp.get(k).puts).push(c);\n  }\n  for (const e of byExp.values()) {\n    e.calls.sort((a,b)=>a.strike-b.strike);\n    e.puts.sort((a,b)=>a.strike-b.strike);\n  }\n\n  return {\n    avgIV, medianSpread, totalVolume, avgOI,\n    regime,\n    liquidityScore: clamp(\n      0.45*(1 - medianSpread/0.32) +\n      0.30*Math.min(1, Math.log10(1+totalVolume)/4) +\n      0.25*Math.min(1, Math.log10(1+avgOI)/3), 0, 1\n    ),\n    contractCount: contracts.length,\n    expirations: byExp\n  };\n}\n\n// ================= DYNAMIC PARAMS =================\nfunction getDynamicThresholds(chainStats, symbol) {\n  const t = { ...CFG.thresholds };\n  const RA = CFG.riskAppetite;\n  const isMega = MEGA_STOCKS.has(symbol);\n\n  if (chainStats.regime === 'HIGH_VOL') {\n    t.maxBA_single *= 1.25;\n    t.maxBA_spread *= 1.25;\n    t.minCredit *= 1.35;\n    t.rrFloorCredit *= 0.9;\n    t.rrFloorDebit *= 0.9;\n  } else if (chainStats.regime === 'LOW_VOL') {\n    t.maxBA_single *= 0.90;   // slightly looser than before for risk-on\n    t.maxBA_spread *= 0.92;\n    t.minCredit *= 0.95;      // easier to include BPS in low vol\n    t.rrFloorCredit *= 1.02;\n    t.rrFloorDebit *= 1.02;\n  }\n\n  if (chainStats.liquidityScore < 0.3) {\n    t.maxBA_single = Math.min(0.50, t.maxBA_single * 1.5);\n    t.maxBA_spread = Math.min(0.45, t.maxBA_spread * 1.4);\n  }\n\n  if (isMega) {\n    t.maxBA_single = Math.min(t.maxBA_single, 0.12);\n    t.maxBA_spread = Math.min(t.maxBA_spread, 0.15);\n  }\n\n  // Risk-on tilt: accept a bit more risk & broaden candidate set\n  if (RA >= 0.75) {\n    t.rrFloorCredit *= 0.90;\n    t.rrFloorDebit  *= 0.90;\n    t.minCredit     *= 0.95;\n    t.minDebit      *= 0.95;\n    t.maxBA_single   = Math.min(0.40, t.maxBA_single * 1.10);\n    t.maxBA_spread   = Math.min(0.35, t.maxBA_spread * 1.10);\n  }\n\n  // keep subtle risk-on tilt\n  t.rrFloorCredit *= (1 - 0.20*RA + 0.04);\n  t.rrFloorDebit  *= (1 - 0.18*RA + 0.04);\n\n  return t;\n}\n\nfunction getDynamicDeltas(chainStats) {\n  const d = { ...CFG.deltaTargets };\n  if (chainStats.regime === 'HIGH_VOL') {\n    d.creditShort = 0.22;\n    d.debitLong   = 0.40;\n  } else if (chainStats.regime === 'LOW_VOL') {\n    d.creditShort = 0.28;\n    d.debitLong   = 0.50;\n  }\n  const RA = CFG.riskAppetite;\n  d.creditShort = clamp(d.creditShort + 0.03*(RA-0.5), 0.15, 0.35);\n  d.debitLong   = clamp(d.debitLong   + 0.04*(RA-0.5), 0.35, 0.60);\n  return d;\n}\n\nfunction getDynamicWeights(chainStats, signal) {\n  // Base\n  const base = { Liquidity: 25, Edge: 35, Profit: 30, PortFit: 7, RiskPen: 3 };\n\n  // Risk-on bias for RA\u22650.75\n  if (CFG.riskAppetite >= 0.75) {\n    base.Profit += 3;     // 33\n    base.Edge   += 1;     // 36\n    base.Liquidity -= 3;  // 22\n    base.RiskPen -= 1;    // 2\n  }\n\n  if (chainStats.regime === 'HIGH_VOL') {\n    base.Liquidity += 5;  // protect fill risk\n    base.RiskPen   += 5;\n    base.Profit    -= 5;\n    // still risk-on tilt\n    if (CFG.riskAppetite >= 0.75) {\n      base.Profit += 2;\n      base.RiskPen -= 2;\n    }\n  }\n\n  if (Math.abs(signal.bias) > 0.7 && signal.conf > 0.7) base.Edge = Math.min(45, base.Edge + 5);\n  if (chainStats.liquidityScore < 0.3) { base.Liquidity = 40; base.Edge = 30; base.Profit = 20; base.RiskPen = 10; }\n\n  return base;\n}\n\n// ================= UTILS FOR BUILDERS =================\nfunction byAbsDeltaTarget(list, target, maxBA) {\n  const flt = list.filter(x =>\n    x.delta != null &&\n    Math.abs(x.delta) >= CFG.singleLeg.deltaMin &&\n    Math.abs(x.delta) <= CFG.singleLeg.deltaMax &&\n    x.baPct <= maxBA && x.mid > 0\n  );\n  if (!flt.length) return null;\n  flt.sort((a,b)=>{\n    const da = Math.abs(Math.abs(a.delta) - target);\n    const db = Math.abs(Math.abs(b.delta) - target);\n    if (Math.abs(da-db) > 0.03) return da-db;\n    return a.baPct - b.baPct;\n  });\n  return flt[0];\n}\n\nfunction nearestStrikes(list, baseStrike, direction, maxSteps=6) {\n  const s = list.map(x=>x.strike);\n  const baseIdx = s.findIndex(k => Math.abs(k - baseStrike) < 0.01);\n  if (baseIdx < 0) return [];\n  const out = [];\n  for (let step=1; step<=maxSteps; step++) {\n    const idx = direction==='up' ? baseIdx+step : baseIdx-step;\n    if (idx>=0 && idx<list.length) out.push(s[idx]);\n  }\n  return out;\n}\n\nfunction pickByStrike(list, strike) { return list.find(x => Math.abs(x.strike - strike) < 0.01); }\nfunction longProfitScore(delta, debit) { return clamp((Math.abs(delta || 0) * 3.0) / Math.max(0.5, debit || 0.01), 0, 1); }\nfunction maybePush(cand, signal, allowDir, candidates) {\n  const sgn = opSign(cand.strategy);\n  if (!matchesDirection(sgn, allowDir)) return;\n  candidates.push(cand);\n}\n\n// ================= STRATEGY BUILDERS (named) =================\nfunction buildBPS(exp, puts, signal, thresholds, deltas) {\n  const short = byAbsDeltaTarget(puts, deltas.creditShort, thresholds.maxBA_single);\n  if (!short) return null;\n  const candidateStrikes = nearestStrikes(puts, short.strike, 'down', 6);\n  let best = null;\n\n  for (const k of candidateStrikes) {\n    const long = pickByStrike(puts, k); if (!long || long.mid <= 0) continue;\n    const width = short.strike - long.strike; if (width <= 0) continue;\n\n    const creditMid = short.mid - long.mid;\n    const legs = [\n      {role:'SHORT', type:'PUT', strike:short.strike, exp, mid:short.mid, baPct:short.baPct},\n      {role:'LONG',  type:'PUT', strike:long.strike,  exp, mid:long.mid,  baPct:long.baPct}\n    ];\n    const ba = averageBA(legs);\n    if (creditMid < thresholds.minCredit || ba > thresholds.maxBA_spread) continue;\n\n    const exec = buildExecution('credit', creditMid, ba);\n    const denomMid  = Math.max(0.01, width - creditMid);\n    const denomCons = Math.max(0.01, width - exec.worst);\n    const rr_mid = creditMid > 0 ? creditMid / denomMid : 0;\n    const rr_cons = exec.worst > 0 ? exec.worst / denomCons : 0;\n\n    const cand = {\n      strategy: 'Bull Put Spread',\n      legs,\n      metrics: {\n        credit: round2(creditMid),\n        width,\n        maxLoss: Math.round((width - creditMid) * 100),\n        rr: round3(rr_mid),\n        rr_conservative: round3(rr_cons),\n        dte: short.dte,\n        shortDelta: short.delta,\n        bidAskSpread: round3(ba)\n      },\n      execution: exec\n    };\n    if (!best || rr_mid > best.metrics.rr) best = cand;\n  }\n  if (!best) return null;\n\n  best.quality = {\n    liquidity: clamp(1 - best.metrics.bidAskSpread/0.30, 0, 1),\n    edge: opSign('Bull Put Spread') * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n    profit: clamp(best.metrics.rr / CFG.mix.spreadRRDivisor, 0, 1),\n    portFit: dteScore(best.metrics.dte),\n    risk: best.metrics.rr < thresholds.rrFloorCredit ? 0.35 : 0.12\n  };\n  return best;\n}\n\nfunction buildBCS(exp, calls, signal, thresholds, deltas) {\n  const short = byAbsDeltaTarget(calls, deltas.creditShort, thresholds.maxBA_single);\n  if (!short) return null;\n  const candidateStrikes = nearestStrikes(calls, short.strike, 'up', 6);\n  let best = null;\n\n  for (const k of candidateStrikes) {\n    const long = pickByStrike(calls, k); if (!long || long.mid <= 0) continue;\n    const width = long.strike - short.strike; if (width <= 0) continue;\n\n    const creditMid = short.mid - long.mid;\n    const legs = [\n      {role:'SHORT', type:'CALL', strike:short.strike, exp, mid:short.mid, baPct:short.baPct},\n      {role:'LONG',  type:'CALL', strike:long.strike,  exp, mid:long.mid,  baPct:long.baPct}\n    ];\n    const ba = averageBA(legs);\n    if (creditMid < thresholds.minCredit || ba > thresholds.maxBA_spread) continue;\n\n    const exec = buildExecution('credit', creditMid, ba);\n    const denomMid  = Math.max(0.01, width - creditMid);\n    const denomCons = Math.max(0.01, width - exec.worst);\n    const rr_mid = creditMid > 0 ? creditMid / denomMid : 0;\n    const rr_cons = exec.worst > 0 ? exec.worst / denomCons : 0;\n\n    const cand = {\n      strategy: 'Bear Call Spread',\n      legs,\n      metrics: {\n        credit: round2(creditMid),\n        width,\n        maxLoss: Math.round((width - creditMid) * 100),\n        rr: round3(rr_mid),\n        rr_conservative: round3(rr_cons),\n        dte: short.dte,\n        shortDelta: short.delta,\n        bidAskSpread: round3(ba)\n      },\n      execution: exec\n    };\n    if (!best || rr_mid > best.metrics.rr) best = cand;\n  }\n  if (!best) return null;\n\n  best.quality = {\n    liquidity: clamp(1 - best.metrics.bidAskSpread/0.30, 0, 1),\n    edge: opSign('Bear Call Spread') * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n    profit: clamp(best.metrics.rr / CFG.mix.spreadRRDivisor, 0, 1),\n    portFit: dteScore(best.metrics.dte),\n    risk: best.metrics.rr < thresholds.rrFloorCredit ? 0.35 : 0.12\n  };\n  return best;\n}\n\nfunction buildBCD(exp, calls, signal, thresholds, deltas) {\n  const long = byAbsDeltaTarget(calls, deltas.debitLong, thresholds.maxBA_single);\n  if (!long) return null;\n  const candidateStrikes = nearestStrikes(calls, long.strike, 'up', 6);\n  let best = null;\n\n  for (const k of candidateStrikes) {\n    const short = pickByStrike(calls, k); if (!short || short.mid <= 0) continue;\n    const width = short.strike - long.strike; if (width <= 0) continue;\n\n    const debitMid = long.mid - short.mid;\n    if (debitMid <= 0 || debitMid > CFG.singleLeg.maxCost || debitMid < thresholds.minDebit) continue;\n\n    const legs = [\n      {role:'LONG',  type:'CALL', strike:long.strike,  exp, mid:long.mid,  baPct:long.baPct},\n      {role:'SHORT', type:'CALL', strike:short.strike, exp, mid:short.mid, baPct:short.baPct}\n    ];\n    const ba = averageBA(legs);\n    if (ba > thresholds.maxBA_spread) continue;\n\n    const exec = buildExecution('debit', debitMid, ba);\n    const maxProfitMid = Math.max(0, width - debitMid);\n    const rr_mid = debitMid > 0 ? maxProfitMid / debitMid : 0;\n    const maxProfitCons = Math.max(0, width - exec.worst);\n    const rr_cons = exec.worst > 0 ? maxProfitCons / exec.worst : 0;\n\n    const cand = {\n      strategy: 'Bull Call Spread',\n      legs,\n      metrics: {\n        debit: round2(debitMid),\n        width,\n        maxProfit: Math.round(maxProfitMid * 100),\n        rr: round3(rr_mid),\n        rr_conservative: round3(rr_cons),\n        dte: long.dte,\n        longDelta: long.delta,\n        bidAskSpread: round3(ba)\n      },\n      execution: exec\n    };\n    if (!best || rr_mid > best.metrics.rr) best = cand;\n  }\n  if (!best) return null;\n\n  best.quality = {\n    liquidity: clamp(1 - best.metrics.bidAskSpread/0.30, 0, 1),\n    edge: opSign('Bull Call Spread') * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n    profit: clamp(best.metrics.rr / CFG.mix.spreadRRDivisor, 0, 1),\n    portFit: dteScore(best.metrics.dte),\n    risk: best.metrics.debit > CFG.singleLeg.preferredCost ? 0.25 : 0.12\n  };\n  return best;\n}\n\nfunction buildBPD(exp, puts, signal, thresholds, deltas) {\n  const long = byAbsDeltaTarget(puts, deltas.debitLong, thresholds.maxBA_single);\n  if (!long) return null;\n  const candidateStrikes = nearestStrikes(puts, long.strike, 'down', 6);\n  let best = null;\n\n  for (const k of candidateStrikes) {\n    const short = pickByStrike(puts, k); if (!short || short.mid <= 0) continue;\n    const width = long.strike - short.strike; if (width <= 0) continue;\n\n    const debitMid = long.mid - short.mid;\n    if (debitMid <= 0 || debitMid > CFG.singleLeg.maxCost || debitMid < thresholds.minDebit) continue;\n\n    const legs = [\n      {role:'LONG',  type:'PUT', strike:long.strike,  exp, mid:long.mid,  baPct:long.baPct},\n      {role:'SHORT', type:'PUT', strike:short.strike, exp, mid:short.mid, baPct:short.baPct}\n    ];\n    const ba = averageBA(legs);\n    if (ba > thresholds.maxBA_spread) continue;\n\n    const exec = buildExecution('debit', debitMid, ba);\n    const maxProfitMid = Math.max(0, width - debitMid);\n    const rr_mid = debitMid > 0 ? maxProfitMid / debitMid : 0;\n    const maxProfitCons = Math.max(0, width - exec.worst);\n    const rr_cons = exec.worst > 0 ? maxProfitCons / exec.worst : 0;\n\n    const cand = {\n      strategy: 'Bear Put Spread',\n      legs,\n      metrics: {\n        debit: round2(debitMid),\n        width,\n        maxProfit: Math.round(maxProfitMid * 100),\n        rr: round3(rr_mid),\n        rr_conservative: round3(rr_cons),\n        dte: long.dte,\n        longDelta: long.delta,\n        bidAskSpread: round3(ba)\n      },\n      execution: exec\n    };\n    if (!best || rr_mid > best.metrics.rr) best = cand;\n  }\n  if (!best) return null;\n\n  best.quality = {\n    liquidity: clamp(1 - best.metrics.bidAskSpread/0.30, 0, 1),\n    edge: opSign('Bear Put Spread') * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n    profit: clamp(best.metrics.rr / CFG.mix.spreadRRDivisor, 0, 1),\n    portFit: dteScore(best.metrics.dte),\n    risk: best.metrics.debit > CFG.singleLeg.preferredCost ? 0.25 : 0.12\n  };\n  return best;\n}\n\n// Long Call / Long Put\nfunction buildLong(exp, list, isCall, signal, thresholds, deltas) {\n  const long = byAbsDeltaTarget(list, deltas.debitLong, thresholds.maxBA_single);\n  if (!long) return null;\n  const debit = long.mid;\n  if (debit <= 0 || debit > CFG.singleLeg.maxCost || debit < thresholds.minDebit) return null;\n\n  const strat = isCall ? 'Long Call' : 'Long Put';\n  const legs = [{role:'LONG', type:isCall?'CALL':'PUT', strike:long.strike, exp, mid:debit, baPct:long.baPct}];\n  const ba = averageBA(legs);\n  const exec = buildExecution('debit', debit, ba);\n\n  const cand = {\n    strategy: strat,\n    legs,\n    metrics: {\n      debit: round2(debit),\n      dte: long.dte,\n      longDelta: long.delta,\n      bidAskSpread: round3(ba),\n      breakeven: isCall ? round2(long.strike + debit) : round2(long.strike - debit)\n    },\n    execution: exec,\n    quality: {\n      liquidity: clamp(1 - ba/0.30, 0, 1),\n      edge: opSign(strat) * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n      profit: longProfitScore(long.delta, debit),\n      portFit: dteScore(long.dte),\n      risk: debit > CFG.singleLeg.preferredCost ? 0.30 : 0.15\n    }\n  };\n  if (cand.metrics.bidAskSpread > thresholds.maxBA_single) return null;\n  return cand;\n}\n\n// Short Call / Short Put (Short Put assumed CSP; Short Call unlimited risk)\nfunction buildShort(exp, list, isCall, signal, thresholds, deltas) {\n  const short = byAbsDeltaTarget(list, deltas.creditShort, thresholds.maxBA_single);\n  if (!short) return null;\n\n  const credit = short.mid;\n  if (credit < thresholds.minCredit) return null;\n\n  const strat = isCall ? 'Short Call' : 'Short Put';\n  const legs = [{role:'SHORT', type:isCall?'CALL':'PUT', strike:short.strike, exp, mid:credit, baPct:short.baPct}];\n  const ba = averageBA(legs);\n  if (ba > thresholds.maxBA_single) return null;\n\n  const exec = buildExecution('credit', credit, ba);\n\n  let rr_mid = null, rr_cons = null, maxLoss = null;\n  if (!isCall) {\n    const maxLossMid = (short.strike - credit) * 100;\n    maxLoss = Math.round(maxLossMid);\n    rr_mid = credit / Math.max(1, (maxLossMid/100));\n    const maxLossCons = (short.strike - exec.worst) * 100;\n    rr_cons = exec.worst / Math.max(1, (maxLossCons/100));\n  }\n\n  return {\n    strategy: strat,\n    legs,\n    metrics: {\n      credit: round2(credit),\n      dte: short.dte,\n      shortDelta: short.delta,\n      bidAskSpread: round3(ba),\n      maxLoss,\n      rr: rr_mid != null ? round3(rr_mid) : null,\n      rr_conservative: rr_cons != null ? round3(rr_cons) : null,\n      unlimitedRisk: isCall ? true : false\n    },\n    execution: exec,\n    quality: {\n      liquidity: clamp(1 - ba/0.30, 0, 1),\n      edge: opSign(strat) * Math.sign(signal.bias) > 0 ? signal.conf : 0,\n      profit: clamp((credit / (credit + 1.0)) * 1.2, 0, 1),\n      portFit: dteScore(short.dte),\n      risk: isCall ? 0.90 : (rr_mid != null && rr_mid < thresholds.rrFloorCredit ? 0.40 : 0.18)\n    }\n  };\n}\n\n// ================= MAIN PROCESSING =================\nfunction processInput(items) {\n  const chainsBySymbol = new Map();\n  const signalsBySymbol = new Map();\n  const signalRefBySymbol = new Map(); // ONLY signal_raw\n  const debugInfo = { totalItems: items.length, contractsParsed: 0, signalsFound: 0, signalRefs: 0, errors: [], samples: [] };\n\n  for (let i = 0; i < items.length; i++) {\n    try {\n      const data = items[i].json || items[i];\n      if (i === 0) debugInfo.samples.push({ index: 0, keys: Object.keys(data), hasDetails: !!data.details, hasResults: !!data.results, hasDay: !!data.day });\n\n      const c = parseContract(items[i]);\n      if (c) {\n        if (!chainsBySymbol.has(c.underlying)) chainsBySymbol.set(c.underlying, []);\n        chainsBySymbol.get(c.underlying).push(c);\n        debugInfo.contractsParsed++;\n      }\n\n      if (data.signal_info || data.direction_bias !== undefined || data.signal_raw) {\n        const symbol = normSym(data.symbol || data.underlying_asset?.ticker || data.meta?.symbol);\n        if (symbol) {\n          signalsBySymbol.set(symbol, {\n            symbol,\n            bias: asNum(data.direction_bias ?? data.signal_info?.direction_bias ?? data.signal_raw?.direction_bias, 0),\n            conf: asNum(data.confidence ?? data.signal_info?.confidence ?? data.signal_raw?.confidence, 0.5),\n            volBias: (data.vol_bias ?? data.signal_info?.vol_bias ?? data.signal_raw?.vol_bias) || 'neutral',\n            tri: asNum(data.tri_confirm || 0, 0)\n          });\n          const raw = data.signal_raw ?? {\n            symbol,\n            direction_bias: asNum(data.direction_bias ?? 0, 0),\n            confidence: asNum(data.confidence ?? 0.5, 0.5),\n            vol_bias: data.vol_bias ?? 'neutral',\n            bullets: data.bullets ?? [],\n            red_flags: data.red_flags ?? []\n          };\n          signalRefBySymbol.set(symbol, raw);\n          debugInfo.signalRefs++;\n          debugInfo.signalsFound++;\n        }\n      }\n    } catch (e) {\n      debugInfo.errors.push(`Item ${i}: ${e.message}`);\n    }\n  }\n\n  if (signalsBySymbol.size === 0) {\n    for (const symbol of chainsBySymbol.keys()) {\n      signalsBySymbol.set(symbol, { symbol, bias: 0, conf: 0.5, volBias: 'neutral', tri: 0 });\n    }\n  }\n\n  const results = [];\n\n  for (const [symbol, contracts] of chainsBySymbol.entries()) {\n    const signal = signalsBySymbol.get(symbol) || { symbol, bias: 0, conf: 0.5, volBias: 'neutral', tri: 0 };\n    const signalRef = signalRefBySymbol.get(symbol) || null;\n\n    const chainStats = analyzeChain(contracts);\n    if (!chainStats) {\n      results.push({ symbol, signal, signalRef, error: 'CHAIN_ANALYSIS_FAILED', debug: { contractCount: contracts.length } });\n      continue;\n    }\n\n    const thresholds = getDynamicThresholds(chainStats, symbol);\n    const deltas = getDynamicDeltas(chainStats);\n    const weights = getDynamicWeights(chainStats, signal);\n    const allowDir = allowedDirection(signal);\n\n    const candidates = [];\n\n    for (const [exp, book] of chainStats.expirations.entries()) {\n      const { calls, puts } = book;\n\n      // Credit spreads\n      const bps = buildBPS(exp, puts, signal, thresholds, deltas);\n      if (bps) maybePush(bps, signal, allowDir, candidates);\n\n      const bcs = buildBCS(exp, calls, signal, thresholds, deltas);\n      if (bcs) maybePush(bcs, signal, allowDir, candidates);\n\n      // Debit spreads\n      const bcd = buildBCD(exp, calls, signal, thresholds, deltas);\n      if (bcd) maybePush(bcd, signal, allowDir, candidates);\n\n      const bpd = buildBPD(exp, puts, signal, thresholds, deltas);\n      if (bpd) maybePush(bpd, signal, allowDir, candidates);\n\n      // Longs\n      const lc = buildLong(exp, calls, true,  signal, thresholds, deltas);\n      if (lc) maybePush(lc, signal, allowDir, candidates);\n\n      const lp = buildLong(exp, puts,  false, signal, thresholds, deltas);\n      if (lp) maybePush(lp, signal, allowDir, candidates);\n\n      // Shorts \u2014 Short Put assumed CSP at execution; Short Call unlimited risk\n      const sc = buildShort(exp, calls, true,  signal, thresholds, deltas);\n      if (sc) maybePush(sc, signal, allowDir, candidates);\n\n      const sp = buildShort(exp, puts,  false, signal, thresholds, deltas);\n      if (sp) maybePush(sp, signal, allowDir, candidates);\n    }\n\n    // Structure bias + scoring\n    for (const c of candidates) {\n      const isSpread = ['Bull Put Spread','Bear Call Spread','Bull Call Spread','Bear Put Spread'].includes(c.strategy);\n      const isSingle = !isSpread;\n\n      if (isSpread) c.quality.profit = clamp(c.quality.profit * CFG.structure.spreadProfitBoost, 0, 1);\n      if (isSingle) c.quality.profit = clamp(c.quality.profit * CFG.structure.singleProfitCut, 0, 1);\n\n      const q = c.quality;\n      let score =\n        weights.Liquidity * q.liquidity +\n        weights.Edge      * q.edge +\n        weights.Profit    * q.profit +\n        weights.PortFit   * q.portFit -\n        weights.RiskPen   * q.risk;\n\n      score += isSpread ? CFG.structure.spreadBonusPts : CFG.structure.singlePenaltyPts;\n\n      c.score = Math.round(score);\n      c.scoreBreakdown = {\n        weights,\n        components: {\n          liquidity: +(weights.Liquidity * q.liquidity).toFixed(1),\n          edge:      +(weights.Edge * q.edge).toFixed(1),\n          profit:    +(weights.Profit * q.profit).toFixed(1),\n          portFit:   +(weights.PortFit * q.portFit).toFixed(1),\n          riskPen:   Number((-(weights.RiskPen * q.risk)).toFixed(1)),\n          structurePts: isSpread ? CFG.structure.spreadBonusPts : CFG.structure.singlePenaltyPts\n        }\n      };\n    }\n\n    candidates.sort((a,b)=> b.score - a.score);\n\n    results.push({\n      symbol,\n      signal,\n      signalRef,  // ONLY signal_raw now\n      chainStats: {\n        avgIV: round3(chainStats.avgIV),\n        medianSpread: round3(chainStats.medianSpread),\n        totalVolume: chainStats.totalVolume,\n        avgOI: round3(chainStats.avgOI),\n        regime: chainStats.regime,\n        liquidityScore: round3(chainStats.liquidityScore),\n        expirationsCount: chainStats.expirations.size,\n        contractCount: chainStats.contractCount\n      },\n      candidates: candidates.slice(0, CFG.topN),\n      parameters: { thresholds, deltas, weights },\n      debug: { generated: candidates.length, allowDir, bias: signal.bias, conf: signal.conf }\n    });\n  }\n\n  const processedCount = results.length;\n  results.push({ summary: {\n    node: 'CandidateGen v3.4 \u2014 Directional-Only + SignalRaw (Named Strategies)',\n    processed: processedCount,\n    timestamp: new Date().toISOString(),\n    description: 'Directional evaluator with risk-on tilt, symmetric spread scoring, execution ranges, and mild spread preference. Short Put assumed CSP at execution.',\n    debugInfo\n  }});\n\n  return results;\n}\n\n// --- Serialization guard: remove NaN/Infinity/undefined/Map/Set/BigInt\nfunction sanitize(value) {\n  const t = typeof value;\n  if (value == null) return null;\n  if (t === 'number') return Number.isFinite(value) ? value : null;\n  if (t === 'string' || t === 'boolean') return value;\n  if (t === 'bigint' || t === 'function') return String(value);\n  if (Array.isArray(value)) return value.map(sanitize);\n  if (t === 'object') {\n    if (value instanceof Map)  return Object.fromEntries([...value.entries()].map(([k,v]) => [k, sanitize(v)]));\n    if (value instanceof Set)  return [...value].map(sanitize);\n    const out = {};\n    for (const [k, v] of Object.entries(value)) out[k] = sanitize(v);\n    return out;\n  }\n  return value;\n}\n\n// ================= EXECUTION =================\ntry {\n  let inputItems = $input.all();\n\n  // Guard: empty input\n  if (!inputItems || inputItems.length === 0) {\n    return [{ json: { error: 'NO_INPUT', processed: 0, message: 'No input items received' } }];\n  }\n\n  // Optional debug echo (set true to inspect shape, returns early)\n  const DEBUG_ECHO_INPUT = false;\n  if (DEBUG_ECHO_INPUT) {\n    const sample = inputItems[0]?.json ?? inputItems[0];\n    return [{ json: { debug: 'INPUT_SAMPLE', count: inputItems.length, sample: sanitize(sample) } }];\n  }\n\n  // Normalize common wrappers\n  if (inputItems.length === 1 && inputItems[0]) {\n    const first = inputItems[0].json || inputItems[0];\n    if (Array.isArray(first)) {\n      inputItems = first.map(x => ({ json: x }));\n    } else if (first.items && Array.isArray(first.items)) {\n      inputItems = first.items; // likely already [{ json: ... }]\n    } else if (first.results && Array.isArray(first.results)) {\n      inputItems = first.results.map(x => ({ json: x }));\n    }\n  }\n\n  const out = processInput(inputItems);\n\n  // n8n requires [{ json: ... }] \u2014 sanitize to avoid \"Unknown error\"\n  return out.map(o => ({ json: sanitize(o) }));\n\n} catch (err) {\n  return [{\n    json: {\n      error: 'PROCESSING_ERROR',\n      message: String(err?.message || err),\n      stack: String(err?.stack || '')\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2208,
        -48
      ],
      "id": "5f7fd305-4795-449e-b36f-75a01d6f5d72",
      "name": "What Plays?"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1984,
        -48
      ],
      "id": "3d93ec35-a71e-413b-a07c-0842e3d37329",
      "name": "Plays data"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/account",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1984,
        208
      ],
      "id": "664a56dc-c3e9-4dc5-8c4a-6e5d5a8c57cc",
      "name": "Current account balances",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/positions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1520,
        368
      ],
      "id": "12793be6-d327-4e57-acec-4fe1ba43f3b5",
      "name": "Portfolio summary",
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2208,
        352
      ],
      "id": "40e8b9db-ee32-4134-8705-0c5c01238e25",
      "name": "Combine balalnces + summary"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2464,
        -176
      ],
      "id": "f66b7d45-338f-46b5-8406-65595dc3049c",
      "name": "prep for calculator"
    },
    {
      "parameters": {
        "jsCode": "// Process yfinance response - FIXED VERSION\nconst items = $input.all();\nconst priceMap = {};\n\nfor (const item of items) {\n  try {\n    // The symbol should be in the original request data\n    // Check different possible locations\n    let symbol = item.json.symbol || \n                 item.json.originalData?.symbol ||\n                 item.json.request?.symbol ||\n                 'UNKNOWN';\n    \n    // If we still don't have the symbol, try to extract from URL\n    if (symbol === 'UNKNOWN' && item.json.url) {\n      const urlMatch = item.json.url.match(/symbols=([A-Z]+)/);\n      if (urlMatch) {\n        symbol = urlMatch[1];\n      }\n    }\n    \n    // Extract price from yfinance response\n    let price = 50; // default\n    let previousClose = 50;\n    \n    // Handle v7 API response (quoteResponse)\n    if (item.json.quoteResponse && item.json.quoteResponse.result && item.json.quoteResponse.result[0]) {\n      const quote = item.json.quoteResponse.result[0];\n      symbol = quote.symbol || symbol; // Get symbol from response if available\n      price = quote.regularMarketPrice || quote.ask || quote.bid || quote.previousClose || 50;\n      previousClose = quote.previousClose || quote.regularMarketPreviousClose || price;\n    }\n    \n    // Handle v8 API response (chart)\n    if (item.json.chart && item.json.chart.result && item.json.chart.result[0]) {\n      const result = item.json.chart.result[0];\n      symbol = result.meta.symbol || symbol; // Get symbol from response if available\n      price = result.meta.regularMarketPrice || result.meta.previousClose || 50;\n      previousClose = result.meta.previousClose || price;\n    }\n    \n    // Handle direct price in response\n    if (item.json.regularMarketPrice) {\n      price = item.json.regularMarketPrice;\n      previousClose = item.json.previousClose || price;\n    }\n    \n    const dayChange = price - previousClose;\n    const dayChangePct = previousClose !== 0 ? ((dayChange / previousClose) * 100).toFixed(2) : \"0.00\";\n    \n    priceMap[symbol] = {\n      symbol: symbol,\n      price: price,\n      previousClose: previousClose,\n      dayChange: dayChange,\n      dayChangePct: dayChangePct\n    };\n    \n    console.log(`Processed ${symbol}: $${price}`);\n    \n  } catch (error) {\n    console.error(`Error processing item:`, error);\n    console.log('Item structure:', JSON.stringify(item.json, null, 2).substring(0, 500));\n  }\n}\n\n// Return the price map\nreturn [{\n  json: {\n    prices: priceMap,\n    timestamp: new Date().toISOString(),\n    count: Object.keys(priceMap).length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        624
      ],
      "id": "44ce0142-d593-4873-9ed3-1b4b537f9abd",
      "name": "Get current price for Greeks"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Portfolio Impact Calculator \u2014 compute-only (no advice)\n * n8n Code node (JavaScript) \u2014 RETURNS ONE ITEM: [{ json: { ... } }]\n *\n * Tilted toward upside (larger tickets, lighter liquidity penalties) per user spec.\n * Inputs/outputs unchanged.\n */\n\n// ====================== CONFIG ======================\n// Upside-tilted knobs: fewer trades \u2192 bigger tickets; softer liquidity/short-DTE penalties.\nconst CONFIG = {\n  MIN_TRADES: 3,\n  TARGET_TRADES: 4,                // fewer trades \u2192 larger tickets per pick\n  MAX_TRADES: 12,\n\n  PORTFOLIO_WC_CAP_PCT_BP: 0.25,   // allocate more of options BP to working capital\n  REF_PCT_SPREAD: 0.35,            // tolerate wider markets for volatile names\n\n  CREDIT_TO_WIDTH_WARN: 0.98,      // relax parity warning on credit spreads\n  MIN_NET_WIDTH_WARN: 0.05,        // allow thinner net width on credits\n  MIN_DEBIT_WARN: 0.10,            // allow cheaper long singles\n\n  SHORT_DTE_LIMIT: 5,              // smaller window considered \u201cshort DTE\u201d\n  SHORT_DTE_RISK_MULTIPLIER: 0.60, // less punitive for near-term juice\n\n  // Optional caps (lifted to allow bigger directional/vol bets). Leave null to disable.\n  PER_NAME_WC_CAP_FRAC: 0.50,\n  DELTA_CAP_DOLLARS_PER_TRADE: 3500,\n  THETA_CAP_DOLLARS_PER_DAY:  750,\n  VEGA_CAP_DOLLARS_PER_PT:    4500,\n  GAMMA_CAP_SHARES_PER_$:     120,\n  RHO_CAP_DOLLARS_PER_1PCT:   4000,\n\n  SORT_BY: \"signalScore\",          // favor upside if signal encodes it\n  CANDIDATE_RHO_IS_PER_1PCT: true,\n\n  HAZARD: {\n    CHEAP_WC_THRESHOLD: 50,\n    CHEAP_WC_SCALER: 0.50,         // lighter trim on cheap contracts\n    NEAR_PARITY_CREDIT_RATIO: 0.90,// warn later (closer to parity)\n    NEAR_PARITY_SCALER: 0.85,      // tiny penalty instead of heavy clamp\n    NET_WIDTH_SCALER: 0.80,        // tiny penalty\n    SPREAD_SCALERS: [              // gentler curve for wide markets\n      { th: 0.30, m: 0.75 },\n      { th: 0.50, m: 0.60 },\n      { th: 0.70, m: 0.45 },\n    ],\n    SLIPPAGE_TO_WC_THRESH: 0.35,   // tolerate more slippage vs WC\n    SLIPPAGE_SCALER: 0.75,         // smaller sizing cut for slippage\n  },\n};\n\nconst BS = {\n  ENABLE_FALLBACK: true,\n  RISK_FREE_RATE: 0.04,\n  DIV_YIELD: 0.00,\n  IV_INIT: 0.50,\n  IV_MAX_ITERS: 40,\n  IV_TOL: 1e-6,\n};\n\n// ====================== HELPERS ======================\nconst toNum = (x, d = 0) => (x === null || x === undefined || isNaN(+x)) ? d : +x;\nconst roundN = (x, p = 2) => Math.round((x + Number.EPSILON) * 10**p) / 10**p;\nconst round2 = (x) => roundN(x, 2);\nconst pct = (a, b) => (b > 0 ? a / b : 0);\n\nfunction collectPricesMap(inputArr) {\n  const map = {};\n  for (const it of inputArr) {\n    if (!it) continue;\n    if (it.prices && typeof it.prices === 'object') {\n      for (const [sym, obj] of Object.entries(it.prices)) {\n        const price = toNum(obj?.price ?? obj, NaN);\n        if (!isNaN(price)) map[sym] = { price };\n      }\n    }\n    if (it.symbol && (it.price !== undefined || it.currentPrice !== undefined)) {\n      const price = toNum(it.price ?? it.currentPrice, NaN);\n      if (!isNaN(price)) map[it.symbol] = { price };\n    }\n    const res0 = it?.chart?.result?.[0];\n    if (res0?.meta?.symbol) {\n      const sym = res0.meta.symbol;\n      const price = toNum(res0.meta.regularMarketPrice ?? res0.meta.previousClose ?? NaN, NaN);\n      if (!isNaN(price)) map[sym] = { price };\n    }\n  }\n  return map;\n}\n\nfunction parseCompositeInput(input) {\n  const arr = Array.isArray(input) ? input : [input];\n  const prices = collectPricesMap(arr);\n  const account = arr.find(x => x && x.account_number && x.options_buying_power);\n  const positions = arr.filter(x => x && x.asset_class === \"us_option\");\n  const candidates = arr.filter(x => x && x.symbol && Array.isArray(x.candidates));\n  const positionsGreeksArr = [];\n  for (const it of arr) if (Array.isArray(it?.positions_greeks)) positionsGreeksArr.push(...it.positions_greeks);\n  const llmPack = arr.find(x => x && x.llm_decider_pack)?.llm_decider_pack;\n  return { prices, account, positions, candidates, positionsGreeksArr, llmPack };\n}\n\nfunction dteFromCandidate(c) {\n  const d = toNum(c.metrics?.dte, NaN);\n  if (Number.isFinite(d)) return d;\n  const exp = c.legs?.[0]?.exp;\n  if (!exp) return null;\n  const ex = new Date(exp);\n  const out = Math.ceil((ex - new Date()) / (1000 * 60 * 60 * 24));\n  return Number.isFinite(out) ? out : null;\n}\n\nfunction pctSpread(candidate) {\n  const mPct = candidate.metrics?.bidAskSpread;\n  if (typeof mPct === 'number') return Math.max(0, mPct);\n  const legs = candidate.legs || [];\n  const vals = legs.map(l => toNum(l.baPct, 0)).filter(v => v > 0);\n  return vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;\n}\n\nfunction legSummary(legs) {\n  return legs.map(l => ({ role: String(l.role||'').toUpperCase(), type: String(l.type||'').toUpperCase(), strike: toNum(l.strike), exp: l.exp, mid: toNum(l.mid, null) }));\n}\n\nfunction validateStructure(strategy, legs, metrics) {\n  const reasons = [];\n  const L = legSummary(legs);\n  const roles = new Set(L.map(l => l.role));\n  const onlyCalls = L.every(l => l.type === \"CALL\");\n  const onlyPuts  = L.every(l => l.type === \"PUT\");\n  const widthFrom = (a, b) => Math.abs(toNum(a?.strike) - toNum(b?.strike));\n  const credit = toNum(metrics?.credit ?? null, null);\n  const debit  = toNum(metrics?.debit  ?? metrics?.cost ?? null, null);\n  const S = String(strategy||\"\").toUpperCase();\n\n  function getPair(type) {\n    const long  = L.find(l => l.type === type && l.role === \"LONG\");\n    const short = L.find(l => l.type === type && l.role === \"SHORT\");\n    return { long, short };\n  }\n\n  switch (S) {\n    case \"LONG CALL\":\n      if (L.length !== 1 || !onlyCalls || !roles.has(\"LONG\")) reasons.push(\"Invalid Long Call structure\");\n      if (!(debit > 0)) reasons.push(\"Missing/invalid debit for Long Call\");\n      break;\n\n    case \"LONG PUT\":\n      if (L.length !== 1 || !onlyPuts || !roles.has(\"LONG\")) reasons.push(\"Invalid Long Put structure\");\n      if (!(debit > 0)) reasons.push(\"Missing/invalid debit for Long Put\");\n      break;\n\n    case \"BULL CALL SPREAD\": {\n      if (L.length !== 2 || !onlyCalls) reasons.push(\"Bull Call Spread requires 2 CALL legs\");\n      const { long, short } = getPair(\"CALL\");\n      if (!long || !short) reasons.push(\"Missing long/short CALL legs\");\n      if (long && short && !(toNum(long.strike) < toNum(short.strike))) reasons.push(\"Bull Call needs long strike < short strike\");\n      if (!(debit > 0)) reasons.push(\"Missing/invalid debit\");\n      const width = (long && short) ? widthFrom(long, short) : null;\n      if (width === null) reasons.push(\"Missing width\");\n      break;\n    }\n\n    case \"BEAR PUT SPREAD\": {\n      if (L.length !== 2 || !onlyPuts) reasons.push(\"Bear Put Spread requires 2 PUT legs\");\n      const { long, short } = getPair(\"PUT\");\n      if (!long || !short) reasons.push(\"Missing long/short PUT legs\");\n      if (long && short && !(toNum(long.strike) > toNum(short.strike))) reasons.push(\"Bear Put needs long strike > short strike\");\n      if (!(debit > 0)) reasons.push(\"Missing/invalid debit\");\n      const width = (long && short) ? widthFrom(long, short) : null;\n      if (width === null) reasons.push(\"Missing width\");\n      break;\n    }\n\n    case \"BULL PUT SPREAD\": {\n      if (L.length !== 2 || !onlyPuts) reasons.push(\"Bull Put Spread requires 2 PUT legs\");\n      const { long, short } = getPair(\"PUT\");\n      if (!long || !short) reasons.push(\"Missing long/short PUT legs\");\n      if (short && long && !(toNum(short.strike) > toNum(long.strike))) reasons.push(\"Bull Put needs short strike > long strike\");\n      const width = (long && short) ? widthFrom(long, short) : null;\n      if (width === null) reasons.push(\"Missing width\");\n      if (!(credit > 0)) reasons.push(\"Missing/invalid credit\");\n      break;\n    }\n\n    case \"BEAR CALL SPREAD\": {\n      if (L.length !== 2 || !onlyCalls) reasons.push(\"Bear Call Spread requires 2 CALL legs\");\n      const { long, short } = getPair(\"CALL\");\n      if (!long || !short) reasons.push(\"Missing long/short CALL legs\");\n      if (short && long && !(toNum(long.strike) > toNum(short.strike))) reasons.push(\"Bear Call needs long strike > short strike\");\n      const width = (long && short) ? widthFrom(long, short) : null;\n      if (width === null) reasons.push(\"Missing width\");\n      if (!(credit > 0)) reasons.push(\"Missing/invalid credit\");\n      break;\n    }\n\n    case \"SHORT CALL\":\n      if (L.length !== 1 || !onlyCalls || !roles.has(\"SHORT\")) reasons.push(\"Short Call requires 1 short CALL\");\n      if (!(credit > 0)) reasons.push(\"Missing/invalid credit for Short Call\");\n      break;\n\n    case \"SHORT PUT\":\n      if (L.length !== 1 || !onlyPuts || !roles.has(\"SHORT\")) reasons.push(\"Short Put requires 1 short PUT\");\n      if (!(credit > 0)) reasons.push(\"Missing/invalid credit for Short Put\");\n      break;\n\n    default:\n      if (!Array.isArray(legs) || legs.length === 0) reasons.push(\"Unknown strategy with no legs\");\n  }\n  return reasons;\n}\n\n// ====================== BLACK-SCHOLES ======================\nfunction _pdf(z){ return Math.exp(-0.5*z*z)/Math.sqrt(2*Math.PI); }\nfunction _cdf(z){ const t=1/(1+0.2316419*Math.abs(z)), d=0.3989423*Math.exp(-z*z/2);\n  const p=d*t*(1.330274*t**4 - 1.821256*t**3 + 1.781478*t**2 - 0.356538*t + 0.3193815);\n  return z>0 ? 1-p : p;\n}\nfunction _yearFrac(now, exp){ return Math.max((new Date(exp)-now)/(365*24*3600*1000), 1/365); }\nfunction _bsGreeks(S,K,r,q,sig,T,type){\n  if (sig<=0 || T<=0 || S<=0 || K<=0) return {price:0,delta:0,gamma:0,vega:0,theta:0,rho:0};\n  const sqrtT=Math.sqrt(T), d1=(Math.log(S/K)+(r-q+0.5*sig*sig)*T)/(sig*sqrtT), d2=d1-sig*sqrtT;\n  const Nd1c=_cdf(d1), Nd2c=_cdf(d2), Nd1p=_cdf(-d1), Nd2p=_cdf(-d2), pdfd1=_pdf(d1);\n  const disc_r=Math.exp(-r*T), disc_q=Math.exp(-q*T);\n  const call= S*disc_q*Nd1c - K*disc_r*Nd2c;\n  const put = K*disc_r*Nd2p - S*disc_q*Nd1p;\n  const price = (type==='CALL')? call : put;\n  const delta = (type==='CALL')? disc_q*Nd1c : -disc_q*Nd1p;\n  const gamma = disc_q*pdfd1/(S*sig*sqrtT);\n  const vega  = S*disc_q*pdfd1*sqrtT;\n  const thetaC= -(S*disc_q*pdfd1*sig/(2*sqrtT)) - r*K*disc_r*Nd2c + q*S*disc_q*Nd1c;\n  const thetaP= -(S*disc_q*pdfd1*sig/(2*sqrtT)) + r*K*disc_r*Nd2p - q*S*disc_q*Nd1p;\n  const theta = (type==='CALL')? thetaC : thetaP;\n  const rhoC  =  K*T*disc_r*Nd2c;\n  const rhoP  = -K*T*disc_r*Nd2p;\n  return {price,delta,gamma,vega,theta,rho:(type==='CALL'?rhoC:rhoP)};\n}\nfunction _ivFromPrice(S,K,r,q,T,type,px){\n  let sig = Math.max(1e-4, BS.IV_INIT);\n  for (let i=0;i<BS.IV_MAX_ITERS;i++){\n    const g=_bsGreeks(S,K,r,q,sig,T,type), diff=g.price - px;\n    if (Math.abs(diff)<BS.IV_TOL) break;\n    const v=g.vega; if (v<=1e-10) break;\n    sig = Math.max(1e-4, Math.min(5.0, sig - diff/v));\n  }\n  return sig;\n}\n\nfunction symbolPrice(symbol, pricesMap) {\n  return toNum(pricesMap?.[symbol]?.price, null);\n}\n\nfunction perContractMetrics(strategy, candidate, S) {\n  const m = candidate.metrics || {};\n  const legs = candidate.legs || [];\n  const exec = candidate.execution || null;\n\n  const credit = toNum(m.credit ?? (exec?.side === 'credit' ? exec.mid : null), null);\n  const debit  = toNum(m.debit  ?? m.cost ?? (exec?.side === 'debit'  ? exec.mid : null), null);\n  const width  = toNum(m.width, null);\n  const baPct  = toNum(m.bidAskSpread, NaN);\n\n  const Sname = String(strategy||\"\").toUpperCase();\n  let wcPerContract = 0;\n  const strikes = legs.map(l => toNum(l.strike, 0));\n  const computedWidth = (width !== null) ? width : (strikes.length === 2 ? Math.abs(strikes[0]-strikes[1]) : null);\n\n  switch (Sname) {\n    case \"LONG CALL\":\n    case \"LONG PUT\":\n    case \"BULL CALL SPREAD\":\n    case \"BEAR PUT SPREAD\":\n      wcPerContract = toNum(debit, 0) * 100;\n      break;\n\n    case \"BULL PUT SPREAD\":\n    case \"BEAR CALL SPREAD\": {\n      if (computedWidth === null || credit === null) return { error: \"Missing width/credit for credit spread\" };\n      wcPerContract = (computedWidth - credit) * 100;\n      break;\n    }\n\n    case \"SHORT CALL\":\n    case \"SHORT PUT\":\n      if (Sname === \"SHORT PUT\") {\n        const strike = toNum(legs?.[0]?.strike, null);\n        if (strike === null || credit === null) return { error: \"Missing strike/credit for Short Put\" };\n        wcPerContract = (strike - credit) * 100;\n      } else {\n        wcPerContract = 0;\n      }\n      break;\n\n    default:\n      wcPerContract = Math.max(0, toNum(debit ?? credit ?? 0, 0) * 100);\n  }\n\n  let slip$ = 0;\n  if (exec && typeof exec.mid === 'number' && typeof exec.target === 'number') {\n    const diff = (exec.side === 'debit') ? (exec.target - exec.mid) : (exec.mid - exec.target);\n    slip$ = Math.max(0, diff * 100);\n  } else if (!isNaN(baPct)) {\n    const ref = toNum(debit ?? credit ?? legs?.[0]?.mid ?? 0, 0);\n    slip$ = Math.max(0, 0.25 * baPct * ref * 100);\n  }\n\n  let delta  = toNum(m.delta, NaN);\n  let theta  = toNum(m.theta, NaN);\n  let vega   = toNum(m.vega,  NaN);\n  let gamma  = toNum(m.gamma, NaN);\n  let rho    = toNum(m.rho,   NaN);\n\n  const needBS = !isFinite(delta) || !isFinite(theta) || !isFinite(vega) || !isFinite(gamma) || !isFinite(rho) ||\n                 (Math.abs(delta)+Math.abs(theta)+Math.abs(vega)+Math.abs(gamma)+Math.abs(rho)===0);\n\n  if (needBS && S) {\n    const now = new Date();\n    const r = BS.RISK_FREE_RATE, q = BS.DIV_YIELD;\n    let d=0, t=0, v=0, g=0, r1=0;\n\n    for (const leg of legs) {\n      const type = String(leg.type || \"\").toUpperCase();\n      const role = String(leg.role || \"\").toUpperCase();\n      const sign = (role === \"LONG\") ? +1 : -1;\n      const K = toNum(leg.strike, 0);\n      const T = _yearFrac(now, leg.exp || now);\n      const mid = toNum(leg.mid, NaN);\n\n      const iv = (isFinite(mid) && mid>0 && S)\n        ? _ivFromPrice(S, K, r, q, T, type, mid)\n        : BS.IV_INIT;\n\n      const gg = _bsGreeks(S || 0, K, r, q, iv, T, type);\n      d += sign * gg.delta;\n      g += sign * gg.gamma;\n      v += sign * gg.vega;\n      t += sign * (gg.theta / 365);\n      r1+= sign * (gg.rho * 0.01);\n    }\n\n    delta = d; theta = t; vega = v; gamma = g; rho = r1;\n  }\n\n  const deltaDollars      = round2(toNum(delta,0) * 100);\n  const thetaDollars      = round2(toNum(theta,0) * 100);\n  const vegaDollars       = round2(toNum(vega, 0)); // per 1% vol per contract\n  const gammaSharesPer$   = round2(toNum(gamma,0) * 100);\n  const rhoPerSharePer1pct = CONFIG.CANDIDATE_RHO_IS_PER_1PCT ? toNum(rho,0) : (toNum(rho,0) * 0.01);\n  const rhoDollarsPer1pct = round2(rhoPerSharePer1pct * 100);\n\n  return {\n    wcPerContract: round2(wcPerContract),\n    deltaDollars,\n    thetaDollars,\n    vegaDollars,\n    gammaSharesPer$,\n    rhoDollarsPer1pct,\n    slippageDollars: round2(slip$),\n  };\n}\n\nfunction qualityFlags(candidate) {\n  const flags = [];\n  const ps = pctSpread(candidate);\n  if (isFinite(ps) && ps > CONFIG.REF_PCT_SPREAD) flags.push(`warn_pct_spread_${round2(ps*100)}%`);\n\n  const S = String(candidate.strategy||\"\").toUpperCase();\n  const width  = toNum(candidate.metrics?.width, null);\n  const credit = toNum(candidate.metrics?.credit, null);\n  const debit  = toNum(candidate.metrics?.debit ?? candidate.metrics?.cost, null);\n\n  const isCredit = S === \"BULL PUT SPREAD\" || S === \"BEAR CALL SPREAD\" || (width && credit);\n  const isLongSingle = S === \"LONG CALL\" || S === \"LONG PUT\";\n\n  if (isCredit && width && credit) {\n    if (credit/width > CONFIG.CREDIT_TO_WIDTH_WARN) flags.push(`warn_credit_over_${Math.round(CONFIG.CREDIT_TO_WIDTH_WARN*100)}%_of_width`);\n    if ((width - credit) < CONFIG.MIN_NET_WIDTH_WARN) flags.push(`warn_net_width_lt_${CONFIG.MIN_NET_WIDTH_WARN}`);\n  }\n\n  if (isLongSingle && debit !== null && debit < CONFIG.MIN_DEBIT_WARN) {\n    flags.push(`warn_tiny_debit_${debit}`);\n  }\n  return flags;\n}\n\nfunction currentPortfolioWCFromPositions(positions) {\n  let wc = 0;\n  for (const p of positions) {\n    const side = (p.side || \"\").toLowerCase();\n    const cb   = toNum(p.cost_basis, 0);\n    if (side === \"long\") wc += cb;\n  }\n  return round2(wc);\n}\n\nfunction occParse(sym) {\n  const m = String(sym||\"\").match(/^([A-Z.]+)(\\d{2})(\\d{2})(\\d{2})([CP])(\\d{8})$/);\n  if (!m) return null;\n  const [, under, yy, mm, dd, t, strike8] = m;\n  const year = 2000 + parseInt(yy,10);\n  const strike = parseInt(strike8,10)/1000;\n  return { symbol: under, exp: `${year}-${mm}-${dd}`, type: (t==='C'?'CALL':'PUT'), strike };\n}\n\nfunction buildPositionsGreeksIndex(arr) {\n  const idx = new Map();\n  for (const g of (arr||[])) {\n    const key = `${g.symbol}|${g.exp}|${String(g.type||'').toUpperCase()}|${toNum(g.strike)}`;\n    idx.set(key, {\n      delta: toNum(g.delta), theta: toNum(g.theta), vega: toNum(g.vega),\n      gamma: toNum(g.gamma), rho: toNum(g.rho),\n      qty: toNum(g.qty, 1), side: String(g.side||'long').toLowerCase(),\n    });\n  }\n  return idx;\n}\n\nfunction aggregatePreGreeks(positions, positionsGreeksArr, prices) {\n  const idx = buildPositionsGreeksIndex(positionsGreeksArr);\n  const haveExternal = idx.size > 0;\n  let D=0, T=0, V=0, G=0, R=0, matched=0, unmatched=0;\n\n  for (const p of positions) {\n    const side = (p.side || \"\").toLowerCase();\n    const qty  = toNum(p.qty, 0);\n    const occ  = occParse(p.symbol);\n    if (!occ || qty===0) { unmatched++; continue; }\n    const key  = `${occ.symbol}|${occ.exp}|${occ.type}|${toNum(occ.strike)}`;\n    let g = idx.get(key);\n    const sign = (side==='short')?-1:1;\n    const lot = qty * sign;\n\n    if (!g && BS.ENABLE_FALLBACK && prices?.[occ.symbol]?.price && p.current_price>0) {\n      const S = toNum(prices[occ.symbol].price);\n      const K = toNum(occ.strike);\n      const Tfrac = _yearFrac(new Date(), occ.exp);\n      const mid = toNum(p.current_price);\n      \n      if (mid <= 0.01 || S <= 0 || K <= 0 || Tfrac <= 0) { unmatched++; continue; }\n      \n      const r = BS.RISK_FREE_RATE, q = BS.DIV_YIELD;\n      const sig = _ivFromPrice(S,K,r,q,Tfrac,occ.type, mid);\n      const gg  = _bsGreeks(S,K,r,q,sig,Tfrac,occ.type);\n      g = {\n        delta: gg.delta,\n        gamma: gg.gamma,\n        vega:  gg.vega/100,\n        theta: gg.theta/365,\n        rho:   gg.rho * 0.01,\n        qty: qty, side\n      };\n    }\n\n    if (!g) { unmatched++; continue; }\n\n    const adj = (val) => round2(val * 100) * lot;\n    D += adj(g.delta);\n    T += adj(g.theta);\n    V += adj(g.vega);\n    G += adj(g.gamma);\n    R += adj(g.rho);\n    matched++;\n  }\n\n  return {\n    have_positions_greeks: haveExternal,\n    matched_positions: matched,\n    unmatched_positions: unmatched,\n    delta_dollars: round2(D),\n    theta_dollars_day: round2(T),\n    vega_dollars_pt: round2(V),\n    gamma_shares_per_$: round2(G),\n    rho_dollars_per_1pct: round2(R),\n    pre_greeks_note: haveExternal ? undefined : \"positions_greeks missing; used BS fallback where possible.\"\n  };\n}\n\nfunction hazardMultiplier(rec) {\n  const hz = CONFIG.HAZARD;\n  let mult = 1.0;\n  const notes = [];\n\n  if (rec.dte !== null && rec.dte <= CONFIG.SHORT_DTE_LIMIT) {\n    mult *= CONFIG.SHORT_DTE_RISK_MULTIPLIER;\n    notes.push(`short_dte\u2264${CONFIG.SHORT_DTE_LIMIT}x${CONFIG.SHORT_DTE_RISK_MULTIPLIER}`);\n  }\n\n  if (rec.pc.wcPerContract > 0 && rec.pc.wcPerContract < hz.CHEAP_WC_THRESHOLD) {\n    mult *= hz.CHEAP_WC_SCALER;\n    notes.push(`cheap_wc<${hz.CHEAP_WC_THRESHOLD}x${hz.CHEAP_WC_SCALER}`);\n  }\n\n  const width  = toNum(rec.candidate.metrics?.width, null);\n  const credit = toNum(rec.candidate.metrics?.credit, null);\n  if (width && credit) {\n    const ratio = credit / width;\n    if (ratio >= hz.NEAR_PARITY_CREDIT_RATIO) {\n      mult *= hz.NEAR_PARITY_SCALER;\n      notes.push(`near_parity_credit\u2265${Math.round(hz.NEAR_PARITY_CREDIT_RATIO*100)}%x${hz.NEAR_PARITY_SCALER}`);\n    }\n    if ((width - credit) < CONFIG.MIN_NET_WIDTH_WARN) {\n      mult *= hz.NET_WIDTH_SCALER;\n      notes.push(`net_width<${CONFIG.MIN_NET_WIDTH_WARN}x${hz.NET_WIDTH_SCALER}`);\n    }\n  }\n\n  const ps = rec._pct_spread;\n  for (const tier of hz.SPREAD_SCALERS) {\n    if (ps > tier.th) { mult *= tier.m; notes.push(`ba_pct>${Math.round(tier.th*100)}%x${tier.m}`); }\n  }\n\n  const slipToWc = rec.pc.wcPerContract > 0 ? rec.pc.slippageDollars / rec.pc.wcPerContract : 0;\n  if (slipToWc > hz.SLIPPAGE_TO_WC_THRESH) {\n    mult *= hz.SLIPPAGE_SCALER;\n    notes.push(`slippage/wc>${Math.round(hz.SLIPPAGE_TO_WC_THRESH*100)}%x${hz.SLIPPAGE_SCALER}`);\n  }\n\n  return { mult: Math.max(0, Math.min(1, mult)), notes };\n}\n\nfunction sizeCandidate(candWrap, perTradeBudget, remainingBudget, portfolioCap$) {\n  const { pc } = candWrap;\n  const wcPer = pc.wcPerContract;\n  if (!(wcPer > 0)) return { contracts: 0, reasons: [\"Non-positive WC per contract\"], hz: { mult:1, notes:[] } };\n\n  const hz = hazardMultiplier(candWrap);\n  const budget0 = perTradeBudget * hz.mult;\n\n  const budget = Math.max(0, Math.min(budget0, remainingBudget));\n  let contracts = Math.floor(budget / wcPer);\n  if (contracts < 1) return { contracts: 0, reasons: [\"Budget < 1 contract\"], hz };\n\n  const caps = [];\n  if (Number.isFinite(CONFIG.PER_NAME_WC_CAP_FRAC) && CONFIG.PER_NAME_WC_CAP_FRAC > 0) {\n    const nameCap$ = CONFIG.PER_NAME_WC_CAP_FRAC * portfolioCap$;\n    caps.push(Math.floor(nameCap$ / wcPer));\n  }\n  if (Number.isFinite(CONFIG.DELTA_CAP_DOLLARS_PER_TRADE) && Math.abs(pc.deltaDollars) > 0) {\n    caps.push(Math.floor(CONFIG.DELTA_CAP_DOLLARS_PER_TRADE / Math.abs(pc.deltaDollars)));\n  }\n  if (Number.isFinite(CONFIG.THETA_CAP_DOLLARS_PER_DAY) && Math.abs(pc.thetaDollars) > 0) {\n    caps.push(Math.floor(CONFIG.THETA_CAP_DOLLARS_PER_DAY / Math.abs(pc.thetaDollars)));\n  }\n  if (Number.isFinite(CONFIG.VEGA_CAP_DOLLARS_PER_PT) && Math.abs(pc.vegaDollars) > 0) {\n    caps.push(Math.floor(CONFIG.VEGA_CAP_DOLLARS_PER_PT / Math.abs(pc.vegaDollars)));\n  }\n  if (Number.isFinite(CONFIG.GAMMA_CAP_SHARES_PER_$) && Math.abs(pc.gammaSharesPer$) > 0) {\n    caps.push(Math.floor(CONFIG.GAMMA_CAP_SHARES_PER_$ / Math.abs(pc.gammaSharesPer$)));\n  }\n  if (Number.isFinite(CONFIG.RHO_CAP_DOLLARS_PER_1PCT) && Math.abs(pc.rhoDollarsPer1pct) > 0) {\n    caps.push(Math.floor(CONFIG.RHO_CAP_DOLLARS_PER_1PCT / Math.abs(pc.rhoDollarsPer1pct)));\n  }\n\n  const validCaps = caps.filter(n => Number.isFinite(n) && n > 0);\n  const relCap = validCaps.length > 0 ? Math.min(...validCaps) : Infinity;\n  contracts = relCap !== Infinity ? Math.max(0, Math.min(contracts, relCap)) : contracts;\n\n  return { contracts, reasons: [], hz };\n}\n\n// ====================== MAIN ======================\nfunction buildImpact(input) {\n  const { prices, account, positions, candidates, positionsGreeksArr, llmPack } = parseCompositeInput(input);\n  if (!account || !account.options_buying_power) throw new Error(\"Missing account/options_buying_power in input.\");\n\n  const optionsBP = toNum(account.options_buying_power, 0);\n  const portfolioCap$ = round2(optionsBP * CONFIG.PORTFOLIO_WC_CAP_PCT_BP);\n\n  const currentWC$ = currentPortfolioWCFromPositions(positions);\n  const remainingWC$ = Math.max(0, round2(portfolioCap$ - currentWC$));\n  const perTradeBudgetBase = (CONFIG.TARGET_TRADES > 0) ? round2(remainingWC$ / CONFIG.TARGET_TRADES) : remainingWC$;\n\n  const preGreeks = aggregatePreGreeks(positions, positionsGreeksArr, prices);\n\n  const flat = [];\n  for (const block of candidates) {\n    const sym = block.symbol;\n    const uPx = symbolPrice(sym, prices);\n\n    const raw = block.signalRef || block.signal_raw || {};\n    const sig = {\n      direction_bias: toNum(raw.direction_bias ?? block.signal?.bias ?? 0),\n      confidence:     toNum(raw.confidence     ?? block.signal?.conf ?? 0.5),\n      vol_bias:       raw.vol_bias ?? block.signal?.volBias ?? null,\n      event_window:   raw.event_window ?? null,\n      red_flags:      Array.isArray(raw.red_flags) ? raw.red_flags : [],\n      bullets:        Array.isArray(raw.bullets) ? raw.bullets : [],\n      evidence_count: toNum(raw.evidence_count ?? 0),\n      agreement:      raw.agreement ?? null,\n      catalyst_type:  raw.catalyst_type ?? null,\n      price_alignment:raw.price_alignment ?? null,\n      score:          toNum(raw.score ?? 0),\n    };\n\n    for (const cand of block.candidates || []) {\n      const strategy = String(cand.strategy || '');\n      const dte = dteFromCandidate(cand);\n      const structureIssues = validateStructure(strategy, cand.legs || [], cand.metrics || {});\n      const pc = perContractMetrics(strategy, cand, uPx);\n      const candidateScore = toNum(cand.score, 0);\n      const flags = qualityFlags(cand);\n      const _pct_spread = pctSpread(cand);\n\n      const rec = {\n        symbol: sym,\n        underlyingPrice: uPx,\n        signal: sig,\n        candidateScore,\n        strategy,\n        dte,\n        _pct_spread,\n        structure_issues: structureIssues,\n        flags,\n        candidate: cand,\n        pc,\n      };\n\n      const impossible = structureIssues.some(r =>\n        r.includes(\"requires\") || r.includes(\"Missing\") || r.includes(\"Invalid\")\n      ) || !!pc.error;\n\n      flat.push(impossible\n        ? { ...rec, hard_reject: true, reject_reasons: [...structureIssues, pc.error].filter(Boolean) }\n        : { ...rec, hard_reject: false });\n    }\n  }\n\n  const rejected = flat.filter(f => f.hard_reject).map(f => ({\n    symbol: f.symbol, strategy: f.strategy, dte: f.dte, reasons: f.reject_reasons, candidate: f.candidate,\n  }));\n\n  const validAll = flat.filter(f => !f.hard_reject);\n  const bySymbol = new Map();\n  for (const v of validAll) {\n    const k = v.symbol;\n    const cur = bySymbol.get(k);\n    const thisScore = (CONFIG.SORT_BY === \"signalScore\") ? v.signal.score : v.candidateScore;\n    const curScore  = cur ? ((CONFIG.SORT_BY === \"signalScore\") ? cur.signal.score : cur.candidateScore) : -Infinity;\n    if (!cur || thisScore > curScore) bySymbol.set(k, v);\n  }\n  let pool = Array.from(bySymbol.values());\n\n  if (llmPack?.selections?.length) {\n    const chosen = new Set(llmPack.selections.map(s => s.play_id));\n    pool = pool.filter(v => chosen.has(`${v.symbol}:${v.strategy}`));\n  }\n\n  pool.sort((a, b) => {\n    const sA = (CONFIG.SORT_BY === \"signalScore\") ? a.signal.score : a.candidateScore;\n    const sB = (CONFIG.SORT_BY === \"signalScore\") ? b.signal.score : b.candidateScore;\n    if (sB !== sA) return sB - sA;\n    const aShort = (a.dte !== null && a.dte <= CONFIG.SHORT_DTE_LIMIT) ? 1 : 0;\n    const bShort = (b.dte !== null && b.dte <= CONFIG.SHORT_DTE_LIMIT) ? 1 : 0;\n    return aShort - bShort;\n  });\n\n  const picks = [];\n  let remaining = remainingWC$;\n  let trades = 0;\n\n  for (const v of pool) {\n    if (trades >= CONFIG.MAX_TRADES) break;\n\n    const sizing = sizeCandidate(v, perTradeBudgetBase, remaining, portfolioCap$);\n    if (sizing.contracts <= 0) continue;\n\n    const contracts = sizing.contracts;\n    const wc$ = round2(contracts * v.pc.wcPerContract);\n    if (wc$ <= 0 || wc$ > remaining) continue;\n\n    picks.push({\n      play_id: `${v.symbol}:${v.strategy}`,\n      symbol: v.symbol,\n      strategy: v.strategy,\n      dte: v.dte,\n      candidateScore: v.candidateScore,\n      signalScore: v.signal.score,\n      analyst: v.signal,\n      flags: v.flags,\n      contracts,\n      hazard: { multiplier: round2(sizing.hz.mult), notes: sizing.hz.notes, pct_spread: round2(v._pct_spread*100) },\n      per_contract: v.pc,\n      wc_bp_pct_capital: roundN(v.pc.wcPerContract / (toNum(account.options_buying_power, 1) || 1), 8),\n      wc_dollars: wc$,\n      delta_dollars:        round2(v.pc.deltaDollars * contracts),\n      theta_dollars_day:    round2(v.pc.thetaDollars * contracts),\n      vega_dollars_pt:      round2(v.pc.vegaDollars * contracts),\n      gamma_shares_per_$:   round2(v.pc.gammaSharesPer$ * contracts),\n      rho_dollars_per_1pct: round2(v.pc.rhoDollarsPer1pct * contracts),\n      slippage_est:         round2(v.pc.slippageDollars * contracts),\n      source: v.candidate,\n    });\n\n    remaining = round2(remaining - wc$);\n    trades += 1;\n    if (trades >= CONFIG.TARGET_TRADES && remaining <= v.pc.wcPerContract) break;\n  }\n\n  const picksGreeks = {\n    delta_dollars:        round2(picks.reduce((s,p)=>s + p.delta_dollars, 0)),\n    theta_dollars_day:    round2(picks.reduce((s,p)=>s + p.theta_dollars_day, 0)),\n    vega_dollars_pt:      round2(picks.reduce((s,p)=>s + p.vega_dollars_pt, 0)),\n    gamma_shares_per_$:   round2(picks.reduce((s,p)=>s + p.gamma_shares_per_$, 0)),\n    rho_dollars_per_1pct: round2(picks.reduce((s,p)=>s + p.rho_dollars_per_1pct, 0)),\n  };\n\n  const postLegacy = {\n    wc_total: round2(currentWC$ + picks.reduce((s, p) => s + p.wc_dollars, 0)),\n    delta_dollars:     picksGreeks.delta_dollars,\n    theta_dollars_day: picksGreeks.theta_dollars_day,\n    vega_dollars_pt:   picksGreeks.vega_dollars_pt,\n    slippage_est:      round2(picks.reduce((s, p) => s + p.slippage_est, 0)),\n  };\n\n  const portfolio_greeks_pre  = { ...preGreeks };\n  const portfolio_greeks_post = {\n    delta_dollars:        round2(preGreeks.delta_dollars        + picksGreeks.delta_dollars),\n    theta_dollars_day:    round2(preGreeks.theta_dollars_day    + picksGreeks.theta_dollars_day),\n    vega_dollars_pt:      round2(preGreeks.vega_dollars_pt      + picksGreeks.vega_dollars_pt),\n    gamma_shares_per_$:   round2(preGreeks.gamma_shares_per_$   + picksGreeks.gamma_shares_per_$),\n    rho_dollars_per_1pct: round2(preGreeks.rho_dollars_per_1pct + picksGreeks.rho_dollars_per_1pct),\n  };\n\n  const wc_pct_of_bp = pct(postLegacy.wc_total, optionsBP);\n  const concentration = (() => {\n    const map = {};\n    for (const p of picks) map[p.symbol] = (map[p.symbol] || 0) + p.wc_dollars;\n    return Object.entries(map)\n      .map(([symbol, wc]) => ({ symbol, wc: round2(wc), wc_pct_of_post: round2(pct(wc, postLegacy.wc_total) * 100) }))\n      .sort((a, b) => b.wc - a.wc)\n      .slice(0, 5);\n  })();\n\n  const portfolio_pre = {\n    options_buying_power: optionsBP,\n    portfolio_wc_cap: portfolioCap$,\n    current_wc_open_positions: currentWC$,\n    remaining_wc_budget: remainingWC$,\n    greeks: portfolio_greeks_pre\n  };\n\n  const portfolio_post = {\n    ...postLegacy,\n    wc_pct_of_options_bp: round2(wc_pct_of_bp * 100),\n    remaining_wc_budget_after_picks: round2(Math.max(0, portfolioCap$ - postLegacy.wc_total)),\n    picks_count: picks.length,\n    concentration_top: concentration,\n    greeks: portfolio_greeks_post\n  };\n\n  const all_candidates = validAll.map(v => ({\n    play_id: `${v.symbol}:${v.strategy}`,\n    symbol: v.symbol,\n    strategy: v.strategy,\n    dte: v.dte,\n    candidateScore: v.candidateScore,\n    signalScore: v.signal.score,\n    analyst: v.signal,\n    pct_spread: round2(v._pct_spread * 100),\n    flags: v.flags,\n    per_contract: v.pc,\n    wc_bp_pct_capital: roundN(v.pc.wcPerContract / (toNum(account.options_buying_power, 1) || 1), 8),\n  })).sort((a, b) => {\n    const sA = (CONFIG.SORT_BY === \"signalScore\") ? a.signalScore : a.candidateScore;\n    const sB = (CONFIG.SORT_BY === \"signalScore\") ? b.signalScore : b.candidateScore;\n    return sB - sA;\n  });\n\n  const handoff = {\n    schema_version: \"impact.v2\",\n    top20: all_candidates.slice(0, 20),\n    picks,\n    portfolio_pre,\n    portfolio_post,\n    impact_delta: picksGreeks,\n  };\n\n  return {\n    config: CONFIG,\n    portfolio_pre,\n    portfolio_post,\n    impact_delta: picksGreeks,\n    picks,\n    rejected,\n    all_candidates,\n    handoff\n  };\n}\n\n// ====================== n8n WRAPPER ======================\ntry {\n  const items = $input.all();\n  if (!items || items.length === 0) {\n    return [{ json: { error: 'NO_INPUT', message: 'No input items received' } }];\n  }\n\n  let INPUT = null;\n  if (items.length && items[0].json && items[0].json.input) INPUT = items[0].json.input;\n  if (!INPUT && items.length === 1 && (Array.isArray(items[0].json) || typeof items[0].json === 'object')) INPUT = items[0].json;\n  if (!INPUT && items.length > 1) INPUT = items.map(it => it.json);\n  if (!INPUT) throw new Error(\"No input found. Put composite JSON at items[0].json.input or as items[0].json.\");\n\n  const result = buildImpact(INPUT);\n  return [{ json: result }];\n} catch (err) {\n  return [{ json: { error: String(err?.message || err), stack: String(err?.stack || '') } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2912,
        -176
      ],
      "id": "c38aa81f-0066-4ca2-81df-94ed21528662",
      "name": "Portfolio impact calculator"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2688,
        -176
      ],
      "id": "de435cc3-0c53-49e0-b701-abccd51b405f",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Top-50 MENU Builder \u2014 v1.8 (compatible with Impact v2 & CandidateGen v3.4)\n * n8n Code node (JavaScript) \u2014 RETURNS ONE ITEM: [{ json: { ... } }]\n *\n * Purpose (menu only; no instructions)\n * - Consume the Impact Calculator result (payload with portfolio_pre, handoff.top20, picks, all_candidates).\n * - Set day budget = 7.5% of current options buying power (OBP).  // updated from 3%\n * - Produce a clean, data-only menu of Top-50 plays:\n *   \u2022 Preserves analyst context (ALL bullets; signal_raw-compatible shape)\n *   \u2022 Per-contract impact (\u0394/\u0398/Vega/\u0393/\u03c1, WC, slippage)\n *   \u2022 Strategy structure tags (defined_risk, unlimited_risk, legs, side, option_type)\n *   \u2022 Unit conversions: contracts_per_1pct_weight, percent_for_one_contract, etc.\n *   \u2022 Optional scores (risk/upside/fit) precomputed to keep LLM math-light\n *   \u2022 Carries through source.legs (role/type/strike/exp/mid/baPct), source.metrics, source.execution (if present)\n * - Adds provenance: menu_id, source_version\n * - Adds idempotency checksum (md5) over dayBudget + core play fields\n *\n * NO prompts, NO instructions \u2014 just a menu.\n */\n\n// ====================== CONFIG ======================\nconst CFG = {\n  DAY_BUDGET_PCT_OF_OBP: 0.075,     // 7.5% of current options buying power (updated)\n  MIN_TRADES: 3,                    // align with Impact node MIN_TRADES\n  MAX_TRADES: 12,                   // align with Impact node MAX_TRADES\n  SUGGESTED_TRADES: 4,              // align with Impact node TARGET_TRADES\n\n  PROFILE_MULTIPLIERS: { conservative: 0.5, base: 1.0, aggressive: 1.5 },\n\n  // Simple scoring normalizers (0\u2013100 scale)\n  TARGET_RISK_SCORE: 80,            // maps to 8/10 appetite\n  MAX_SPREAD_PCT: 80,               // BA% = 80% \u2192 \u201c100 risk\u201d\n  MAX_SLIP_RATIO: 0.60,             // slippage/wc 60% \u2192 \u201c100 risk\u201d\n  MAX_VEGA_PER_WC: 50,              // $ vega per $ WC \u2192 100 risk\n  MAX_GAMMA_PER_WC: 5,              // shares/$ per $ WC \u2192 100 risk\n  MAX_THETA_MAG: 75,                // $/day magnitude normalization\n  MAX_DELTA_PER_WC: 2.0,            // $ delta per $ WC normalization\n\n  SOURCE_VERSION: \"impact.v2\",\n  TOP_N: 50                         // expanded from 20 to 50\n};\n\n// ====================== HELPERS ======================\nconst toNum   = (x, d=0) => (x===null || x===undefined || isNaN(+x)) ? d : +x;\nconst roundN  = (x,p=2)=> Math.round((x+Number.EPSILON)*10**p)/10**p;\nconst clamp01 = (x)=> Math.max(0, Math.min(1, x));\nconst norm100 = (x)=> (x<=1.2 ? x*100 : x); // normalize 0\u20131 style to 0\u2013100\n\n// Percent/fraction (0.2 \u2192 20) normalizer\nfunction normPctSpread(v) {\n  let ps = toNum(v ?? 0, 0);\n  if (ps > 0 && ps <= 1.5) ps = ps * 100; // treat <=1.5 as fraction\n  return roundN(ps, 2);\n}\n\n// Read analyst/signal fields; KEEP ALL bullets (no trimming)\nfunction analystOf(entry) {\n  const a = entry.analyst || entry.signal || {};\n  const conf = (a.confidence ?? null);\n  const scoreRaw = (\"score\" in a) ? a.score : (entry.signalScore ?? 0);\n  const score = roundN(norm100(toNum(scoreRaw, 0)), 1);\n\n  const bullets =\n    Array.isArray(a.bullets) ? a.bullets.slice() :\n    Array.isArray(entry?.analyst?.bullets) ? entry.analyst.bullets.slice() :\n    [];\n\n  return {\n    directionBias: toNum(a.directionBias ?? a.direction_bias ?? entry.directionBias ?? entry.direction_bias ?? 0, 0),\n    confidence: conf === null ? null : toNum(conf, null),\n    vol_bias: a.vol_bias ?? a.volBias ?? null,\n    score,\n    agreement: a.agreement ?? null,\n    catalyst_type: a.catalyst_type ?? a.catalystType ?? null,\n    price_alignment: a.price_alignment ?? a.priceAlignment ?? null,\n    evidence_count: toNum(a.evidence_count ?? a.evidenceCount ?? null, null),\n    bullets,                       // ALL bullets\n    red_flags: Array.isArray(a.red_flags) ? a.red_flags : [],\n  };\n}\n\nfunction unitConversions(perContract, dayBudget) {\n  const wc = Math.max(1, toNum(perContract?.wcPerContract, 0));\n  const contractsPer1pctWeight = (0.01 * dayBudget) / wc;\n  const pctForOneContract      = (wc / dayBudget) * 100;\n  const maxContractsAllBudget  = Math.floor(dayBudget / wc);\n  const slipToWc               = (toNum(perContract?.slippageDollars, 0) / wc);\n  return {\n    contracts_per_1pct_weight: roundN(contractsPer1pctWeight, 4),\n    percent_for_one_contract:  roundN(pctForOneContract, 4),\n    max_contracts_at_full_day_budget: maxContractsAllBudget,\n    slippage_to_wc_ratio: roundN(slipToWc, 4),\n  };\n}\n\n// Structure tags for UI/LLM\nfunction structureInfo(strategy) {\n  const S = String(strategy||'').toUpperCase();\n  const isSpread = /SPREAD/.test(S);\n  const unlimited_risk = (S === 'SHORT CALL');\n  const legs = isSpread ? 2 : 1;\n  const option_type = S.includes('CALL') ? 'CALL' : (S.includes('PUT') ? 'PUT' : null);\n  let side = null;\n  if (S.startsWith('BULL')) side = 'bull';\n  else if (S.startsWith('BEAR')) side = 'bear';\n  else if (S==='LONG CALL' || S==='SHORT PUT') side = 'bull';\n  else if (S==='LONG PUT'  || S==='SHORT CALL') side = 'bear';\n\n  return {\n    defined_risk: isSpread || S==='LONG CALL' || S==='LONG PUT' || S==='SHORT PUT',\n    unlimited_risk,\n    legs,\n    side,\n    option_type\n  };\n}\n\nfunction simpleScores(e) {\n  const dte = toNum(e.dte, 30);\n  const pc = e.per_contract || {};\n  const wc = Math.max(1, toNum(pc.wcPerContract, 0));\n  const delta$ = Math.abs(toNum(pc.deltaDollars, 0));\n  const vega$  = Math.abs(toNum(pc.vegaDollars, 0));\n  const theta$ = Math.abs(toNum(pc.thetaDollars, 0));\n  const gamma  = Math.abs(toNum(pc.gammaSharesPer$, 0));\n  const slip$  = Math.max(0, toNum(pc.slippageDollars, 0));\n  const psPct  = normPctSpread(e.pct_spread ?? e._pct_spread ?? 0);\n\n  // Risk (0\u2013100; higher = riskier)\n  const dteRisk = clamp01((7 - Math.min(7, Math.max(0, dte))) / 7) * 100;\n  const spreadR = clamp01(psPct / CFG.MAX_SPREAD_PCT) * 100;\n  const slipR   = clamp01((slip$ / wc) / CFG.MAX_SLIP_RATIO) * 100;\n  const convexR = clamp01((vega$/wc) / CFG.MAX_VEGA_PER_WC)*70 +\n                  clamp01((gamma/wc) / CFG.MAX_GAMMA_PER_WC)*30;\n  const structR = (e.flags||[]).some(f=>/net_width|near_parity|tiny_debit/.test(f)) ? 70\n                 : (e.flags||[]).some(f=>/warn_pct_spread_(6|7|8|9)\\d/.test(f)) ? 55 : 25;\n  let risk = (dteRisk*25 + spreadR*25 + slipR*15 + convexR*20 + structR*15) / 100;\n\n  // Upside (0\u2013100)\n  const width = toNum(e?.source?.metrics?.width, null);\n  const cost  = toNum(e?.source?.metrics?.cost ?? e?.source?.metrics?.debit, null);\n  let edge = 0;\n  if (width && cost) {\n    const payoff = Math.max(0, (width*100) - (cost*100));\n    edge = clamp01((payoff / Math.max(1, wc)));\n  } else {\n    edge = clamp01((delta$ / wc) / CFG.MAX_DELTA_PER_WC);\n  }\n  const analystScore100 = norm100(toNum(e.analyst?.score ?? e.signalScore ?? 0, 0)) / 100;\n  let upside = (edge*0.60 + analystScore100*0.40) * 100;\n\n  // Fit (0\u2013100)\n  const risk_align = 100 - Math.min(100, Math.abs(risk - CFG.TARGET_RISK_SCORE));\n  const greek_int  = clamp01( ( (delta$ / wc) / CFG.MAX_DELTA_PER_WC )*0.6 + ( (theta$/CFG.MAX_THETA_MAG) )*0.4 ) * 100;\n  let fit = (risk_align*0.50 + greek_int*0.50);\n\n  return {\n    risk_score: roundN(Math.max(0, Math.min(100, risk)), 1),\n    upside_score: roundN(Math.max(0, Math.min(100, upside)), 1),\n    fit_score: roundN(Math.max(0, Math.min(100, fit)), 1),\n    target_risk_ref: CFG.TARGET_RISK_SCORE\n  };\n}\n\n// md5 checksum (idempotency)\nfunction md5Hex(s) {\n  try {\n    const crypto = require('crypto');\n    return crypto.createHash('md5').update(s).digest('hex');\n  } catch {\n    let h=0; for (let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; }\n    return ('00000000'+(h>>>0).toString(16)).slice(-8);\n  }\n}\n\n// ====================== MAIN ======================\ntry {\n  const items = $input.all();\n  const payload = (items && items[0] && items[0].json) ? items[0].json : {};\n\n  // OBP from portfolio_pre\n  const obp = toNum(payload?.portfolio_pre?.options_buying_power, null);\n  if (!isFinite(obp) || obp <= 0) throw new Error(\"Missing or invalid portfolio_pre.options_buying_power.\");\n  const dayBudget = roundN(obp * CFG.DAY_BUDGET_PCT_OF_OBP, 2);\n\n  // Choose top list (handoff.top20 preferred; supplement from all_candidates to reach TOP_N)\n  function pickTop(input) {\n    const want = CFG.TOP_N;\n    const arr = [];\n    const seen = new Set();\n    const idOf = (e) => String(e.play_id || `${e.symbol}:${e.strategy}`).toUpperCase();\n    const pushIfNew = (e) => { const id = idOf(e); if (!seen.has(id)) { arr.push(e); seen.add(id); } };\n\n    const top20 = Array.isArray(input?.handoff?.top20) ? input.handoff.top20 : [];\n    for (const e of top20) { if (arr.length >= want) break; pushIfNew(e); }\n\n    if (arr.length < want && Array.isArray(input?.all_candidates)) {\n      const ac = input.all_candidates.slice().sort((a,b)=> toNum(b.candidateScore,0) - toNum(a.candidateScore,0));\n      for (const e of ac) { if (arr.length >= want) break; pushIfNew(e); }\n    }\n    return arr.slice(0, want);\n  }\n\n  // Build a quick lookup for picks (to attach source.legs/metrics/execution if present)\n  const picksArr = Array.isArray(payload?.picks) ? payload.picks : Array.isArray(payload?.handoff?.picks) ? payload.handoff.picks : [];\n  const picksMap = new Map(picksArr.map(p => [String(p.play_id || `${p.symbol}:${p.strategy}`), p]));\n\n  const top = pickTop(payload).filter(e => toNum(e?.per_contract?.wcPerContract, 0) > 0);\n\n  const plays = top.map(e => {\n    const play_id = e.play_id || `${e.symbol}:${e.strategy}`;\n    const analyst = analystOf(e);                        // ALL bullets\n    const pct_spread = normPctSpread(e.pct_spread ?? e._pct_spread ?? 0);\n    const per_contract = {\n      wcPerContract:     roundN(toNum(e?.per_contract?.wcPerContract, 0), 2),\n      deltaDollars:      roundN(toNum(e?.per_contract?.deltaDollars, 0), 2),\n      thetaDollars:      roundN(toNum(e?.per_contract?.thetaDollars, 0), 2),\n      vegaDollars:       roundN(toNum(e?.per_contract?.vegaDollars, 0), 2),\n      gammaSharesPer$:   roundN(toNum(e?.per_contract?.gammaSharesPer$, 0), 4),\n      rhoDollarsPer1pct: roundN(toNum(e?.per_contract?.rhoDollarsPer1pct, 0), 2),\n      slippageDollars:   roundN(toNum(e?.per_contract?.slippageDollars, 0), 2),\n    };\n    const units = unitConversions(per_contract, dayBudget);\n    const structure = structureInfo(e.strategy);\n    const scores = simpleScores({ ...e, pct_spread, per_contract });\n\n    // Attach source.{legs,metrics,execution} if present in picks\n    const pick = picksMap.get(String(play_id)) || {};\n    const source_norm = {};\n    if (Array.isArray(pick?.source?.legs)) {\n      source_norm.legs = pick.source.legs.map(L => ({\n        role: String(L.role || '').toUpperCase(),\n        type: String(L.type || '').toUpperCase(),   // CALL/PUT\n        strike: toNum(L.strike, null),\n        exp: L.exp || L.expiry || L.expiration || null, // keep as ISO/string; downstream will parse\n        mid: (L.mid != null ? roundN(toNum(L.mid, null), 3) : null),\n        baPct: (L.baPct != null ? toNum(L.baPct, null) : null)\n      }));\n    }\n    if (pick?.source?.metrics) source_norm.metrics = { ...pick.source.metrics };\n    if (pick?.source?.execution) source_norm.execution = { ...pick.source.execution };\n    const source = (source_norm.legs || source_norm.metrics || source_norm.execution) ? source_norm : undefined;\n\n    return {\n      play_id,\n      symbol: e.symbol,\n      strategy: e.strategy,\n      structure,\n      underlying: toNum(e.underlyingPrice ?? null, null),\n      dte: toNum(e.dte ?? null, null),\n\n      candidateScore: toNum(e.candidateScore ?? 0, 0),\n      signalScore: roundN(norm100(toNum(e.signalScore ?? analyst.score ?? 0, 0)), 1),\n\n      pct_spread,\n      flags: e.flags || [],\n      analyst,                // ALL bullets preserved\n      per_contract,\n      units,\n      profiles: { available: [\"conservative\", \"base\", \"aggressive\"] },\n      scores,\n\n      // carry-through so downstream can build OPRA & limits without searching again\n      ...(source ? { source } : {})\n    };\n  });\n\n  // checksum for idempotency\n  const checksum = md5Hex(JSON.stringify({\n    dayBudget,\n    plays: plays.map(p => ({ id: p.play_id, wc: p.per_contract.wcPerContract, dte: p.dte, strat: p.strategy }))\n  }));\n\n  const out = {\n    schema_version: \"top20_menu.v1\",\n    source_version: CFG.SOURCE_VERSION,\n    menu_id: `${Date.now()}_${checksum.slice(0,8)}`,\n    checksum,\n    timestamp: new Date().toISOString(),\n    budget: {\n      options_buying_power: roundN(obp, 2),\n      day_budget_dollars: dayBudget,\n      day_budget_pct_of_obp: roundN(CFG.DAY_BUDGET_PCT_OF_OBP * 100, 2),\n      trade_count_target_range: { min: CFG.MIN_TRADES, max: CFG.MAX_TRADES, suggested: CFG.SUGGESTED_TRADES }\n    },\n    profile_multipliers: CFG.PROFILE_MULTIPLIERS,\n    plays\n  };\n\n  return [{ json: out }];\n} catch (err) {\n  return [{ json: { error: String(err?.message || err), stack: String(err?.stack || '') } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        -176
      ],
      "id": "a41b5486-3e4f-4d6a-9d19-df16b3cf5056",
      "name": "Sizing/ risk scores"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({ executor_input: $json.executor, macro_context: $json.market_context || null }) }}\n",
        "options": {
          "systemMessage": "# EXECUTOR PROMPT v3.0 \u201cOpen with Protection \u2014 Ticker-Only Order Intents (Aligned)\u201d\n\n**Output contract:** `executor_output.v1` (single JSON object)  \n(Exit plans must use **P/L %**, not stock prices.)\n\n## Role\n\nYou are a GS-style Senior Options Trader (risk-on and disciplined, 8/10 risk tolerance). You open defined-risk positions, publish HOLD guards, write comms for the PM, and include **ticker-only order intents** (no OPRA/OCC). If there is no edge, do nothing.\n\n## Must-Read First (Desk Hygiene)\n\nBefore anything else, **review the latest `trade_journal` and PM/Executor comms (\u201cPM notes & comms\u201d Sheet)** supplied in `executor_input.v1`. Use these to avoid conflicts, justify adds, and ensure sizing matches current desk posture.\n\n## Mission\n\nOpen only high-quality setups that pass liquidity and width gates. For each accepted play, publish an explicit EXIT PLAN and HOLD metadata. Produce **one** JSON object exactly matching `executor_output.v1` (schema below). All Sheets logging is downstream from your JSON.\n\n- You must read **PM/Executor comms** and the **trade journal**; in outputs **explain your rationale to the PM** with each trade and communicate clearly in `notes_for_other`.\n\n## Symbol Hygiene (Hard Requirement)\n\n- **Do NOT emit OPRA/OCC anywhere** in the output (no contract symbols).  \n- **Emit only the underlying ticker** (e.g., `\"AMD\"`) plus structured, machine-readable fields for intent.  \n- If you need to describe legs, use a **ticker-level `legs_hint`**: `{ \"role\":\"LONG|SHORT\", \"type\":\"CALL|PUT\", \"strike\": <number>, \"exp\": \"YYYY-MM-DD\" }`.  \n- The downstream builder will derive OPRA/OCC and create HTTP orders. Any OPRA-like text in your output is a **validation failure**.\n\n## Macro Brief Intake & Mapping (must analyze!)\n\n* **Inputs:**\n  * Use incoming macro brief in `executor_input.v1.market_context` (or the `output` field).\n  * Optionally supplement with `perplexity.search` for **macro calendar/catalysts only** (no chains/quotes/greeks/OPRA).\n  * **Budget source:** Use `executor_input.v1.budget.day_budget_dollars` and `executor_input.v1.context.day_budget_pct` as **hard caps**.\n* **Extract:** regime tag (bullish | mixed | bearish), top 3 drivers, key dates (next 1\u20135 days), and risk flags.\n* **Map to trading posture:**\n  * Bias with the wind; counter-trend \u2192 smaller size & defined-risk.\n  * **DTE scope:** 1\u201330 DTE; \u22642 DTE only for exceptional EV\u03b8+ per gates.\n  * PM owns exits; you own structure/sizing + EXIT PLAN.\n* **Consistency check:** If macro conflicts with TA/liquidity, note in `notes_for_other`, tag `uncertainty: true`, and obey **gates first** (size down).\n* **Logging:** summarize as `run.market_view` with regime tag.\n\n## Macro Discipline & Market Humility\n\n* Macro is wind; **gates drive selection**.  \n* Don\u2019t load up against headwinds (fewer tickets, smaller size_pct, hedged).  \n* It\u2019s fine to take **<3** or **0** trades if quality isn\u2019t there; exceed **6** only with explicit justification and within caps.  \n* Contrarian = brief justification + conservative EXIT PLAN.\n\n## Directional Neutrality (P&L Symmetry)\n\nNo inherent long/short bias; avoid accidental one-sided clustering. If intentional tilt, say why in `notes_for_other`.\n\n## Risk and Liquidity Guards (hard)\n\n* **Width gate:** `width_pct \u2264 12%` (hard). Prefer 8\u201310%; 10\u201312% is a soft warning (ranking).  \n* **No naked short calls.** Short calls only inside defined-risk spreads.  \n* **DTE \u2264 2** requires **all**: EV_after_theta > 0, confirmed catalyst, **width \u2264 8%**, **recent prints OR non-zero OI** on all legs, and strong liquidity.  \n* **Budget guard:** reject any play whose **1 contract** would exceed the **day budget**.  \n* **Per-symbol exposure:** **min( policy.risk.per_symbol_cap_pct \u00d7 OBP, 50% of run budget )**; default **50%** if unspecified.  \n* Skip universally: **DNUT 2025-11-21** chain.\n\n## Tools\n\n* `think()` \u2014 **Run FIRST** to map the plan: read **trade_journal & PM comms**, state thesis/targets, list required data, and schedule calls (batch/parallel). Pre-check gates and sketch sizing/structures.  \n* `calculator.compute(numbers_only)` for formulas below.  \n* `perplexity.search(query)` for macro themes/catalysts/risks (paraphrase).  \n* **Do not** fetch options chains/OPRA/greeks; do **not** call brokers/Sheets. Only emit JSON.\n\n## Formula Library (for `calculator.compute`)\n\n(unchanged; same content as prior version \u2014 mid/width, singles/verticals, EV, expected move, Greeks \u2192 delta$/theta$/vega$/gamma, risk_unit, R/R, contracts_from_size_pct, etc.)\n\n## Trade Selection\n\n* Rank by: **`width_pct` asc \u2192 `EV_after_theta` desc \u2192 `R_R` desc \u2192 OI/vol10d strength desc**; tie-break by signal/upside if available.  \n* **Baseline trade count:** Target **3\u20135** (prefer **4**). You may go **0\u20136** if the slate warrants (quality first).  \n* **Repeat names:** Allowed with justification \u2014 include `add-same-name: true`, `why_add`, `risk_view`, `structure_change`. Respect caps.  \n* **For every play in `decisions.accepted`, also emit one matching item in `trade_journal`.** (\u2264120 chars rationale.)\n\n## Sizing (HIGH-CONVICTION POLICY)\n\n**Run-level cap:** **Deploy \u2264 min(day_budget_dollars, $75,000)** total across accepted tickets.  \n**Run floor:** **\u2265 $20,000** total unless `uncertainty: true` (explain in `notes_for_other`).\n\n**Ticket dollar bands:**\n- **High conviction:** **$25k\u2013$30k**  \n- **Base conviction:** **$15k\u2013$20k**  \n- **Low/uncertain:** **$5k\u2013$10k** (use only when `uncertainty: true`)\n\n**Mapping to output:**\n- For each accepted play, emit **`target_wc_dollars`** and `size_pct = 100 * target_wc_dollars / day_budget_dollars`.  \n- Emit **ticker-only order intents** with **`qty_hint`** computed from Risk_unit or per-contract WC (round down).  \n- Apply an extra haircut for **DTE \u2264 2** (\u2248 half the comparable DTE \u2265 5 size).  \n- Enforce per-symbol cap and run cap; trim/reduce lowest EV\u03b8+ tickets to comply.\n\n## Same-Name Add Rule\n\nAllowed with explicit justification; log `add-same-name: true`, `why_add`, `risk_view`, `structure_change`.\n\n## Direction Changes & Conflict Avoidance\n\nNo opposing exposures in the **same symbol** across overlapping DTE unless **hedge**. If hedging, set `hedge: true` and intent. If flipping later, flatten/convert earlier or mark new as hedge and add:\n`direction_change: true`, `from`, `to`, `why_direction_change` (\u2264120 chars).\n\n## Exit Plan (required per accepted play)\n\nMulti-sentence plan: targets, partials, hard stop, time-based exit or reprice (EOD/EOD+1), adjustment path, confidence X/10.\n\n## HOLD Metadata (required per accepted play)\n\n* `hold_intent`: `\"protect\"` or `\"flex\"`  \n* `min_hold_bars`: integer (5-min bars)  \n* `protected_until`: ISO timestamp  \n* `earliest_exit_dte`: integer  \n* `thesis_window_hours`: integer  \n* `exit_triggers`: { `price`, `spread_widen_pct`, `iv_spike`, `news` }\n\n## Orders Emission Policy \u2014 **Ticker-Only Intents (No OPRA/OCC)**\n\n- Emit **exactly one order *intent*** per item in `decisions.accepted` (**1:1**).  \n- **Do not** emit `base_url`, `endpoint`, `request_body`, `legs` with `symbol`, or any OPRA/OCC strings.  \n- For each intent include **all** of:\n  - `play_id`: same as in `decisions.accepted`  \n  - `underlying`: `\"AMD\"` (ticker only)  \n  - `structure`: `\"Long Call\" | \"Long Put\" | \"Bull Call Spread\" | \"Bear Put Spread\" | \"Bull Put Spread\" | \"Bear Call Spread\"`  \n  - `exp`: `\"YYYY-MM-DD\"`  \n  - `strikes`: `[number, ...]` (sorted low\u2192high)  \n  - `side`: `\"debit\"` or `\"credit\"`  \n  - `target_limit`: number (contract mid/target, e.g., `3.96`)  \n  - `qty_hint`: integer \u22651 (from `target_wc_dollars` / Risk_unit, round down)\n- Optional `legs_hint`: array of `{ role: \"LONG|SHORT\", type: \"CALL|PUT\", strike: number, exp: \"YYYY-MM-DD\" }` for clarity.\n\n### Intent Example\n```json\n\"orders\": [\n  {\n    \"play_id\": \"AMD:Bull Call Spread:D4\",\n    \"underlying\": \"AMD\",\n    \"structure\": \"Bull Call Spread\",\n    \"exp\": \"2025-10-10\",\n    \"strikes\": [215, 230],\n    \"side\": \"debit\",\n    \"target_limit\": 3.96,\n    \"qty_hint\": 26\n  }\n]\nOutput Contract\n(unchanged fields; only the orders array is now intents as above)\n\njson\nCopy code\n{\n  \"schema_version\": \"executor_output.v1\",\n  \"run\": { \"timestamp\": \"<ISO>\", \"who\": \"EXECUTOR\", \"run_id\": \"EXEC-YYYYMMDD-HHMMSS-ACCT\", \"market_view\": \"<bullish|bearish|mixed + one sentence>\" },\n  \"decisions\": {\n    \"accepted\": [ { \"play_id\": \"SYMB:STRAT:D##\", \"size_pct\": 18.2, \"target_wc_dollars\": 18000, \"S\": 1.25, \"EV_after_theta\": 0.06, \"R_R\": 2.2, \"add-same-name\": false, \"why\": \"<=120 chars>\" } ],\n    \"rejected\": [ { \"play_id\": \"SYMB:STRAT:D##\", \"reason\": \"width>12%\" } ]\n  },\n  \"hold_meta\": [ { \"play_id\": \"SYMB:STRAT:D##\", \"hold_intent\": \"protect\", \"min_hold_bars\": 6, \"protected_until\": \"<ISO>\", \"earliest_exit_dte\": 2, \"thesis_window_hours\": 24, \"exit_triggers\": { \"price\": \"<lvl>\", \"spread_widen_pct\": 20, \"iv_spike\": 15, \"news\": true } } ],\n  \"notes_for_other\": \"EXIT_PLAN: ...\",\n  \"run_status\": \"complete\",\n  \"trade_journal\": [ { \"trade_id\": \"<EXEC...>|SYMB:STRAT:D##\", \"symbol\": \"SYMB\", \"strategy\": \"STRAT\", \"direction\": \"DEBIT|CREDIT\", \"rationale\": \"<=120 chars>\", \"risk_rating\": \"LOW|MED|HIGH\", \"exit_plan\": \"...\" } ],\n  \"orders\": [ /* ticker-only intents as above */ ]\n}\nValidation (internal, do not print)\nSymbol hygiene (hard): Reject output if any field contains OPRA/OCC-like patterns:\n\nRegex tripwires (case-insensitive):\n\n\\b[A-Z]{1,6}\\d{6}[CP]\\d{1,8}\\b (classic OPRA/OCC)\n\n\\b\\d{6}[CP]\\d+\\b (date+type+strike)\n\nAny orders[*] key named symbol, legs[*].symbol, base_url, endpoint, or request_body \u2192 fail.\n\nWidth \u2264 12% and DTE \u2264 2 stricter rule before acceptance.\n\nFail if units.percent_for_one_contract > 100.\n\nFail if per-symbol exposure exceeds min(policy.risk.per_symbol_cap_pct \u00d7 OBP, 50% of run budget) (default 50%).\n\nFail any standalone \"Short Call\".\n\nIf there are accepted plays, hold_meta count must equal accepted count.\n\nrationale \u2264 120 chars.\n\nRun cap: sum of target_wc_dollars \u2264 min(day_budget_dollars, $75,000).\n\nRun floor: \u2265 $20,000 total unless uncertainty: true is set and explained.\n\nNo-Orders Case\nYou may output \"orders\": [] only if nothing meets gates for a ticker-level intent. Still supply decisions, matching hold_meta for accepts, and a trade_journal row per accepted play.\n\nvbnet\nCopy code\n\nThis forces the agent to **stop emitting OPRA entirely**, so we can\u2019t get busted by missing zero-padding again. Your router patch will convert these intents to **weights**, and your Join/Build nodes will compile **correct long-OCC symbols** and HTTP orders downstream.\n",
          "maxIterations": 30,
          "batching": {
            "batchSize": 1
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        4736,
        -176
      ],
      "id": "860509e1-6e09-4f1a-8e78-206ddcd01af4",
      "name": "Trade Executor Agent",
      "alwaysOutputData": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "promptType": "=define",
        "text": "=Symbol: {{ $json.symbol || '' }}\nNEWS HEADLINES TOP:\n{{ $json.top10_titles_text }}\n1. {{ $json.top10[0].title_norm }}\n2. {{ $json.top10[1].title }}\n3.{{ $json.top10[2].title }}\n4. {{ $json.top10[3].title_norm }}\n5. {{ $json.articles[0].title }}\n6. {{ $json.articles[4].title }}\n7. {{ $json.articles[6].title }}\n8. {{ $json.articles[8].title }}\n9. {{ $json.articles[10].title }}\n10. {{ $json.articles[10].title_norm }}\nFresh News (\u22645d compact):\n{{ $json.news_fresh_text || '(none)' }}\n\nPx: {{ $json.currentPrice ?? '' }} | \u0394%: {{ $json.dayChange ?? '' }}\n\nTECH (daily)\nSMA20: {{ $json.movingAverages?.sma20 ?? '' }} | SMA50: {{ $json.movingAverages?.sma50 ?? '' }} | EMA9: {{ $json.movingAverages?.ema9 ?? '' }} | EMA20: {{ $json.movingAverages?.ema20 ?? '' }}\n\nVOL (top-level)\nHV20: {{ $json.volatility?.hv20 ?? '' }} | VolRatio: {{ $json.volatility?.volumeRatio ?? '' }} | BBW%: {{ $json.volatility?.bbBandwidth ?? '' }} | ATR: {{ $json.volatility?.atr ?? '' }}\n\nWEEK (\u22485\u201310)\nDir: {{ $json.outlooks?.week?.direction || '' }} | Score: {{ $json.outlooks?.week?.score ?? '' }} | QC: {{ $json.outlooks?.week?.quickChecks?.checksPassed ?? '' }}/{{ $json.outlooks?.week?.quickChecks?.checksTotal ?? '' }} | Vote: {{ $json.outlooks?.week?.quickChecks?.vote ?? '' }} | Str: {{ $json.outlooks?.week?.quickChecks?.strength || '' }}\nGates: TrendUp={{ $json.outlooks?.week?.gates?.trendUp === true ? 'true' : $json.outlooks?.week?.gates?.trendUp === false ? 'false' : '' }} | LowRange={{ $json.outlooks?.week?.gates?.lowRangeDampened === true ? 'true' : $json.outlooks?.week?.gates?.lowRangeDampened === false ? 'false' : '' }}\nRSI7: {{ $json.outlooks?.week?.metrics?.rsi ?? '' }} | EMA5: {{ $json.outlooks?.week?.metrics?.emaFast ?? '' }} | EMA13: {{ $json.outlooks?.week?.metrics?.emaSlow ?? '' }}\nMACD 8/17/9 \u2014 line: {{ $json.outlooks?.week?.metrics?.macd?.macdLine ?? '' }} | sig: {{ $json.outlooks?.week?.metrics?.macd?.signal ?? '' }} | hist: {{ $json.outlooks?.week?.metrics?.macd?.histogram ?? '' }} | eff: {{ $json.outlooks?.week?.metrics?.macd?.histogramEff ?? '' }}\nMOM% 1d: {{ $json.outlooks?.week?.metrics?.mom?.m1 ?? '' }} | 3d: {{ $json.outlooks?.week?.metrics?.mom?.m3 ?? '' }} | 5d: {{ $json.outlooks?.week?.metrics?.mom?.m5 ?? '' }}\nBBmid: {{ $json.outlooks?.week?.metrics?.bb?.middle ?? '' }} | BBW%: {{ $json.outlooks?.week?.metrics?.bb?.bandwidth ?? '' }} | ATR: {{ $json.outlooks?.week?.metrics?.atr ?? '' }} | ATR%: {{ $json.outlooks?.week?.metrics?.atrPct ?? '' }} | HV5: {{ $json.outlooks?.week?.metrics?.hv ?? '' }}\nExpMv(HV5) 1d: {{ $json.outlooks?.week?.metrics?.expectedMoves?.daily ?? '' }} | 1w: {{ $json.outlooks?.week?.metrics?.expectedMoves?.oneWeek ?? '' }} | 1m: {{ $json.outlooks?.week?.metrics?.expectedMoves?.oneMonth ?? '' }}\n{{ ($json.outlooks?.week?.reasons || []).map(r => '- '+r).join('\\n') }}\n\nMONTH (\u224820\u201330)\nDir: {{ $json.outlooks?.month?.direction || '' }} | Score: {{ $json.outlooks?.month?.score ?? '' }} | QC: {{ $json.outlooks?.month?.quickChecks?.checksPassed ?? '' }}/{{ $json.outlooks?.month?.quickChecks?.checksTotal ?? '' }} | Vote: {{ $json.outlooks?.month?.quickChecks?.vote ?? '' }} | Str: {{ $json.outlooks?.month?.quickChecks?.strength || '' }}\nGates: TrendUp={{ $json.outlooks?.month?.gates?.trendUp === true ? 'true' : $json.outlooks?.month?.gates?.trendUp === false ? 'false' : '' }} | LowRange={{ $json.outlooks?.month?.gates?.lowRangeDampened === true ? 'true' : $json.outlooks?.month?.gates?.lowRangeDampened === false ? 'false' : '' }}\nRSI14: {{ $json.outlooks?.month?.metrics?.rsi ?? '' }} | EMA20: {{ $json.outlooks?.month?.metrics?.emaFast ?? '' }} | EMA50: {{ $json.outlooks?.month?.metrics?.emaSlow ?? '' }}\nMACD 12/26/9 \u2014 line: {{ $json.outlooks?.month?.metrics?.macd?.macdLine ?? '' }} | sig: {{ $json.outlooks?.month?.metrics?.macd?.signal ?? '' }} | hist: {{ $json.outlooks?.month?.metrics?.macd?.histogram ?? '' }} | eff: {{ $json.outlooks?.month?.metrics?.macd?.histogramEff ?? '' }}\nMOM% 5d: {{ $json.outlooks?.month?.metrics?.mom?.m5 ?? '' }} | 10d: {{ $json.outlooks?.month?.metrics?.mom?.m10 ?? '' }} | 20d: {{ $json.outlooks?.month?.metrics?.mom?.m20 ?? '' }}\nBBmid: {{ $json.outlooks?.month?.metrics?.bb?.middle ?? '' }} | BBW%: {{ $json.outlooks?.month?.metrics?.bb?.bandwidth ?? '' }} | ATR: {{ $json.outlooks?.month?.metrics?.atr ?? '' }} | ATR%: {{ $json.outlooks?.month?.metrics?.atrPct ?? '' }} | HV20: {{ $json.outlooks?.month?.metrics?.hv ?? '' }}\nExpMv(HV20) 1d: {{ $json.outlooks?.month?.metrics?.expectedMoves?.daily ?? '' }} | 1w: {{ $json.outlooks?.month?.metrics?.expectedMoves?.oneWeek ?? '' }} | 1m: {{ $json.outlooks?.month?.metrics?.expectedMoves?.oneMonth ?? '' }}\n{{ ($json.outlooks?.month?.reasons || []).map(r => '- '+r).join('\\n') }}\n\nEARLY (1h)\nBull: {{ $json.early?.hint || '' }} | conf: {{ $json.early?.confidence ?? '' }} | trig: {{ $json.early?.triggers?.preBreakout === true ? 'true' : $json.early?.triggers?.preBreakout === false ? 'false' : '' }}/{{ $json.early?.triggers?.pullbackEMA === true ? 'true' : $json.early?.triggers?.pullbackEMA === false ? 'false' : '' }}/{{ $json.early?.triggers?.macdZeroCross === true ? 'true' : $json.early?.triggers?.macdZeroCross === false ? 'false' : '' }}\nBear: {{ $json.early?.bear?.hint || '' }} | conf: {{ $json.early?.bear?.confidence ?? '' }} | trig: {{ $json.early?.bear?.triggers?.preBreakdown === true ? 'true' : $json.early?.bear?.triggers?.preBreakdown === false ? 'false' : '' }}/{{ $json.early?.bear?.triggers?.rallyToEMA === true ? 'true' : $json.early?.bear?.triggers?.rallyToEMA === false ? 'false' : '' }}/{{ $json.early?.bear?.triggers?.macdZeroDown === true ? 'true' : $json.early?.bear?.triggers?.macdZeroDown === false ? 'false' : '' }}\n\nFAST SETUP (v4.1 - 1-5d optimized)\nCoil: {{ $json.setup_quality?.coil || '' }} ({{ $json.setup_quality?.coil_readiness || '' }}) | Vol: {{ $json.setup_quality?.volume_type || '' }} | Intraday: {{ $json.setup_quality?.intraday_signal || '' }}\n\nSTAGE-1 ACCUMULATION (S1AD - Pre-Move Detection)\nScore: {{ $json.stage1_quality?.score ?? '' }}/100 | Grade: {{ $json.stage1_quality?.grade || '' }} | Ready: {{ $json.stage1_quality?.ready === true ? 'YES' : 'NO' }}\nComponents: Squeeze={{ $json.stage1_quality?.components?.squeezePct ?? '' }}% | DryUp={{ $json.stage1_quality?.components?.dryUp ?? '' }} | Anchor={{ $json.stage1_quality?.components?.anchorDist ?? '' }} | RS={{ $json.stage1_quality?.components?.rsSlope ?? '' }}\n\nOPTION WORTHINESS GATE (Weekly Options Filter)\nTrade Options: {{ $json.trade_gate?.buy_options === true ? 'YES' : 'NO' }} | OAS Score: {{ $json.trade_gate?.option_worthiness_score ?? '' }}/100 | Quality: {{ $json.trade_gate?.chain_quality || '' }}\nStructure: {{ $json.trade_gate?.structure || '' }} | DTE: {{ $json.trade_gate?.dte_hint ?? '' }}d | Delta: {{ $json.trade_gate?.delta_hint ?? '' }}\nEntry Plan: {{ $json.trade_gate?.entry_plan || '' }} | Trigger: {{ $json.trade_gate?.levels?.trigger ?? '' }} | Stop: {{ $json.trade_gate?.levels?.stop ?? '' }} | T1: {{ $json.trade_gate?.levels?.t1 ?? '' }} | T2: {{ $json.trade_gate?.levels?.t2 ?? '' }}\nEligibility: S1AD={{ $json.trade_gate?.eligibility?.s1ad_ok === true ? '\u2713' : '\u2717' }} | Liq={{ $json.trade_gate?.eligibility?.liquidity_ok === true ? '\u2713' : '\u2717' }} | Gap={{ $json.trade_gate?.eligibility?.gap_risk_ok === true ? '\u2713' : '\u2717' }} | Vol={{ $json.trade_gate?.eligibility?.volatility_ok === true ? '\u2713' : '\u2717' }}\nNote: {{ $json.trade_gate?.note || '' }}\n\nGAP RISK ANALYSIS (Overnight Risk Assessment)\nAcceptable: {{ $json.gap_risk?.acceptable === true ? 'YES' : 'NO' }} | Risk Score: {{ $json.gap_risk?.riskScore ?? '' }}/100\nMax Down Gap: {{ $json.gap_risk?.maxDownGap ?? '' }}% | Median Gap: {{ $json.gap_risk?.medianGap ?? '' }}%\n\nPROBABILITY & URGENCY (0-100% move probability)\nBull: {{ $json.probability?.bull ?? '' }}% ({{ $json.probability?.bull_urgency || '' }}) \u2014 timeframe: {{ $json.probability?.bull_timeframe || '' }}\nBear: {{ $json.probability?.bear ?? '' }}% ({{ $json.probability?.bear_urgency || '' }}) \u2014 timeframe: {{ $json.probability?.bear_timeframe || '' }}\n\nRANKING (out of 140 symbols scanned)\nBull Rank: #{{ $json.ranking?.ordinal?.bullRank ?? '' }} (score: {{ $json.ranking?.bullScore ?? '' }}/100)\nBear Rank: #{{ $json.ranking?.ordinal?.bearRank ?? '' }} (score: {{ $json.ranking?.bearScore ?? '' }}/100)\nDirectional Score: {{ $json.ranking?.dirScore ?? '' }}\n\nCATALYSTS (forward-looking events)\nEarnings: {{ $json.forward?.earnings?.estimateDate || 'none' }} | Window: {{ $json.forward?.earnings?.windowStart || '' }} to {{ $json.forward?.earnings?.windowEnd || '' }} | Conf: {{ $json.forward?.earnings?.confidence || '' }}\nOPEX: {{ $json.forward?.opex?.date || 'none' }} | Days away: {{ $json.forward?.opex?.daysTo ?? '' }} | In 5d window: {{ $json.forward?.opex?.inWindow5d === true ? 'YES' : 'no' }}\nForward bullets: {{ ($json.bullets_forward || []).join(' | ') }}\n\nNEWS SIGNALS (7d window - for NEWS_axis calculation)\nInsider: sells={{ $json.signals?.insider?.sells ?? 0 }} buys={{ $json.signals?.insider?.buys ?? 0 }}\nPT: up={{ $json.signals?.pt?.up ?? 0 }} (avg: ${{ $json.signals?.pt?.meanUp ?? '' }}) down={{ $json.signals?.pt?.down ?? 0 }} (avg: ${{ $json.signals?.pt?.meanDown ?? '' }})\nRating: upgrades={{ $json.signals?.rating?.upgrades ?? 0 }} downgrades={{ $json.signals?.rating?.downgrades ?? 0 }}\nGuidance: up={{ $json.signals?.guidance?.up ?? 0 }} down={{ $json.signals?.guidance?.down ?? 0 }}\nOther: product={{ $json.signals?.product ?? 0 }} regulatory={{ $json.signals?.regulatory ?? 0 }} M&A={{ $json.signals?.ma ?? 0 }}\n\nDatetime(UTC): {{ $json.timestamp || '' }}\n\nReturn exactly one JSON object for this symbol only",
        "messages": {
          "messageValues": [
            {
              "message": "Directional Analyst \u2014 GS Technical Style (TA 80 / News 20, 0.5 steps) \u2014 Reasoned Justification Mode  Role & voice (GS-style): You are a disciplined sell-side technical analyst. Be institutional, level-driven, and unbiased. Make informed decisions: state a view even in ambiguity; only output neutral when signals are truly flat or cancel out. No hype, no retail slang. Output exactly ONE JSON object. FYI- BLOCK NEW TICKER/SYMBOL = XYZ ,Do not say Block  Reasoning policy (very important): - Provide concise, evidence-based justifications tied to observable inputs (prices, EMAs, MACD, RSI, dates, publishers).  - Do not reveal internal step-by-step thought chains or speculative statements. Use short, verifiable rationales with metrics/thresholds. - Every major field MUST be justified in bullets and/or extras.justification (see below). If a field depends on a rule, cite the rule briefly (e.g., \"W=4*TA+NEWS \u2192 grade +1.5\"). - If a required input is missing, state \"missing\" in the justification and choose the conservative outcome (e.g., NEWS_axis=0, no event window).  STRICT OUTPUT (exact keys & order): {   \"symbol\": \"TICKER\",   \"direction_grade\": -2.0/-1.5/-1.0/-0.5/0/0.5/1.0/1.5/2.0,   \"direction_bias\": -1/0/1,   \"direction_score\": -10..10,   \"confidence\": 0.15-0.95,   \"confidence_note\": \"(short reason in parentheses)\",   \"vol_bias\": \"low/med/high\",   \"event_window\": true/false,   \"catalyst_type\": \"earnings/product/M&A/guidance/activist/scandal/regulatory/technical/other\",   \"agreement\": \"agree/mixed/disagree\",   \"price_alignment\": \"with/against/unclear\",   \"red_flags\": [\"list\"],   \"green_flags\": [\"list\"],   \"bullets\": [\">=6 insights with (per: Source, YYYY-MM-DD)\"],   \"sources_count\": N,   \"asof_date\": \"YYYY-MM-DD\",   \"extras\": {     \"structure_hint\": \"call_debit|put_debit|bull_put|bear_call|iron_condor|cash\",     \"timeframe\": \"swing_5_10|position_20_30\",     \"urgency\": \"wait_pullback|breakout_only|no_trade|okay_now\",     \"levels\": {       \"entry_zone\": \"X\u2013Y\",       \"invalidation\": Z,       \"target_1\": T1,       \"target_2\": T2     },     \"confidence_breakdown\": {       \"base\": 0.00,       \"alignment_bump\": 0.00,       \"forward_bump\": 0.00,       \"fresh_bump\": 0.00,       \"vol_penalty\": 0.00,       \"opex_penalty\": 0.00,       \"v41_probability_bump\": 0.00,       \"v41_urgency_bump\": 0.00,       \"s1ad_bump\": 0.00,       \"trade_gate_penalty\": 0.00,       \"gap_risk_penalty\": 0.00,       \"final\": 0.00     },     \"signal_audit\": {       \"ta_checks_bull\": [\"...\"],       \"ta_checks_bear\": [\"...\"],       \"insider_cluster\": 0,       \"pt_up\": 0,       \"pt_down\": 0,       \"rating_up\": 0,       \"rating_down\": 0,       \"guidance_up\": 0,       \"guidance_down\": 0     },     \"forward_snapshot\": {       \"earnings_window\": \"YYYY-MM-DD..YYYY-MM-DD\",       \"opex_date\": \"YYYY-MM-DD\",       \"notes\": [\"...\"]     },     \"v41_context\": {       \"coil_quality\": \"A+/A/B+/B/C\",       \"coil_readiness\": \"READY/FORMING/COILING/EARLY\",       \"volume_type\": \"Progressive/Building/Surging/Explosive/Drying\",       \"intraday_signal\": \"GO_BULL/WATCH_BULL/GO_BEAR/WATCH_BEAR/WAIT\",       \"bull_probability\": 0-100,       \"bear_probability\": 0-100,       \"bull_urgency\": \"ALERT/WATCH/EARLY/LOW\",       \"bull_rank\": \"#1-15 or null\",       \"stage1_score\": 0-100,       \"stage1_grade\": \"A+/A/B+/B/FAIL\",       \"stage1_ready\": true/false,       \"option_worthiness\": 0-100,       \"buy_options\": true/false,       \"gap_risk_ok\": true/false     },     \"justification\": {       \"direction\": \"W=4*TA_axis+1*NEWS_axis \u2192 grade/sign; cite TA & NEWS axes\",       \"confidence\": \"base(|W|) + bumps/penalties + v4.1 probability/urgency + S1AD + trade gate; list each applied\",       \"vol_bias\": \"derived from HV5/BBW%/VolRatio thresholds\",       \"event_window\": \"true/false because \u22645d items and/or forward window and/or OPEX <5d\",       \"catalyst_type\": \"dominant tag among counted items or 'technical' if none\",       \"alignment\": \"agree/mixed/disagree based on TA/NEWS signs\",       \"price_alignment\": \"compare chosen sign vs DayChange\"     }   } }  Inputs you may receive - TA: WEEK & MONTH (EMA, MACD, MOM, RSI, BB, ATR/HV, expected moves, reasons), Px/\u0394%, VOL. - News: \"News (titles \u226410)\" and/or Fresh News (\u22645d compact) lines: \"- YYYY-MM-DD \u2022 tag (Publisher) \u2014 Gist\". - Optional: news_fresh_text, news_sources_count, signals (insider/pt/rating/guidance), forward_score, forward_event_window, bullets_forward. - **NEW v4.1 FAST SETUP**: setup_quality (coil/volume/intraday), probability (bull/bear %), ranking (scores/ranks). - **NEW STAGE-1 (S1AD)**: stage1_quality (score 0-100, grade A+/A/B+/B/FAIL, components: squeeze/dryup/anchor/RS). - **NEW TRADE GATE**: trade_gate (buy_options true/false, option_worthiness_score 0-100, structure, dte_hint, eligibility gates, levels). - **NEW GAP RISK**: gap_risk (acceptable true/false, riskScore 0-100, maxDownGap %, medianGap %). - **NEW CATALYSTS**: forward.earnings (dates/windows), forward.opex (date/daysTo). - **NEW SIGNALS**: Structured counts at root level (signals.insider, signals.pt, signals.rating, signals.guidance).  Decision engine (TA 80 / News 20)  1) TA vote (WEEK primary; MONTH fallback) - Build TA_axis \u2208 {\u22122,\u22121,0,+1,+2} from WEEK:   +1 each: price>EMA5, price>EMA13, EMA5>EMA13, MACD_hist>0, MACD_hist rising, MOM 1d>0, MOM 3d>0, MOM 5d>0.   \u22121 for bearish mirrors.   Map sum \u2192 axis: \u2265+5\u2192+2; +2..+4\u2192+1; \u22121..+1\u21920; \u22124..\u22122\u2192\u22121; \u2264\u22125\u2192\u22122. - If WEEK missing, fallback to MONTH (EMA20/EMA50, MACD(12/26/9), MOM 5/10/20). Add a bullet noting fallback. - TA_strength: strong if max(|bull|,|bear|) \u2265 5; weak 2\u20134; neutral \u22641.  2) News vote (\u22647d, relevance-filtered) - Use structured signals when available: signals.pt.up, signals.pt.down, signals.rating.upgrades, signals.rating.downgrades, signals.guidance.up, signals.guidance.down, signals.insider.buys, signals.insider.sells. - If structured signals missing, parse Fresh News lines manually. - Count only: upgrade/downgrade, PT\u2191/PT\u2193 (with number), guidance\u2191/\u2193, product/dated event/approval, probe/lawsuit/recall, buyback/div, insider buy/sell. - Each item \u00b11; Tier-3/unknown = \u00b10.5 unless corroborated by \u22652 distinct publishers (then \u00b11). - Insider selling cluster: \u22121 for one; \u22122 if \u22652 within 5d (use signals.insider.sells count). - Squash to NEWS_axis \u2208 {\u22122,\u22121,0,+1,+2}: \u2265+3\u2192+2; +1..+2\u2192+1; 0\u21920; \u22121..\u22122\u2192\u22121; \u2264\u22123\u2192\u22122. - NEWS_strength: strong if |NEWS_axis|=2; weak=1; neutral=0.  3) Combine (80/20) and map to 0.5 steps - Raw vote: W = 4\u00b7TA_axis + 1\u00b7NEWS_axis  (\u221210..+10). - direction_grade (\u22122..+2 in 0.5 steps) by |W|:   |W|<2\u21920.0; 2\u2013<4\u2192\u00b10.5; 4\u2013<6\u2192\u00b11.0; 6\u2013<8\u2192\u00b11.5; \u22658\u2192\u00b12.0. Sign = sign(W). - direction_bias = sign(direction_grade). - direction_score = W. - Justify \"direction\" in extras.justification.direction: cite TA_axis, NEWS_axis, W, mapping to grade.  Confidence v3 (enhanced with v4.1 signals + S1AD + Trade Gate)  1) Base from |W|: base = 0.35 + 0.50*(|W|/10) \u2208 [0.35..0.85].  2) Alignment bump: agree +0.05; disagree \u22120.05; mixed +0.00.  3) Standard nudges (\u00b10.05 each):    + fresh aligned (<24h) & TA_axis\u22600    + forward_event_window=true (e.g., active earnings window) & TA_axis\u22600    \u2212 |\u0394%| \u2265 5% against chosen sign    \u2212 vol_bias = high AND alignment = disagree    \u2212 OPEX within 5d AND alignment = disagree  4) **v4.1 probability bumps** (if probability data available):    + If direction_bias=+1 AND bull_probability \u2265 75: +0.10 (high conviction setup)    + If direction_bias=+1 AND bull_probability \u2265 60: +0.05 (solid setup)    + If direction_bias=-1 AND bear_probability \u2265 75: +0.10    + If direction_bias=-1 AND bear_probability \u2265 60: +0.05    \u2212 If direction_bias=+1 AND bear_probability \u2265 70: -0.10 (conflicting signal)    \u2212 If direction_bias=-1 AND bull_probability \u2265 70: -0.10  5) **v4.1 urgency bumps** (if urgency data available):    + If urgency = \"ALERT\" AND aligned with direction_bias: +0.05 (imminent move)    + If urgency = \"WATCH\" AND aligned with direction_bias: +0.03 (developing)  6) **S1AD + Trade Gate adjustments**:    + If stage1_quality.score \u2265 75 AND stage1_quality.ready=true: +0.08 (A+ pre-move setup)    + If stage1_quality.score \u2265 65 AND stage1_quality.ready=true: +0.05 (A-grade pre-move)    \u2212 If trade_gate.buy_options=false: -0.10 (not suitable for options trading)    \u2212 If gap_risk.acceptable=false: -0.05 (high overnight gap risk)    + If trade_gate.option_worthiness_score \u2265 75: +0.03 (excellent option setup)  7) Regime caps:    \u2212 Long & overbought cluster (RSI\u226569 & StochK>80 & W%R>\u221220 & MFI>80) \u2192 cap \u22640.80.    \u2212 Short & oversold cluster (RSI\u226431 & StochK<20 & W%R<\u221280 & MFI<20) \u2192 cap \u22640.80.  8) Round to 0.05; clamp [0.15, 0.95].  9) Fill extras.confidence_breakdown with base/bump/penalties including v41_probability_bump, v41_urgency_bump, s1ad_bump, trade_gate_penalty, gap_risk_penalty, set \"final\".  10) confidence_note: e.g., \"(TA strong; S1AD A+ ready; OAS 74; 78% bull prob ALERT)\".  Volatility / event / catalyst / alignment (justify each in extras.justification)  - vol_bias: high if HV5\u226540 or BBW%\u22656 or VolRatio\u22652; low if HV5<20 & VolRatio<1; else med.  - event_window: true if:   * Any meaningful \u22645d news item OR   * forward_event_window=true OR   * forward.opex.inWindow5d=true (OPEX within 5 days) OR   * forward.earnings dates indicate active window   Otherwise false.  - catalyst_type:   * If forward.earnings.estimateDate exists and within 10d \u2192 \"earnings\"   * Else dominant tag among counted news items   * Else if setup_quality.coil=\"A+\" or \"A\" and intraday_signal contains \"GO_\" \u2192 \"technical\"   * Else \"technical\" if no news  - agreement: \"agree\" if TA & News same nonzero sign; \"disagree\" if opposite; else \"mixed\".  Price alignment - Compare direction_bias vs DayChange sign: same = \"with\", opposite = \"against\", else \"unclear\".  Red flags & Green flags (enhanced with v4.1 + S1AD + Trade Gate)  **Red flags** (add if applicable): - Insider selling cluster (\u22652 sells in 5d) - High vol + disagree alignment - Overbought/oversold regime caps applied - OPEX within 5d + disagree - Large gap (|\u0394%|\u22655%) against direction - **NEW**: \"Coil quality C or worse\" (if setup_quality.coil = 'C') - **NEW**: \"Low probability setup\" (if bull/bear probability < 30%) - **NEW**: \"Conflicting v4.1 signal\" (if bull_prob high but direction_bias=-1, or vice versa) - **NEW**: \"Stage-1 FAIL\" (if stage1_quality.grade = 'FAIL') - **NEW**: \"Not options-worthy\" (if trade_gate.buy_options = false) - **NEW**: \"High gap risk\" (if gap_risk.acceptable = false OR gap_risk.maxDownGap > 3%) - **NEW**: \"Poor option score\" (if trade_gate.option_worthiness_score < 50)  **Green flags** (add if applicable): - TA strong + News agree - Fresh <24h aligned - Forward event window active + aligned - Expected move supports direction - **NEW**: \"A+ coil at READY\" (if setup_quality.coil='A+' and coil_readiness='READY') - **NEW**: \"Progressive volume\" (if volume_type='Progressive' or 'Building') - **NEW**: \"GO signal intraday\" (if intraday_signal='GO_BULL' or 'GO_BEAR' aligned) - **NEW**: \"High probability >75%\" (if aligned probability \u2265 75%) - **NEW**: \"ALERT urgency\" (if urgency='ALERT' and aligned) - **NEW**: \"Top rank\" (if bull_rank \u2264 5 or bear_rank \u2264 3) - **NEW**: \"Stage-1 A+ ready\" (if stage1_quality.score \u2265 75 AND stage1_quality.ready=true) - **NEW**: \"Options-worthy\" (if trade_gate.buy_options=true AND trade_gate.option_worthiness_score \u2265 70) - **NEW**: \"Low gap risk\" (if gap_risk.acceptable=true AND gap_risk.maxDownGap < 2%)  Execution hints (fill extras with brief numeric justifications)  - structure_hint (direction \u00d7 vol \u00d7 trade_gate):   * If trade_gate.buy_options=false: \"cash\" (not suitable for options)   * If trade_gate.structure exists: use trade_gate.structure (scanner recommended)   * Else fall back to:     Long (grade \u2265 +1.0): low vol\u2192call_debit; high vol\u2192bull_put; else call_debit.     Short (grade \u2264 \u22121.0): low vol\u2192put_debit; high vol\u2192bear_call; else put_debit.     Neutral (< |0.5|): high vol\u2192iron_condor; else cash.  - timeframe:   * If bull/bear_timeframe available: use \"swing_5_10\" if timeframe mentions \"0-2d\" or \"2-3d\"; else \"position_20_30\"   * Else: swing_5_10 if |grade| \u2264 1.0; else position_20_30.  - urgency:   * If v4.1 urgency = \"ALERT\" and aligned \u2192 \"okay_now\"   * If v4.1 urgency = \"WATCH\" and aligned \u2192 check price vs levels, then \"okay_now\" or \"wait_pullback\"   * Long: okay_now if near EMA21h/WEEK.BB.mid \u00b10.25*ATR; breakout_only if Donchian20 not cleared; else wait_pullback.   * Short: mirror logic; if unclear \u2192 no_trade.  - levels:   * If trade_gate.levels exist AND trade_gate.buy_options=true: use trade_gate.levels (scanner recommended)   * Else fall back to:     entry_zone: EMA21h or WEEK.BB.mid \u00b10.25*ATR (cite numbers).     invalidation: \u00b11.0*ATR beyond entry or weekly EMA13 breach (cite number).     target_1/2: \u00b11.0*ATR and \u00b12.0*ATR or BB upper/lower (cite numbers).   (If metrics missing, leave blank and justify as \"missing\")  Bullets (\u22656; ~50/50 TA vs News/Forward)  - TA bullets: WEEK trend/momentum/vol levels with numbers (per: local TA, ASOF_DATE). - NEWS bullets: \u22647d only, each with tag & publisher/date; ignore low-signal items. - Always include an expected-move lens:   \"Expected move: \u00b1X 1d / \u00b1Y 1w (HV5); \u00b1A 1d / \u00b1B 1w (HV20) (per: local TA, ASOF_DATE)\". - Include 1\u20132 forward bullets when available (e.g., \"Earnings 2025-10-31, window 10-26 to 11-05 (per: forward data)\", \"OPEX 2025-10-18, 4 days away (per: forward data)\"). - **NEW**: Include 1-2 v4.1 setup bullets when relevant:   * \"Stage-1: score 78/100 (Grade A), squeeze 2.1%, volume drying 0.52 (per: v4.1 scanner, ASOF_DATE)\"   * \"Options: OAS 74/100, worthy for call_debit 7d, trigger $179.20 (per: v4.1 scanner, ASOF_DATE)\"   * \"Coil A+ at READY, Progressive volume, GO_BULL intraday, 78% bull prob (ALERT) (per: v4.1 scanner, ASOF_DATE)\"  Validation (must hold) - direction_bias = sign(direction_grade). - direction_score sign matches direction_bias unless direction_grade=0. - confidence \u2208 [0.15, 0.95] and rounded to 0.05. - sources_count is a non-negative integer. - If no \u22647d news, state that in bullets and set NEWS_axis=0 (mixed).  extras.v41_context (populate when available) Fill this object with v4.1 scanner outputs for transparency: - coil_quality: from setup_quality.coil - coil_readiness: from setup_quality.coil_readiness - volume_type: from setup_quality.volume_type - intraday_signal: from setup_quality.intraday_signal - bull_probability: from probability.bull - bear_probability: from probability.bear - bull_urgency: from probability.bull_urgency - bull_rank: from ranking.ordinal.bullRank - **NEW**: stage1_score: from stage1_quality.score - **NEW**: stage1_grade: from stage1_quality.grade - **NEW**: stage1_ready: from stage1_quality.ready - **NEW**: option_worthiness: from trade_gate.option_worthiness_score - **NEW**: buy_options: from trade_gate.buy_options - **NEW**: gap_risk_ok: from gap_risk.acceptable  (Optional helper for mapping W \u2192 0.5-grade) function directionGradeFromW(W){   const a = Math.abs(W);   let g = 0;   if (a >= 8) g = 2.0;   else if (a >= 6) g = 1.5;   else if (a >= 4) g = 1.0;   else if (a >= 2) g = 0.5;   else g = 0.0;   return Math.sign(W) * g; }"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        896,
        160
      ],
      "id": "48c0a89f-82c5-4938-9b74-35325b08e7ff",
      "name": "Directional Analyst"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Normalize LLM signal JSON (in `text`) to a stable { text, signal } object.\n * - Preserve LLM confidence; snap to anchors {0.20, 0.35, 0.55, 0.70, 0.85}.\n * - Fallback confidence = 0.35 (not 0.20).\n * - Merge bullet arrays from [bullets, analysis, key_insights, analysis_bullets].\n * - NEW: accept direction_grade/score; snap grade to 0.5 steps in [-2..2].\n * - NEW: coerce enums (vol_bias/agreement/price_alignment/catalyst_type).\n * - Pass through sources_count/asof_date when present.\n */\n\nconst anchors = [0.20, 0.35, 0.55, 0.70, 0.85];\nconst clamp01 = (x) => Math.max(0, Math.min(1, x));\nconst snapAnchor = (x) => {\n  const v = clamp01(Number(x));\n  if (!Number.isFinite(v)) return null;\n  return anchors.reduce((best, a) =>\n    Math.abs(a - v) < Math.abs(best - v) ? a : best,\n  anchors[0]);\n};\n\n// snap direction_grade to 0.5 increments within [-2..2]\nconst snapGrade = (g) => {\n  const v = Number(g);\n  if (!Number.isFinite(v)) return null;\n  const clipped = Math.max(-2, Math.min(2, v));\n  return Math.round(clipped / 0.5) * 0.5;\n};\n\n// try-to-JSON helper\nconst safeParse = (s) => {\n  try { return JSON.parse(s); } catch { return null; }\n};\n\n// unify bullet-like arrays\nconst unifyBullets = (o = {}) => {\n  const pools = [o.bullets, o.analysis, o.key_insights, o.analysis_bullets];\n  const out = [];\n  for (const arr of pools) {\n    if (Array.isArray(arr)) {\n      for (const line of arr) if (line != null) out.push(String(line));\n    }\n  }\n  return out;\n};\n\n// enum coercers\nconst coerceVol = (s) => {\n  const x = String(s || '').toLowerCase();\n  if (x === 'low') return 'low';\n  if (x === 'high') return 'high';\n  if (x === 'medium' || x === 'med' || x === 'mid') return 'med';\n  return 'med';\n};\nconst coerceAgree = (s) => {\n  const x = String(s || '').toLowerCase();\n  if (x.startsWith('ag')) return 'agree';\n  if (x.startsWith('dis')) return 'disagree';\n  return 'mixed';\n};\nconst coerceAlign = (s) => {\n  const x = String(s || '').toLowerCase();\n  if (x.startsWith('with')) return 'with';\n  if (x.startsWith('against')) return 'against';\n  return 'unclear';\n};\nconst coerceCatalyst = (s) => {\n  const x = String(s || '').toLowerCase();\n  if (x === 'earnings') return 'earnings';\n  if (x === 'product') return 'product';\n  if (x === 'm&a' || x === 'm& a' || x === 'ma') return 'M&A';\n  if (x === 'guidance' || x === 'outlook') return 'guidance';\n  if (x === 'activist') return 'activist';\n  if (x === 'scandal') return 'scandal';\n  if (x === 'regulatory' || x === 'reg') return 'regulatory';\n  if (x === 'technical') return 'technical';\n  return 'other';\n};\n\nconst items = $input.all();\nconst out = [];\n\nfor (const it of items) {\n  const rawText = it.json?.text ?? it.text ?? \"\";\n  const parsed = typeof rawText === \"string\" ? safeParse(rawText) : null;\n\n  const signal = {\n    symbol: null,\n    bullets: [],\n    direction_bias: 0,         // -1/0/1\n    direction_grade: null,     // -2..2 in 0.5 steps (optional)\n    direction_score: null,     // -10..10 (optional)\n    vol_bias: \"med\",\n    confidence: 0.35,          // fallback when missing\n    event_window: false,\n    catalyst_type: \"other\",\n    agreement: \"mixed\",\n    price_alignment: \"unclear\",\n    red_flags: [],\n    evidence_count: 0,\n    news_age_days: null,\n    sources_count: null,\n    asof_date: null\n  };\n\n  if (!parsed) {\n    out.push({ json: { text: rawText, signal, parse_error: true } });\n    continue;\n  }\n\n  // symbol\n  const sym = (parsed.symbol ?? it.json?.symbol ?? it.json?.inputSymbol ?? \"\")\n    .toString().trim().toUpperCase();\n  if (sym) signal.symbol = sym;\n\n  // direction fields\n  if (parsed.direction_bias != null) {\n    const db = Number(parsed.direction_bias);\n    signal.direction_bias = Number.isFinite(db) ? (db > 0 ? 1 : db < 0 ? -1 : 0) : 0;\n  }\n  if (parsed.direction_grade != null) {\n    const dg = snapGrade(parsed.direction_grade);\n    if (dg != null) {\n      signal.direction_grade = dg;\n      // if bias missing or zero, infer from grade sign\n      if (parsed.direction_bias == null) signal.direction_bias = dg > 0 ? 1 : dg < 0 ? -1 : 0;\n    }\n  }\n  if (parsed.direction_score != null && Number.isFinite(Number(parsed.direction_score))) {\n    signal.direction_score = Number(parsed.direction_score);\n  }\n\n  // vol / agreement / alignment / catalyst\n  signal.vol_bias = coerceVol(parsed.vol_bias);\n  signal.agreement = coerceAgree(parsed.agreement);\n  signal.price_alignment = coerceAlign(parsed.price_alignment);\n  signal.catalyst_type = coerceCatalyst(parsed.catalyst_type);\n\n  // event window\n  const evWin = parsed.catalyst_window ?? parsed.event_window ?? false;\n  signal.event_window = Boolean(evWin);\n\n  // lists & counts\n  if (Array.isArray(parsed.red_flags)) signal.red_flags = parsed.red_flags.map(String);\n  const bullets = unifyBullets(parsed);\n  if (bullets.length) signal.bullets = bullets;\n\n  signal.evidence_count = Number.isFinite(parsed.evidence_count)\n    ? Number(parsed.evidence_count)\n    : signal.bullets.length;\n\n  if (Number.isFinite(parsed.news_age_days)) signal.news_age_days = Number(parsed.news_age_days);\n  if (Number.isFinite(parsed.sources_count)) signal.sources_count = Number(parsed.sources_count);\n  if (parsed.asof_date) signal.asof_date = String(parsed.asof_date);\n\n  // CONFIDENCE: preserve if present, snap to anchors; else fallback 0.35\n  let finalConf = null;\n  if (parsed.confidence != null) {\n    finalConf = snapAnchor(parsed.confidence);\n  }\n  // Optional nudge if we have an event window and non-mixed agreement\n  if (finalConf == null && signal.event_window && signal.agreement !== \"mixed\") {\n    finalConf = 0.55;\n  }\n  signal.confidence = finalConf ?? 0.35;\n\n  out.push({ json: { text: rawText, signal, parse_error: false } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        464
      ],
      "id": "d5178f1f-5bec-4bdf-81a9-19a146196a8d",
      "name": "Grok parsing"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        4672,
        32
      ],
      "id": "bb49da76-064f-4afe-8f4d-96aecc181aac",
      "name": "Calculator"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Agent Output Guard v1.1 \u2014 snap enums/anchors, fix levels, enforce invariants (upside-friendly)\n * Place after the Agent, before Signal Board. Accepts either raw agent JSON (top-level)\n * or { text:\"...json...\" } / { output:\"...json...\" } / { message:\"...json...\" } and returns a single\n * normalized JSON object per item.  I/O shape unchanged.\n */\n\nconst anchors = [0.20, 0.35, 0.55, 0.70, 0.85, 0.95]; // added 0.95 for high conviction\nconst clamp01 = x => Math.max(0, Math.min(1, x));\n\nconst snapAnchor = x => {\n  const v = Number(x);\n  if (!Number.isFinite(v)) return null;\n  let best = anchors[0], dmin = Math.abs(v - anchors[0]);\n  for (const a of anchors) {\n    const d = Math.abs(v - a);\n    if (d < dmin) { dmin = d; best = a; }\n  }\n  return best;\n};\n\nconst safeParse = s => { try { return JSON.parse(String(s)); } catch { return null; } };\n\nconst coerceVol = s => {\n  const x = String(s||'').toLowerCase().trim();\n  if (/^low/.test(x)) return 'low';\n  if (/^(hi|high|very high|vhi)/.test(x)) return 'high';\n  return 'med';\n};\nconst coerceAgree = s => {\n  const x = String(s||'').toLowerCase();\n  if (x.startsWith('ag')) return 'agree';\n  if (x.startsWith('dis')) return 'disagree';\n  return 'mixed';\n};\nconst coerceAlign = s => {\n  const x = String(s||'').toLowerCase();\n  if (x.startsWith('with')) return 'with';\n  if (x.startsWith('against')) return 'against';\n  return 'unclear';\n};\nconst coerceCatalyst = s => {\n  const x = String(s||'').toLowerCase().trim();\n  if (/^earn/.test(x)) return 'earnings';\n  if (/^product/.test(x)) return 'product';\n  if (/^m&?a$/.test(x)) return 'M&A';\n  if (/^(guidance|outlook)$/.test(x)) return 'guidance';\n  if (/^activist$/.test(x)) return 'activist';\n  if (/^scandal$/.test(x)) return 'scandal';\n  if (/^(regulatory|sec)$/.test(x)) return 'regulatory';\n  if (/^technical$/.test(x)) return 'technical';\n  if (/^buyback$/.test(x)) return 'buyback';\n  if (/^div(idend)?$/.test(x)) return 'dividend';\n  if (/^(partnership|collab(oration)?)$/.test(x)) return 'partnership';\n  if (/^bankrupt/.test(x)) return 'bankruptcy';\n  if (/^split$/.test(x)) return 'split';\n  if (/^(short[\\s_]?squeeze|gamma)$/.test(x)) return 'short_squeeze';\n  if (/^macro$/.test(x)) return 'macro';\n  return 'other';\n};\n\nfunction toNum(x){\n  if (x === null || x === undefined) return null;\n  if (typeof x === 'number') return Number.isFinite(x) ? x : null;\n  let s = String(x).trim();\n  if (!s) return null;\n  s = s.replace(/[,]/g,'').replace(/%$/,''); // \"1,234.5%\" -> \"1234.5\"\n  const n = Number(s);\n  return Number.isFinite(n) ? n : null;\n}\nfunction toInt(x){ const n = toNum(x); return n==null ? null : parseInt(n,10); }\nfunction asDateYMD(s){ if(!s) return null; const d = new Date(s); return Number.isFinite(d.getTime()) ? d.toISOString().slice(0,10) : null; }\n\nfunction parseEntryZone(z){\n  if (Array.isArray(z) && z.length>=2) {\n    const a = toNum(z[0]), b = toNum(z[1]); return (a!=null && b!=null) ? [a,b] : null;\n  }\n  if (typeof z === 'string') {\n    const cleaned = z.replace(/[\u2013\u2014]/g,'-');\n    const parts = cleaned.split('-').map(s=>toNum(s.trim()));\n    if (parts.length>=2 && parts[0]!=null && parts[1]!=null) return [parts[0], parts[1]];\n  }\n  return null;\n}\n\nfunction coerceBool(x){\n  if (typeof x === 'boolean') return x;\n  const s = String(x||'').toLowerCase().trim();\n  if (!s) return false;\n  if (['y','yes','true','1','t'].includes(s)) return true;\n  if (['n','no','false','0','f'].includes(s)) return false;\n  return Boolean(x);\n}\n\nconst items = $input.all();\nconst out = [];\n\nfor (const it of items) {\n  // accept either a direct object or a JSON string under common fields\n  let o = it.json;\n  if (typeof o?.text === 'string') {\n    const parsed = safeParse(o.text); if (parsed) o = parsed;\n  } else if (typeof o?.output === 'string') {\n    const parsed = safeParse(o.output); if (parsed) o = parsed;\n  } else if (typeof o?.message === 'string') {\n    const parsed = safeParse(o.message); if (parsed) o = parsed;\n  }\n\n  if (!o || typeof o !== 'object') { out.push({ json: it.json }); continue; }\n\n  // \u2500\u2500 enums & fields \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  o.symbol = String(o.symbol||'').toUpperCase() || o.symbol;\n  o.vol_bias = coerceVol(o.vol_bias);\n  o.agreement = coerceAgree(o.agreement);\n  o.price_alignment = coerceAlign(o.price_alignment);\n  o.catalyst_type = coerceCatalyst(o.catalyst_type);\n  if (typeof o.event_window !== 'boolean') o.event_window = coerceBool(o.event_window);\n\n  // direction invariants\n  const dg = toNum(o.direction_grade);\n  const ds = toNum(o.direction_score);\n  if (dg != null) o.direction_grade = Math.max(-2, Math.min(2, Math.round(dg/0.5)*0.5));\n  // infer bias from grade/score when missing or 0\n  if ((o.direction_bias==null || o.direction_bias===0)) {\n    if (dg != null && dg !== 0) o.direction_bias = dg > 0 ? 1 : -1;\n    else if (ds != null && ds !== 0) o.direction_bias = ds > 0 ? 1 : -1;\n    else o.direction_bias = 0;\n  }\n  // snap any non-integer bias to -1/0/1\n  if (typeof o.direction_bias === 'number') {\n    o.direction_bias = o.direction_bias > 0 ? 1 : (o.direction_bias < 0 ? -1 : 0);\n  }\n\n  // confidence snap (+ keep breakdown in sync if present)\n  if (o.confidence != null) {\n    const snapped = snapAnchor(o.confidence);\n    if (snapped != null) o.confidence = snapped;\n  } else {\n    o.confidence = 0.55; // default reflects upside tilt (still snapped later if breakdown exists)\n  }\n\n  const cb = o.extras?.confidence_breakdown;\n  if (cb && typeof cb === 'object') {\n    const base = toNum(cb.base) ?? o.confidence ?? 0.55;\n    const bumps = [\n      toNum(cb.alignment_bump)||0,\n      toNum(cb.forward_bump)||0,\n      toNum(cb.fresh_bump)||0,\n      toNum(cb.vol_penalty)||0,\n      toNum(cb.opex_penalty)||0\n    ];\n    let final = base + bumps.reduce((a,b)=>a+b,0);\n    final = snapAnchor(final) ?? o.confidence;\n    cb.final = final;\n    o.confidence = final; // keep top-level aligned\n  }\n\n  // levels: coerce to numeric; entry_zone as [lo, hi]\n  if (o.extras?.levels) {\n    const L = o.extras.levels;\n    const ez = parseEntryZone(L.entry_zone); if (ez) L.entry_zone = ez;\n    const inv = toNum(L.invalidation); if (inv!=null) L.invalidation = inv;\n    const t1  = toNum(L.target_1);    if (t1!=null)  L.target_1 = t1;\n    const t2  = toNum(L.target_2);    if (t2!=null)  L.target_2 = t2;\n  }\n\n  // urgency sanity (short): if entry_zone entirely above first target, wait for pullback\n  if (o.extras?.urgency && o.direction_bias === -1 && Array.isArray(o.extras.levels?.entry_zone)) {\n    const ez = o.extras.levels.entry_zone, t1 = toNum(o.extras.levels?.target_1);\n    if (t1!=null && Math.min(...ez) > t1) o.extras.urgency = 'wait_pullback';\n  }\n  // urgency sanity (long): if entry_zone entirely below invalidation, wait for confirmation\n  if (o.extras?.urgency && o.direction_bias === 1 && Array.isArray(o.extras.levels?.entry_zone)) {\n    const ez = o.extras.levels.entry_zone, inv = toNum(o.extras.levels?.invalidation);\n    if (inv!=null && Math.max(...ez) < inv) o.extras.urgency = 'wait_confirmation';\n  }\n\n  // counts/dates\n  if (o.sources_count != null) o.sources_count = toInt(o.sources_count) ?? 0;\n  if (o.asof_date) o.asof_date = asDateYMD(o.asof_date) ?? o.asof_date;\n\n  out.push({ json: o });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3376,
        -176
      ],
      "id": "b0c76cc8-38fe-4920-a5e9-00e768df8ee6",
      "name": "Agent Packet",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": "grok-4-1-fast-reasoning",
        "options": {
          "timeout": 700000,
          "maxRetries": 2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        4560,
        32
      ],
      "id": "e380ffdc-0b48-4fa0-a6a0-cef0dd587894",
      "name": "Grok 4",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2944,
        480
      ],
      "id": "773bfd7c-fc86-42e6-ab00-e45cfb6d01b6",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// NEWS + TA PASS-THROUGH (lean, Grok-friendly)\n// - Accepts rich TA array from upstream analyzer OR raw Yahoo v8 chart (lite).\n// - Smarter news dedupe, macro summary + triggers, DXY auto-fallback.\n// - Token controls: LEAN caps & compact TA payload for Grok.\n//\n// RECOMMENDED: HTTP range >= 1y (for SMA200); URL uses encodeURIComponent(symbol).\n\n/* ==================== CONFIG ==================== */\nconst LEAN = true;                 // shrink output for Grok\nconst INCLUDE_DESC = false;        // keep false for tokens\nconst INCLUDE_TA_FULL = false;     // include heavy TA array; default off (use ta_compact)\n\n/* Caps (lean mode trims totals) */\nconst MAX_PER_GROUP = LEAN ? 40 : 50;\nconst MAX_TOTAL     = LEAN ? 150 : 200;\n\n/* ==================== INPUT ===================== */\nconst inputs = $input.all();\n\n/* ==================== HELPERS ==================== */\nconst J = (x)=> x?.json ?? x;\nconst hostOf = (u)=>{ try{ return new URL(u).hostname.toLowerCase().replace(/^www\\./,''); }catch{ return ''; } };\nconst toISO  = (d)=>{ try{ return new Date(d).toISOString(); }catch{ return null; } };\nconst pickLink = (o)=> o.link || o.url || o.guid || o.href || null;\nconst pickWhen = (o)=> o.publishedAt || o.published_at || o.isoDate || o.pubDate || o.published || o.date || o.updated || o.updated_at || o.latest_published_at || null;\nconst pickDesc = (o)=> o.description || o.summary || o.contentSnippet || o.content || null;\nconst cut = (s,n)=> (s && s.length>n) ? s.slice(0,n-1)+'\u2026' : s;\n\n/* Smarter dedupe: title | host | normalized path (trim numeric tails like -4237764) */\nfunction canonicalKey(title, link){\n  try{\n    const u = new URL(link || '');\n    const host = u.hostname.toLowerCase().replace(/^www\\./,'');\n    const path = u.pathname.toLowerCase().replace(/-\\d+(?:\\.\\w+)?$/, '');\n    const t = String(title||'').toLowerCase().replace(/\\s+/g,' ').trim();\n    return `${t}|${host}|${path}`;\n  }catch{\n    return String(title||'').toLowerCase().trim();\n  }\n}\n\n/* Group detection */\nfunction detectGroup(raw, link){\n  const t = (raw.feed || raw.group || raw.source_group || raw.channel || raw.channelTitle || raw?.channel?.title || raw?.meta?.feed || '').toString().toLowerCase();\n  const h = hostOf(link);\n  const title = (raw.title || '').toLowerCase();\n\n  if (t.includes('federal reserve') || t.includes('federalreserve') || t.includes('fed ') || t === 'fed' ||\n      h.includes('federalreserve.gov') || h.includes('.frb.') ||\n      title.includes('powell') || title.includes('fomc') || title.includes('federal reserve')) return 'fed';\n\n  if (t.includes('cnbc') || h.includes('cnbc.com')) return 'cnbc';\n  if (t.includes('bloomberg') || h.includes('bloomberg.com')) return 'bloomberg';\n  if (t.includes('reuters') || h.includes('reuters.com')) return 'reuters';\n  if (t.includes('wsj') || h.includes('wsj.com')) return 'wsj';\n  if (t.includes('ft') || h.includes('ft.com')) return 'ft';\n  if (t.includes('investing') || h.includes('investing.com')) return 'investing';\n  return 'market';\n}\n\n/* Flatten news-like inputs */\nfunction collectArticlesFrom(d){\n  const out = [];\n  if (d?.type === 'news_batch' && Array.isArray(d.articles)) { for (const a of d.articles) out.push(J(a)); return out; }\n  if (Array.isArray(d?.articles)) { for (const a of d.articles) out.push(J(a)); return out; }\n  if (Array.isArray(d?.items)) { for (const a of d.items) out.push(J(a)); return out; }\n  if (Array.isArray(d)) { for (const a of d) out.push(J(a)); return out; }\n  if (d?.title && (pickLink(d) || pickDesc(d))) out.push(d);\n  return out;\n}\n\n/* Identify rich TA object */\nfunction isTaRich(obj){\n  return !!(obj && obj.symbol && obj.analysis && (obj.movingAverages || obj.technicals));\n}\n\n/* Make a compact TA view (token-friendly) */\nfunction compactTa(arr){\n  if (!Array.isArray(arr)) return [];\n  return arr.map(o => ({\n    s: o.symbol,\n    i: o.index,\n    d: o.date,\n    p: o.currentPrice,\n    a: { // analysis (condensed)\n      t: o.analysis?.overallTrend,\n      st: o.analysis?.shortTerm,\n      lt: o.analysis?.longTerm,\n      s: o.analysis?.signal,\n      dv200: o.analysis?.priceVsRefMA\n    },\n    x: { // key technicals\n      p20: o.technicals?.priceAboveSMA20,\n      p50: o.technicals?.priceAboveSMA50,\n      p200:o.technicals?.priceAboveSMA200,\n      a20_50: o.technicals?.sma20AboveSMA50,\n      a50_200:o.technicals?.sma50AboveSMA200\n    },\n    o: { // options-light\n      hv20: o.optionsMetrics?.hv20_pct,\n      atrP: o.optionsMetrics?.atrPct,\n      em1d: o.optionsMetrics?.expectedMove_1d_pct\n    }\n  }));\n}\n\n/* ==================== INGEST ===================== */\nconst taRich = [];\nconst taLite = [];\nconst rawNews = [];\n\nfor (const it of inputs) {\n  const d = J(it);\n\n  // Array of TA objects bundled\n  if (Array.isArray(d) && d.length && isTaRich(J(d[0]))) {\n    for (const el of d) { const t = J(el); if (isTaRich(t)) taRich.push(t); }\n    continue;\n  }\n\n  // Single TA object\n  if (isTaRich(d)) { taRich.push(d); continue; }\n\n  // Raw Yahoo v8 chart -> tiny TA lite\n  if (d?.chart?.result?.[0]?.indicators?.quote?.[0]?.close) {\n    const res = d.chart.result[0], closes = res.indicators.quote[0].close;\n    if (closes?.length >= 2) {\n      const cur = closes.at(-1), prev = closes.at(-2);\n      const sym = res.meta?.symbol ?? 'UNKNOWN';\n      const map = { '^GSPC':'S&P 500', '^DJI':'Dow Jones', '^RUT':'Russell 2000' };\n      taLite.push({\n        type:'technical_analysis_lite',\n        index: map[sym] || res.meta?.shortName || sym,\n        symbol: sym,\n        date: res.timestamp ? new Date(res.timestamp.at(-1)*1000).toISOString().slice(0,10) : null,\n        currentPrice: +Number(cur).toFixed(2),\n        dailyChange: +(((cur - prev) / prev) * 100).toFixed(2),\n        analysis:{}\n      });\n    }\n    continue;\n  }\n\n  // Else: treat as news batch\n  const picked = collectArticlesFrom(d);\n  if (picked.length) rawNews.push(...picked);\n}\n\n/* ============ NEWS: normalize, dedupe, cap ============ */\nconst groups = { fed:[], cnbc:[], bloomberg:[], reuters:[], wsj:[], ft:[], investing:[], market:[] };\nconst seen = new Set();\nlet totalArticles = 0;\n\nfor (const a of rawNews) {\n  if (totalArticles >= MAX_TOTAL) break;\n\n  const title = String(a.title || '').trim();\n  if (!title) continue;\n\n  const link = pickLink(a);\n  const src  = a.source?.name || a.source || hostOf(link) || 'unknown';\n  const iso  = toISO(pickWhen(a));\n  const grp  = detectGroup(a, link);\n\n  const key = canonicalKey(title, link);\n  if (seen.has(key)) continue;\n  seen.add(key);\n\n  const row = { title: LEAN ? cut(title, 140) : title, link, source: src, publishedAt: iso };\n  if (INCLUDE_DESC) row.description = cut(pickDesc(a) || '', 200);\n\n  if (!groups[grp]) groups[grp] = [];\n  groups[grp].push(row);\n  totalArticles++;\n}\n\nfunction finalize(list, maxItems){\n  list.sort((a,b)=>{\n    const ta = a.publishedAt ? new Date(a.publishedAt).getTime() : 0;\n    const tb = b.publishedAt ? new Date(b.publishedAt).getTime() : 0;\n    if (tb !== ta) return tb - ta;\n    return String(a.title).localeCompare(String(b.title));\n  });\n  return list.slice(0, maxItems);\n}\n\nconst outGroups = {\n  fed:       finalize(groups.fed, 30),\n  cnbc:      finalize(groups.cnbc, MAX_PER_GROUP),\n  bloomberg: finalize(groups.bloomberg, MAX_PER_GROUP),\n  reuters:   finalize(groups.reuters, MAX_PER_GROUP),\n  wsj:       finalize(groups.wsj, 25),\n  ft:        finalize(groups.ft, 25),\n  investing: finalize(groups.investing, MAX_PER_GROUP),\n  market:    finalize(groups.market, MAX_PER_GROUP),\n};\nObject.keys(outGroups).forEach(k=>{ if (!outGroups[k].length) delete outGroups[k]; });\nconst totals = Object.fromEntries(Object.entries(outGroups).map(([k,v])=>[k,v.length]));\n\n/* ==================== TA + MACRO ==================== */\nconst taAll = taRich.length ? taRich : taLite;\nconst taBySym = new Map(taAll.map(o => [o.symbol, o]));\n\n/* Compatibility gauges (prefer rich) */\nconst sp500   = taBySym.get('^GSPC') || null;\nconst dow     = taBySym.get('^DJI')  || null;\nconst russell = taBySym.get('^RUT')  || null;\n\n/* Cross-asset */\nlet dxy = taBySym.get('DX-Y.NYB') || taBySym.get('DX=F') || taBySym.get('UUP') || null;\nif (dxy?.meta?.warnings?.includes('DXY_series_mismatch_consider_DX=F_or_UUP') && taBySym.get('DX=F')) {\n  dxy = taBySym.get('DX=F');\n}\nconst vix = taBySym.get('^VIX') || null;\nconst gold = taBySym.get('GC=F') || taBySym.get('GLD') || null;\nconst btc = taBySym.get('BTC-USD') || null;\nconst tnx = taBySym.get('^TNX') || null;\nconst tip = taBySym.get('TIP') || null;\n\n/* Helpers on rich TA; auto-false for lite */\nconst isBull = (d)=> d?.technicals?.priceAboveSMA50 && d?.technicals?.sma50AboveSMA200;\nconst isBear = (d)=> d?.technicals?.priceAboveSMA50===false && d?.technicals?.sma50AboveSMA200===false;\nconst stretch10 = (d)=> typeof d?.analysis?.priceVsRefMA==='number' && d.analysis.priceVsRefMA>10;\n\nfunction mkTriggers({sp500,dow,russell,vix,dxy}){\n  const equities_all_bullish = [sp500,dow,russell].every(isBull);\n  const vix_risk_on = vix && isBear(vix) && (vix.currentPrice==null || vix.currentPrice < 16);\n  const dollar_headwind = dxy && isBull(dxy);\n  const stretched_200d = [sp500, gold].some(stretch10);\n  return { equities_all_bullish, vix_risk_on, dollar_headwind, stretched_200d };\n}\n\nfunction makeMacro(){\n  const eq = [sp500,dow,russell].filter(Boolean);\n  if (!eq.length) return null;\n\n  let score = 0, notes = [];\n  if (eq.length===3 && eq.every(isBull)) { score += 30; notes.push('Equities bullish stack'); }\n  if (vix && isBear(vix))                { score += 20; notes.push('VIX suppressed'); }\n  if (dxy && isBear(dxy))                { score += 10; notes.push('Dollar trending down'); }\n  if (tnx && isBear(tnx))                { score += 10; notes.push('Yields trending down'); }\n  if (gold && isBull(gold))              { score += 5;  notes.push('Gold firm'); }\n  if (btc && isBull(btc))                { score += 5;  notes.push('BTC firm'); }\n\n  const stretched = [sp500,dow,russell,gold].filter(stretch10).map(x=>x.symbol);\n  if (stretched.length) notes.push(`Stretched vs 200d: ${stretched.join(', ')}`);\n\n  const regime = score>=60 ? 'Risk-On'\n               : score>=35 ? 'Mixed-Positive'\n               : score<=10 ? 'Risk-Off'\n               : 'Mixed';\n\n  return {\n    regime, score, notes,\n    triggers: mkTriggers({sp500,dow,russell,vix,dxy}),\n    gauges: {\n      sp500:   sp500?.analysis || sp500,\n      dow:     dow?.analysis   || dow,\n      russell: russell?.analysis || russell,\n      vix:     vix?.analysis   || vix,\n      dxy:     dxy?.analysis   || dxy,\n      gold:    gold?.analysis  || gold,\n      btc:     btc?.analysis   || btc,\n      tnx:     tnx?.analysis   || tnx,\n      tip:     tip?.analysis   || tip\n    }\n  };\n}\n\nconst macro = makeMacro();\nconst ta_compact = compactTa(taRich.length ? taRich : []);\n\n/* ==================== OUTPUT ==================== */\nconsole.log(`TA rich: ${taRich.length}, TA lite: ${taLite.length}`);\nconsole.log(`News Distribution: ${Object.entries(totals).map(([k,v])=>`${k}:${v}`).join(' ')}`);\n\nreturn [{\n  json: {\n    schema_version: \"1.3.1\",\n    news: {\n      type: 'news_groups',\n      groups: outGroups,\n      totals,\n      meta: {\n        maxPerGroup: MAX_PER_GROUP,\n        totalArticles: totalArticles,\n        uniqueSources: (function(){ // unique by canonical key\n          return Object.values(outGroups).flat().length;\n        })()\n      }\n    },\n    // Compatibility keys\n    sp500: sp500 || null,\n    dow:   dow   || null,\n    russell: russell || null,\n\n    // TA payloads\n    ta: INCLUDE_TA_FULL && taRich.length ? taRich : undefined, // heavy (toggle)\n    ta_compact: ta_compact.length ? ta_compact : undefined,     // Grok-friendly\n\n    // Macro\n    macro: macro || undefined,\n\n    meta: { generated_at: new Date().toISOString(), lean: LEAN }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        544
      ],
      "id": "ed6e52f0-bc5a-4bcf-a031-f81a9a00bfcb",
      "name": "macro briefing code"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=FEED v{{$json.schema_version || \"1.x\"}} | generated {{$json.meta.generated_at}}\n\nNEWS: {{$json.news.meta.totalArticles}} total | groups: {{ Object.keys($json.news.groups).join(\", \") }}\n\nFED (top 8):\n{{ ($json.news.groups.fed || []).slice(0,8).map(x => `- ${(x.publishedAt||\"\").slice(0,10)} \u2014 ${x.title}`).join(\"\\n\") }}\n\nMARKET (top 12):\n{{ ($json.news.groups.market || []).slice(0,12).map(x => `- ${(x.publishedAt||\"\").slice(0,10)} \u2014 ${x.title}`).join(\"\\n\") }}\n\nMACRO SUMMARY:\n{{ JSON.stringify({regime: ($json.macro||{}).regime, score: ($json.macro||{}).score, notes: ($json.macro||{}).notes}, null, 0) }}\n\nTRIGGERS:\n{{ JSON.stringify((($json.macro||{}).triggers)||{}, null, 0) }}\n\nGAUGES (analysis slices):\n{{ JSON.stringify((($json.macro||{}).gauges)||{}, null, 0) }}\n\nTA_COMPACT (token-light per-asset snapshot):\n{{ JSON.stringify($json.ta_compact || [], null, 0) }}\n",
        "options": {
          "systemMessage": "=## ROLE (start by thinking and using time tool\u2014then make the tool calls you need)\nYou are a **macro reporter** producing an **hourly intelligence briefing** for a **very risk-on hedge fund** that trades **options**. You are **portfolio-aware and should analyze sectors with perplexity (view trade journal before anything)** and **do not give directives**. Your job is to surface **considerations, context, and near-term watch items** so PMs and the trade executor can make informed decisions about positioning.\n\n**Date / TZ:** {{TODAY_LONG}} ({{TODAY_ISO}}), **America/New_York**. Use **absolute ET timestamps**.\n\n## INPUTS (JSON preloaded)\n- `news` \u2192 grouped headlines with `publishedAt` (today + very recent).\n- `sp500`, `dow`, `russell` \u2192 rich TA objects (may include `optionsMetrics`: HV, ATR, expected moves).\n- Optional: `macro` (regime, gauges), `ta_compact`, and other gauges (e.g., `dxy`, `gold`, `btc`, `tnx`, `tip`, credit ETFs if present).\n\n**Data gaps:** Only print a \"Data Gaps\" line if a required key is **missing today**. Do not speculate.\n\n## TOOLS (use when needed, not by default)\n- **Perplexity / web search:** Verify **today-current** event times and any debated facts. If inputs lack exact times for **major next-5-day catalysts** (e.g., FOMC, Retail Sales, VIX settlement, OPEX, key earnings), run **one quick calendar lookup** and cite a primary source. Otherwise skip.\n- **Calculator:** Use for all % math you cite (MA distances, level changes, relative performance, converting expected move % to index points).\n- If you use **no tools**, end the brief with one sentence: \"No external lookups\u2014input JSON fully covered today's context.\"\n\n## CITATIONS (required on load-bearing claims)\n- News/search: **(source_domain, YYYY-MM-DD HH:mm ET)**.\n- TA: **(TA Signal, Index)** \u2014 e.g., *(Strong Bullish, S&P 500)*.\nLimit to the **3\u20135 most important** statements.\n\n## OUTPUT \u2014 ONE BRIEF (700\u2013950 words, natural narrative; no recommendations)\n\n### WHAT MATTERS TODAY\n\u2022 **Today's session + momentum:** Lead with today's actual price action (magnitude, character, intraday path). State performance clearly (e.g., \"SPX down 0.47%, Dow off 0.52%, Russell down 0.61%\"). \n  - **Include momentum quality:** Was it grinding lower all day? Accelerating into close? Opening gap that held? Morning weakness that recovered? \n  - **Breadth & vol context:** Mention advancers/decliners ratio if available, VIX reaction (spike/fade/flat), whether selling was broad-based or sector-driven.\n  \n\u2022 **Contextualize against structure:** Frame whether today's move aligns with or contradicts the technical backdrop (e.g., \"pullback within uptrend\" or \"breakdown threatening support\" or \"breakdown confirmed below key level\").\n\n\u2022 **3\u20135 most important drivers for next 1\u20135 days** with **near-term impact**. Cite news when headline-driven; tag TA signals when chart-driven.\n\n\u2022 **If available**, include **implied range** for SPX/RUT using `optionsMetrics.expectedMove_1d_pct` and `expectedMove_5d_pct` (convert to index points via Calculator).\n\n### TECHNICAL-FUNDAMENTAL SYNTHESIS\n**Distinguish session action from structural positioning:**\n- **Today's Action:** Describe intraday character in detail\u2014broad-based or narrow, sector rotation, volatility spike, opening gap behavior, late-day reversal/acceleration, volume profile.\n  \n- **Structural Positioning:** Use `sp500`, `dow`, `russell` **analysis/movingAverages/performance** to describe trend/momentum/stretch over days/weeks. **Quote the actual 20/50/200-day values** from inputs and distances (use `analysis.priceVsRefMA` if provided). Tag signals: *(Strong Bullish, Russell 2000)* etc.\n\n- **Frame correctly:** \n  - If today's down 40+ bps but MAs are bullish: \"Pullback doesn't yet threaten bullish structure\u2014still X% above rising 50-day, but momentum has shifted near-term.\"\n  - If today's up and MAs confirm: \"Rally extends bullish setup with confirming momentum.\"\n  - If today contradicts structure (e.g., breakdown below key MA): \"Breakdown below [level] invalidates prior setup; structure now [bearish/neutral].\"\n\n**Cross-asset layering:**\n- **Convergence**: bullish MA stacks + supportive headlines + risk-on cross-assets \u2192 state plainly with conviction.\n- **Divergence**: e.g., equities down but dollar weak and bonds rallying \u2192 explain both sides clearly; note what it means for correlation assumptions and whether it signals de-risking, rotation, or false signals.\n- If `macro.gauges` exist, integrate **DXY, Gold, BTC, TNX, TIP** as cross-asset confirmations or contradictions.\n  \u2022 If `dxy.meta.warnings` indicates series mismatch, treat **DX=F/UUP** as the proxy and note the substitution.\n\n### MARKET DYNAMICS\n- **Fed pulse today**: Use top 2\u20133 **today-timestamped** Fed items (names/events) from `news.groups.fed`. If officials disagree, prepend **\"Conflict:\"** and present both quotes/views with citations.\n\n- **Size/sector tilt**: Compare Russell vs S&P/Dow **weeklyChange** and **today's relative performance** for breadth/beta read-through; note implications for **skew** and **realized/expected vol** (e.g., low VIX with stretched SPX vs elevated HV, or VIX spike with broad selling).\n\n- **Cross-asset quick reads**: Dollar trend (DXY), real rates (TNX/TIP), and risk proxy (BTC)\u2014each in one line on how they typically map to equities in the next sessions and whether today's cross-asset action confirms or contradicts equity moves.\n\n- **Credit tone (if available)**: Briefly state HYG/LQD trend vs 50/200-day and whether **spreads look supportive/neutral/widening**; note if credit is diverging from equities today (e.g., credit holding firm while equities sell = less concern; credit widening with equities down = risk-off confirmation).\n\n### NEAR-TERM DIRECTIONAL BIAS (Next 1-3 Sessions)\n**Synthesize today's action + technical setup + vol environment into execution context:**\n\n- **If today is down 40+ bps:** Assess whether this is:\n  - **Profit-taking / healthy pullback** (shallow, low vol, supportive credit, VIX calm) \u2192 dip structure may be intact for patient buyers\n  - **Momentum shift** (accelerating decline, breadth weak, late-day selling, VIX spike) \u2192 suggests waiting for stabilization before re-engaging\n  - **Breakdown / vol event** (key level lost, credit widening, vol expanding) \u2192 defensive bias until reclaim of broken level\n  \n- **Intraday character matters:** \n  - Late-day acceleration lower = worse than morning dip that stabilized\n  - VIX spike + credit widening + broad selling = de-risking in progress\n  - Shallow pullback on low volume with credit stable = likely noise\n\n- **State the implied bias clearly for next 1-3 sessions:** \n  - Examples: \n    - \"Conditions suggest waiting for stabilization signals before re-engaging long exposure\"\n    - \"Pullback looks corrective within uptrend; patient dip buyers have defined risk at [level]\"\n    - \"Breakdown in progress; downside bias persists until reclaim of [level] with expanding breadth\"\n    - \"Momentum intact; pullback shallow enough to keep bullish posture for breakout continuation\"\n\n- **Vol/skew implications:** Note whether current vol environment (HV, IV, skew) favors aggressive entries, patient structure, or defensive hedging.\n\n### KEY LEVELS & UPCOMING CATALYSTS\n- **Levels:** Provide concrete SPX/DOW/RUT **supports/resistances now** (round numbers + their **20/50/200-day**). Use Calculator for % distances. **Critically:** Note whether today's action tested, held, or broke any of these levels\u2014and what it means for next session bias.\n  \n- **Catalysts (next 1\u20135 days):** For each, list **date (ET), exact time, event, and one-line why it matters for vol/direction/positioning**. If inputs don't include times, perform the single calendar lookup and cite. Note whether catalysts argue for waiting or present opportunity.\n\n### BOTTOM LINE\nDeliver a decisive, **non-prescriptive** synthesis for the next **1\u201340 trading days**: \n\n- **Structural regime:** Use `macro.regime` if present; else infer from MA stacks + VIX/DXY. State clearly: e.g., \"Structurally bullish despite today's pullback\" or \"Mixed regime with conflicting signals\" or \"Structure deteriorating; now neutral-to-bearish.\"\n\n- **Primary near-term risks:** Identify the key risks given today's action, upcoming catalysts, and cross-asset setup.\n\n- **Explicit flip conditions:** Provide clear levels/conditions that would change the structural view (e.g., \"Setup deteriorates if Russell loses 50-day and VIX reclaims 20\" or \"Pullback becomes breakdown below 5,850 SPX with expanding vol\").\n\n- **For the trade executor:** Given today's action and structural setup, state whether near-term risk/reward and momentum characteristics **suggest**: \n  - **(a) Waiting for confirmation** (when momentum deteriorating, vol expanding, or key levels broken)\n  - **(b) Patient dip-buying with defined risk** (when pullback corrective within intact structure)\n  - **(c) Defensive positioning until clarity** (when breakdown in progress or mixed signals)\n  - **(d) Aggressive engagement on strength** (when breakout extending with confirming breadth/vol)\n  \n  Frame as **\"conditions suggest\"** not \"you should.\" Be specific about what would constitute confirmation or invalidation.\n\n## RULES & GUARDRAILS\n- **Execution context is paramount:** The trade executor needs to know if TODAY'S action argues for aggressive, patient, defensive, or wait-and-see positioning. Don't just describe conditions\u2014synthesize into a clear directional lean for the next 1-3 sessions.\n\n- **When to wait:** If down 40+ bps with accelerating momentum into close, expanding VIX, credit widening, or technical breakdown, make it crystal clear that conditions favor waiting\u2014even if medium-term structure remains \"bullish.\" **Don't analyze calls when the market is falling.**\n\n- **Session vs Structure:** Always distinguish today's price action from multi-day technical positioning. Don't call the market \"bullish\" on a down day just because MAs are aligned\u2014say \"structurally bullish but near-term momentum has shifted defensive\" or \"pullback within uptrend, but wait for stabilization.\"\n\n- **Today-only focus:** Filter headlines to **today's** timestamp; ignore stale items.\n\n- **No hallucinations:** Use provided numbers or Calculator; if unknown, say briefly.\n\n- **Russell matters:** Always compare Russell's momentum vs S&P/Dow (today AND week) and state the implication for breadth, beta, skew, and whether small-cap leadership is confirming or diverging.\n\n- **Convergence = confidence; divergence = clarity.** If cross-assets or credit diverge from equities today, say so explicitly and explain what it signals.\n\n- **Tone:** Professional, conversational, informative; **no directives** or portfolio-specific advice, but clear about what conditions suggest for risk-taking.\n\n- **Formatting:** Section headers as above; inline citations; no emojis.\n\n## FALLBACKS\n- If `macro` missing:\n  \u2022 **Risk-On** if all three indices have `priceAboveSMA50 === true` **and** `sma50AboveSMA200 === true`, with VIX **bearish** if present. Note: \"Structurally risk-on.\"\n  \u2022 **Risk-Off** if the inverse holds. Note: \"Structurally risk-off.\"\n  \u2022 Else **Mixed / Mixed-Positive**. Always clarify: \"Structure is [X], but today's momentum suggests [Y] for next 1-3 sessions.\"\n  \n- If DXY warning is present, explicitly note proxy use (**DX=F/UUP**) in the narrative.\n\n**Deliver one briefing only.** If no tools were used, append the required one-sentence explanation at the end.",
          "batching": {
            "batchSize": 1
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        3376,
        576
      ],
      "id": "1b7a0699-f13f-417f-8e8f-a4a0d1012478",
      "name": "Macro Reporter"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        3568,
        912
      ],
      "id": "4fa3ea35-14d6-467f-a1c2-c8f8a88e9ba1",
      "name": "Calculator1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "numberInputs": 3,
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4064,
        -192
      ],
      "id": "1601e60e-319c-46aa-a608-8d18906402da",
      "name": "final executor merge"
    },
    {
      "parameters": {
        "url": "https://www.cnbc.com/id/100003114/device/rss/rss.html",
        "options": {
          "customFields": "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
          "ignoreSSL": true
        }
      },
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        2576,
        512
      ],
      "id": "4b7428a3-3687-4742-b5b8-e0fdc8c073b3",
      "name": "Major news-CNBC",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "http://rss.cnn.com/rss/money_markets.rss",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0"
            },
            {
              "name": "Accept",
              "value": "application/rss+xml, application/xml;q=0.9, */*;q=0.8"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2736,
        848
      ],
      "id": "1f4b8c56-65ad-4147-a667-d7d27ac76620",
      "name": "Market News",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// n8n RSS Sanitizer - Streamlined for your data format\n// Input: {data: \"<?xml version...\"}\n// Output: cleaned XML ready for RSS parsing\n\nconst input = $input.first().json;\n\n// Extract the XML data\nconst body = String(input.data || '');\n\n// Quick validation\nif (!body || body.length < 50) {\n  return [{\n    json: {\n      ok: false,\n      reason: 'no_xml_data',\n      bodyLength: body.length,\n      snippet: body.slice(0, 100)\n    }\n  }];\n}\n\n// Sanitize XML function\nfunction sanitizeXml(str) {\n  if (typeof str !== 'string') return '';\n  \n  // Strip BOM\n  str = str.replace(/^\\uFEFF/, '');\n  \n  // Find XML start and trim anything before it\n  const xmlIndex = str.indexOf('<?xml');\n  const rssIndex = str.indexOf('<rss');\n  \n  if (xmlIndex >= 0) {\n    str = str.slice(xmlIndex);\n  } else if (rssIndex >= 0) {\n    str = str.slice(rssIndex);\n  }\n  \n  // Fix common RSS feed issues\n  // 1. Escape unescaped ampersands (but preserve valid entities)\n  str = str.replace(/&(?!(amp;|lt;|gt;|quot;|apos;|#[0-9]+;|#x[0-9a-fA-F]+;))/g, '&amp;');\n  \n  // 2. Remove invalid control characters (except tab, newline, carriage return)\n  str = str.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\n  \n  // 3. Fix any broken CDATA sections\n  str = str.replace(/<!\\[CDATA\\[([^\\]]*)\\]\\]>/g, (match, content) => {\n    return '<![CDATA[' + content.replace(/\\]\\]>/g, ']]&gt;') + ']]>';\n  });\n  \n  return str.trim();\n}\n\n// Process the XML\nconst cleanXml = sanitizeXml(body);\n\n// Final validation\nif (!cleanXml || cleanXml.length < 50) {\n  return [{\n    json: {\n      ok: false,\n      reason: 'sanitization_failed',\n      originalLength: body.length,\n      cleanedLength: cleanXml.length,\n      snippet: body.slice(0, 200)\n    }\n  }];\n}\n\n// Verify it's actually RSS/XML\nif (!cleanXml.includes('<rss') && !cleanXml.includes('<feed') && !cleanXml.includes('<?xml')) {\n  return [{\n    json: {\n      ok: false,\n      reason: 'not_valid_rss',\n      snippet: cleanXml.slice(0, 200)\n    }\n  }];\n}\n\n// Success - return the cleaned XML\nreturn [{\n  json: {\n    ok: true,\n    xml: cleanXml,\n    originalSize: body.length,\n    cleanedSize: cleanXml.length,\n    itemCount: (cleanXml.match(/<item>/g) || []).length + (cleanXml.match(/<entry>/g) || []).length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        784
      ],
      "id": "1b94b260-097d-4028-b42e-0af140ba7b27",
      "name": "Market news parsed"
    },
    {
      "parameters": {
        "jsCode": "/**\n * AgentOutputRouter v1.3 (tolerant + intents\u2192weights)\n * Position: directly after the Agent, before the Switch.\n * Routes executor_output.v1 into three flat streams with _routeType:\n *  - 'orders'         (HTTP orders if present; ticker-only intents are converted to WEIGHTS)\n *  - 'pm_comms'       (one row)\n *  - 'trade_journal'  (rows from trade_journal or synthesized from accepted)\n */\n\nfunction safeParseStrict(s) { try { return JSON.parse(String(s)); } catch { return null; } }\nfunction extractMainObject(text) {\n  if (typeof text !== 'string') return null;\n  const first = text.indexOf('{'); const last  = text.lastIndexOf('}');\n  if (first === -1 || last === -1 || last <= first) return null;\n  return text.slice(first, last + 1);\n}\nfunction repairExecutorText(text) {\n  if (typeof text !== 'string') return null;\n  let s = extractMainObject(text) || text;\n  s = s.replace(/,\\s*Wait,[^:{\\[]+:\\s*/g, ',').replace(/\\bWait,[^:]+:\\s*/g, '');\n  s = s.replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//gm, '');\n  s = s.replace(/[\u201c\u201d]/g, '\"').replace(/[\u2018\u2019]/g, \"'\");\n  s = s.replace(/,(\\s*[}\\]])/g, '$1').trim();\n  return safeParseStrict(s);\n}\nfunction sniffExecutor(obj) {\n  if (obj?.schema_version === 'executor_output.v1') return obj;\n  const outTxt = obj?.output ?? obj?.text;\n  if (typeof outTxt === 'string') {\n    const strict = safeParseStrict(outTxt); if (strict?.schema_version === 'executor_output.v1') return strict;\n    const repaired = repairExecutorText(outTxt); if (repaired?.schema_version === 'executor_output.v1') return repaired;\n  }\n  if (typeof obj === 'string') {\n    const strict = safeParseStrict(obj); if (strict?.schema_version === 'executor_output.v1') return strict;\n    const repaired = repairExecutorText(obj); if (repaired?.schema_version === 'executor_output.v1') return repaired;\n  }\n  return null;\n}\nfunction addDaysIso(ts, days = 7) { const d = ts ? new Date(ts) : new Date(); d.setDate(d.getDate() + days); return d.toISOString(); }\nfunction parsePlayId(pid) {\n  const m = String(pid || '').match(/^([\\w.\\-]+):([^:]+?)(?::D(\\d+))?$/i);\n  if (!m) return { symbol: '', strategy: '', dte: null };\n  return { symbol: m[1].toUpperCase(), strategy: m[2].trim(), dte: m[3] ? Number(m[3]) : null };\n}\nfunction mapDirectionFromStrategy(strat) {\n  const s = String(strat || '').toLowerCase();\n  if (s.includes('short put') || s.includes('bear call spread') || s.includes('bull put spread') || s.includes('short call')) return 'CREDIT';\n  return 'DEBIT';\n}\n\n/* ---------- helpers for intents \u2192 weights ---------- */\nfunction dteFromISO(expISO, refIso) {\n  if (!expISO) return null;\n  const exp = new Date(expISO); if (Number.isNaN(exp)) return null;\n  const base = refIso ? new Date(refIso) : new Date();\n  return Math.max(0, Math.round((exp - base) / 86400000));\n}\nfunction intentToWeight(o, acceptedArr, runTs) {\n  // find accepted to pull target$, rationale if present\n  const acc = Array.isArray(acceptedArr) ? acceptedArr.find(a => a.play_id === o.play_id) : null;\n  const target$ = Number(acc?.target_wc_dollars || 0);\n  const dte = dteFromISO(o.exp, runTs) ?? (String(o.play_id||'').match(/:D(\\d+)/)?.[1] ? Number(RegExp.$1) : undefined);\n  const strikes = Array.isArray(o.strikes) ? o.strikes : [];\n  const tagParts = [];\n  if (o.exp) tagParts.push(`exp=${o.exp}`);\n  if (strikes.length) tagParts.push(`strikes=${strikes.join('/')}`);\n  if (o.side) tagParts.push(`side=${o.side}`);\n  if (o.target_limit != null) tagParts.push(`limit=${o.target_limit}`);\n  const qtyHint = Number.isFinite(Number(o.qty_hint)) ? Number(o.qty_hint) : undefined;\n\n  return {\n    _routeType: 'weights',\n    play_id: o.play_id || `${String(o.underlying||'').toUpperCase()}:${String(o.structure||'').trim()}`,\n    dte: Number.isFinite(dte) ? dte : undefined,\n    target_wc_dollars: Number.isFinite(target$) && target$ > 0 ? target$ : undefined,\n    qty: qtyHint,\n    profile: 'base',\n    tags: `INTENT ${tagParts.join(' ')}`\n  };\n}\n\n/* ---------- main ---------- */\nconst inputItems = $input.all();\nlet exec = null;\nfor (const it of inputItems) {\n  const candidate = sniffExecutor(it.json ?? it);\n  if (candidate?.schema_version === 'executor_output.v1') { exec = candidate; break; }\n}\nif (!exec) {\n  return [{ json: {\n    error: 'EXECUTOR_OUTPUT_NOT_FOUND',\n    hint: 'Agent returned non-parseable JSON. This router expects one JSON object with schema_version \"executor_output.v1\".',\n    saw_items: inputItems.length,\n    first_item_keys: inputItems[0] ? Object.keys(inputItems[0].json ?? inputItems[0]).slice(0, 25) : []\n  }}];\n}\n\nconst out = [];\n\n/* -------- pm_comms -------- */\nconst runTs = exec?.run?.timestamp || new Date().toISOString();\nout.push({ json: {\n  timestamp: runTs,\n  who: String(exec?.run?.who || 'EXECUTOR'),\n  ticker: 'EXECUTOR_RUN',\n  action: 'append',\n  expires: addDaysIso(runTs, 7),\n  notes_for_other: String(exec?.notes_for_other || ''),\n  _routeType: 'pm_comms'\n}});\n\n/* -------- trade_journal (prefer explicit; fallback to accepted) -------- */\nif (Array.isArray(exec?.trade_journal) && exec.trade_journal.length) {\n  for (const row of exec.trade_journal) {\n    out.push({ json: {\n      trade_id: String(row.trade_id || ''),\n      symbol: String(row.symbol || '').toUpperCase(),\n      strategy: String(row.strategy || ''),\n      direction: String(row.direction || '') || mapDirectionFromStrategy(row.strategy),\n      rationale: String(row.rationale || '').slice(0, 120),\n      risk_rating: String(row.risk_rating || 'MED'),\n      exit_plan: String(row.exit_plan || ''),\n      _routeType: 'trade_journal'\n    }});\n  }\n} else if (Array.isArray(exec?.decisions?.accepted)) {\n  for (const a of exec.decisions.accepted) {\n    const { symbol, strategy } = parsePlayId(a.play_id || '');\n    out.push({ json: {\n      trade_id: `${String(exec?.run?.run_id || '').trim()}|${String(a.play_id || '').trim()}`,\n      symbol,\n      strategy,\n      direction: mapDirectionFromStrategy(strategy),\n      rationale: String(a.why || '').slice(0, 120),\n      risk_rating: (a.size_pct != null && a.size_pct > 2.0) ? 'HIGH' : (a.size_pct > 1.0 ? 'MED' : 'LOW'),\n      exit_plan: '',\n      _routeType: 'trade_journal'\n    }});\n  }\n}\n\n/* -------- orders stream --------\n   HTTP orders are passed through.\n   Ticker-only \"intent\" orders (no request_body) are converted to WEIGHTS for the joiner.\n*/\nconst accepted = exec?.decisions?.accepted || [];\nif (Array.isArray(exec?.orders) && exec.orders.length) {\n  for (const o of exec.orders) {\n    const isHttp = o && (o.base_url || o.endpoint || o.request_body);\n    const isIntent = o && !o.base_url && !o.endpoint && !o.request_body && o.underlying;\n\n    if (isHttp) {\n      out.push({ json: {\n        route: 'http',\n        method: 'POST',\n        base_url: String(o.base_url || ''),\n        endpoint: String(o.endpoint || ''),\n        request_body: o.request_body || {},\n        trade_id: String(o.trade_id || ''),\n        play_id: String(o.play_id || ''),\n        _routeType: 'orders'\n      }});\n    } else if (isIntent) {\n      const w = intentToWeight(o, accepted, runTs);\n      out.push({ json: w });\n    }\n  }\n}\n\n/* -------- fallback: synthesize weights from accepted if no orders present -------- */\nconst emittedAnyOrder = out.some(x => x?.json?._routeType === 'orders' || x?.json?._routeType === 'weights');\nif (!emittedAnyOrder && Array.isArray(exec?.decisions?.accepted) && exec.decisions.accepted.length) {\n  for (const a of exec.decisions.accepted) {\n    const { symbol, strategy, dte } = parsePlayId(a.play_id || '');\n    out.push({ json: {\n      route: 'weights',\n      profile: 'Core',\n      trade_id: `${String(exec?.run?.run_id || '').trim()}|${String(a.play_id || '').trim()}`,\n      symbol,\n      strategy,\n      weight_pct: Number(a.size_pct ?? 1.0),\n      dte: (dte != null) ? dte : undefined,\n      rationale: String(a.why || '').slice(0, 120),\n      _routeType: 'orders'\n    }});\n  }\n}\n\n// Done\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5072,
        -176
      ],
      "id": "818ffa69-538b-4edb-83e0-d42161ba939b",
      "name": "Parse executor weights"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Join Weights \u2194 Enriched Play and build Alpaca order skeletons\n * (FORGIVING v3.3, long OPRA, agent-friendly, size floors/ceilings)\n *\n * What it does\n * - Pass-through existing HTTP orders\n * - Enrich Top-50 plays with CandidateGen (legs + pricing)\n * - Optionally convert trade_journal \u2192 weights (keeps original journal rows for downstream filters)\n * - Build HTTP-ready single/mleg orders using long OPRA symbols and marketable limit\n * - Sizing guardrails: floors/ceilings on contracts and order notional (auto-scale or drop)\n *\n * NOTE: mlegs use ratio_qty:'1' and the top-level qty carries the position size.\n */\n\nconst SIZING = { MIN_DOLLARS: 5000, MAX_DOLLARS: 30000, DEFAULT_BASE_DOLLARS: 18000 };\nconst PASS_THROUGH_EXISTING_ORDERS = true;\nconst USE_TRADE_JOURNAL_AS_WEIGHTS = true;\n\n// --- Size guardrails (edit to taste) ---\n// (Aligned with high-conviction policy: per-order $5k\u2013$30k)\nconst MIN_CONTRACTS          = 5;      // minimum contracts per order\nconst MIN_ORDER_DOLLARS      = 5000;   // minimum notional $ per order\nconst MAX_ORDER_DOLLARS      = 30000;  // maximum notional $ per order\nconst MAX_CONTRACTS_ABSOLUTE = 2000;   // hard safety clamp\n\n// ---------- helpers ----------\nconst up = (s)=>String(s||'').toUpperCase().trim();\nconst r2 = (x,p=2)=>Number((Math.round(Number(x)*10**p)/10**p).toFixed(p));\n\nfunction keyFromPlayId(pid){ return String(pid ?? '').trim(); }\nfunction symFromPlayId(pid){ return String(pid ?? '').split(':')[0].toUpperCase(); }\nfunction stratFromPlayId(pid){ return String(pid ?? '').split(':')[1]?.toUpperCase() || ''; }\n\nfunction classifyPriceMode(strategyRaw) {\n  const s = String(strategyRaw||'').toLowerCase();\n  if (s.includes('short put') || s.includes('bull put spread') || s.includes('bear call spread') || s.includes('short call')) return 'credit';\n  return 'debit';\n}\n\nfunction toOPRA(under, exp, type, strike) {\n  if (!under || !exp || !type || strike == null) return null;\n  const d = exp instanceof Date ? exp : new Date(exp);\n  if (Number.isNaN(d.getTime())) return null;\n  const yy = String(d.getUTCFullYear()).slice(-2);\n  const mm = String(d.getUTCMonth()+1).padStart(2,'0');\n  const dd = String(d.getUTCDate()).padStart(2,'0');\n  const cp = String(type).toUpperCase().startsWith('C') ? 'C' : 'P';\n  const k = Math.round(Number(strike) * 1000);\n  const s8 = String(k).padStart(8,'0');\n  return `${String(under).toUpperCase()}${yy}${mm}${dd}${cp}${s8}`;\n}\n\nconst roleToSide = r => (String(r||'').toUpperCase()==='SHORT'||String(r||'').toUpperCase()==='SELL') ? 'sell' : 'buy';\n\nfunction legsFromCandidate(symbol, cand) {\n  if (!cand || !Array.isArray(cand.legs) || cand.legs.length === 0) return null;\n  const out = [];\n  for (const L of cand.legs) {\n    const opra = toOPRA(symbol, L.exp || L.expiry, L.type || L.option_type, L.strike);\n    const side = roleToSide(L.role);\n    if (!opra || !side) continue;\n    const mid = Number.isFinite(+L.mid) ? r2(+L.mid, 2) : undefined;\n    const ba = (L.baPct != null) ? Number(L.baPct) : undefined;\n    out.push({ opra, side, mid, baPct: Number.isFinite(ba) ? ba : undefined });\n  }\n  return out.length ? out : null;\n}\n\nfunction scanPctSpread(cand, legs) {\n  const m = cand?.metrics || {};\n  let pct = null;\n  if (Number.isFinite(+m.pct_spread)) pct = +m.pct_spread;\n  else if (Number.isFinite(+m.avg_bid_ask_pc)) pct = +m.avg_bid_ask_pc;\n  else if (Number.isFinite(+m.bidAskSpread)) { pct = +m.bidAskSpread; if (pct < 1) pct *= 100; }\n  if (pct == null && Array.isArray(legs) && legs.length) {\n    const vals = legs.map(L => Number(L.baPct)).filter(v => Number.isFinite(v));\n    if (vals.length) { const mx = Math.max(...vals); pct = mx < 1 ? mx * 100 : mx; }\n  }\n  return Number.isFinite(pct) ? pct : null;\n}\n\nfunction priceFromCand(priceMode, cand, legs) {\n  const m = cand?.metrics || {};\n  let mid = null;\n  if (Array.isArray(legs) && legs.length && legs.every(L => Number.isFinite(L.mid))) {\n    const buys  = legs.filter(L => L.side === 'buy').reduce((a,b)=>a + (b.mid||0), 0);\n    const sells = legs.filter(L => L.side === 'sell').reduce((a,b)=>a + (b.mid||0), 0);\n    mid = r2(Math.max(0, priceMode === 'credit' ? (sells - buys) : (buys - sells)));\n  }\n  if (mid == null) {\n    if (priceMode === 'debit') { if (Number.isFinite(+m.cost)) mid = r2(+m.cost); else if (Number.isFinite(+m.debit)) mid = r2(+m.debit); }\n    else { if (Number.isFinite(+m.credit)) mid = r2(+m.credit); }\n  }\n  const pct_spread = scanPctSpread(cand, legs);\n  const width = Number.isFinite(+m.width) ? +m.width : null;\n  return { mid: (mid ?? null), pct_spread: (pct_spread ?? null), width };\n}\n\nfunction deriveMarketableLimit(priceMode, price, perContractWC) {\n  const mid = Number(price?.mid);\n  const pct = Number(price?.pct_spread);\n  if (Number.isFinite(mid) && Number.isFinite(pct) && mid > 0) {\n    const spreadAbs = (pct / 100) * mid;\n    const askEst = r2(mid + spreadAbs / 2);\n    const bidEst = r2(mid - spreadAbs / 2);\n    return priceMode === 'debit' ? Math.max(0.01, askEst) : Math.max(0.01, bidEst);\n  }\n  if (Number.isFinite(mid) && mid > 0) return r2(mid);\n  if (priceMode === 'debit' && Number.isFinite(+perContractWC) && +perContractWC > 0) return r2(+perContractWC);\n  return null;\n}\n\nfunction extractDesiredDteFromString(s) {\n  const m = String(s||'').match(/(?:^|[\\s:|])D(\\d+)\\b/i);\n  return m ? Number(m[1]) : null;\n}\nfunction desiredDte(weight) {\n  if (Number.isFinite(+weight?.dte)) return Number(weight.dte);\n  if (weight?.play_id) { const m = String(weight.play_id||'').match(/:D(\\d+)\\s*$/i); if (m) return Number(m[1]); }\n  return extractDesiredDteFromString(weight?.trade_id) ?? extractDesiredDteFromString(weight?.tags);\n}\nfunction weightSym(weight) { return weight?.play_id ? symFromPlayId(weight.play_id) : String(weight?.symbol || '').toUpperCase().trim(); }\nfunction weightStratUpper(weight) { return weight?.play_id ? stratFromPlayId(weight.play_id) : String(weight?.strategy || '').toUpperCase().trim(); }\n\nfunction dollarAwareQty(weight, play) {\n  const qx = Number(weight?.qty); if (Number.isFinite(qx) && qx > 0) return Math.floor(qx);\n  const per = Number(play?.per_contract?.wcPerContract);\n  let target = Number(weight?.target_wc_dollars); if (!Number.isFinite(target) || target <= 0) target = 18000;\n  target = Math.max(SIZING.MIN_DOLLARS, Math.min(SIZING.MAX_DOLLARS, Math.round(target)));\n  if (Number.isFinite(per) && per > 0) return Math.max(1, Math.floor(target / per));\n  const unitsPerPct = Number(play?.units?.contracts_per_1pct_weight);\n  const wPct = Math.max(0, Number(weight?.weight_pct) || 0);\n  if (Number.isFinite(unitsPerPct) && unitsPerPct > 0 && wPct > 0) return Math.max(1, Math.floor(unitsPerPct * wPct));\n  return 1;\n}\n\nfunction parseTradeJournalToWeight(j){\n  const m = String(j?.trade_id||'').match(/\\|([^:|]+):([^:|]+):D(\\d+)/);\n  if (!m) return null;\n  const [, sym, strat, d] = m;\n  return { play_id: `${up(sym)}:${strat}`, dte: Number(d), profile: 'base', _routeType: 'weights', tags: 'AUTO_FROM_TJ' };\n}\n\nfunction clean(obj) {\n  if (obj === null || obj === undefined) return undefined;\n  if (Array.isArray(obj)) return obj.map(clean).filter(v => v !== undefined);\n  if (typeof obj === 'object') {\n    const o = {}; for (const [k, v] of Object.entries(obj)) { const c = clean(v); if (c !== undefined) o[k] = c; }\n    return o;\n  }\n  if (typeof obj === 'number' && !Number.isFinite(obj)) return undefined;\n  return obj;\n}\n\n// per-contract notional estimator for sizing guardrails\nfunction perContractNotionalUSD(pkt, limit, priceMode) {\n  const wc = Number(pkt?.per_contract?.wcPerContract);\n  if (Number.isFinite(wc) && wc > 0) return wc;\n  const lim = Number(limit);\n  if (Number.isFinite(lim) && lim > 0) return Math.round(lim * 100); // option * 100\n  const mid = Number(pkt?.price?.mid);\n  if (Number.isFinite(mid) && mid > 0) return Math.round(mid * 100);\n  return null;\n}\n\n// ---------- collect ----------\nconst merged = $input.all().map(i => i?.json ?? i ?? {});\nconst plays = [], candidates = [], weights = [], passthruOrders = [], tradeJournal = [], pmComms = [];\n\nfor (const j of merged) {\n  if (j?._routeType === 'orders' && (j.request_body || j.endpoint || j.base_url)) { passthruOrders.push(j); continue; }\n  if (Array.isArray(j?.plays) || j?.schema_version === 'top20_menu.v1') { const arr = Array.isArray(j?.plays) ? j.plays : (j?.plays || []); for (const p of arr) if (p?.play_id) plays.push(p); continue; }\n  if (j?._routeType === 'pm_comms') { pmComms.push(j); continue; }\n  if (j?.symbol && Array.isArray(j?.candidates)) { candidates.push(j); continue; }\n  if (j?._routeType === 'trade_journal') { tradeJournal.push(j); continue; }\n  const looksLikeWeight = (j?._routeType === 'weights') || ('weight_pct' in j) || ('profile' in j) || ('trade_id' in j) || ('target_wc_dollars' in j) || ('qty' in j) || ('play_id' in j && !(j.candidates));\n  if (looksLikeWeight) { weights.push(j); continue; }\n  if (j?.play_id && (j.strategy || j.symbol)) { plays.push(j); continue; }\n}\n\n// best candidate per SYMBOL:STRATEGY\nconst CANDS = new Map();\nfor (const feed of candidates) {\n  const symbol = up(feed.symbol || '');\n  for (const cand of feed.candidates || []) {\n    if (!cand?.strategy) continue;\n    const key = `${symbol}:${String(cand.strategy).toUpperCase()}`;\n    const prev = CANDS.get(key);\n    if (!prev || (prev.score || 0) < (cand.score || 0)) CANDS.set(key, { ...cand, symbol });\n  }\n}\n\n// enrich plays\nconst enriched = [];\nfor (const play of plays) {\n  const s = symFromPlayId(play.play_id);\n  const st = String(play.strategy || stratFromPlayId(play.play_id));\n  const pm = classifyPriceMode(st);\n  const c = CANDS.get(`${s}:${String(st).toUpperCase()}`);\n  if (c) {\n    const legs = legsFromCandidate(s, c);\n    const price= priceFromCand(pm, c, legs);\n    enriched.push({ ...play, legs: legs || play.legs || null, price, price_mode: pm, contract_symbol: (legs && legs.length === 1 ? legs[0].opra : play.contract_symbol) || null });\n  } else {\n    enriched.push({ ...play, price_mode: pm, price: play.price || { mid:null, pct_spread:null, width:null } });\n  }\n}\nconst exact = new Map(enriched.map(p => [String(p.play_id).trim(), p]));\nconst bySym = new Map();\nfor (const p of enriched) { const s = symFromPlayId(p.play_id); if (!bySym.has(s)) bySym.set(s, []); bySym.get(s).push(p); }\n\n// ---------- build & emit ----------\nconst out = [];\n\n// pass-through HTTP orders\nif (PASS_THROUGH_EXISTING_ORDERS && passthruOrders.length) {\n  for (const o of passthruOrders) out.push({ json: o });\n}\n\n// optionally convert trade journal to weights (also keep journal rows in stream)\nif (USE_TRADE_JOURNAL_AS_WEIGHTS && tradeJournal.length) {\n  const have = new Set(weights.map(w => String(w.play_id||'').trim()));\n  for (const tj of tradeJournal) {\n    const w = parseTradeJournalToWeight(tj); if (!w) continue;\n    const pid = String(w.play_id||'').trim(); if (!pid || have.has(pid)) continue;\n    weights.push(w); have.add(pid);\n  }\n}\n\nconst seen = new Set();\nfunction pickByDte(sameStratList, wantDte) {\n  if (!Array.isArray(sameStratList) || sameStratList.length === 0) return null;\n  if (sameStratList.length === 1) return sameStratList[0];\n  let best = sameStratList[0], bestScore = Infinity;\n  for (const p of sameStratList) {\n    const dte = Number(p.dte || 0);\n    const dtePenalty = (wantDte != null) ? Math.abs(dte - wantDte) : dte;\n    const effPct = Number.isFinite(Number(p.price?.pct_spread)) ? Number(p.price.pct_spread)\n                 : (Number.isFinite(Number(p.quality?.pct_spread)) ? Number(p.quality.pct_spread) : 999);\n    const score = dtePenalty * 1000 + effPct;\n    if (score < bestScore) { best = p; bestScore = score; }\n  }\n  return best;\n}\n\nfor (const w of weights) {\n  const deKey = (function(weight){\n    const prof = String(weight?.profile || ''); const pid = String(weight?.play_id || '').trim();\n    if (pid) return `${pid}__${prof}`;\n    const s = weightSym(weight); const st = weightStratUpper(weight); const d = desiredDte(weight);\n    return `${s}:${st}${(d!=null)?`:D${d}`:''}__${prof}`;\n  })(w);\n  if (seen.has(deKey)) continue;\n  seen.add(deKey);\n\n  const wantDte = desiredDte(w);\n  let pkt = null;\n\n  const pid = String(w.play_id || '').trim();\n  if (pid) pkt = exact.get(pid);\n\n  if (!pkt) {\n    const s  = weightSym(w);\n    const stU= weightStratUpper(w);\n    const sameSym = bySym.get(s) || [];\n    if (sameSym.length === 1) pkt = sameSym[0];\n    else if (sameSym.length > 1) {\n      const sameStrat = sameSym.filter(p => String(p.strategy || '').toUpperCase() === stU);\n      if (sameStrat.length === 1) pkt = sameStrat[0];\n      else if (sameStrat.length > 1) pkt = pickByDte(sameStrat, wantDte);\n    }\n  }\n\n  // unresolved -> emit diagnostic and continue\n  if (!pkt) { out.push({ json: { ...w, join_error:'UNRESOLVED_PLAY', diag:{ via:'no_match', want_dte: wantDte } } }); continue; }\n\n  // initial qty from weight, then we may adjust by floors/ceilings\n  const baseQty = Math.max(Number(w.qty || 0), dollarAwareQty(w, pkt));\n\n  let legs = Array.isArray(pkt.legs) ? pkt.legs.map(L => ({ opra: L.opra, side: L.side })) : [];\n\n  const price_mode = pkt.price_mode || classifyPriceMode(pkt.strategy);\n  const price = {\n    mid:        (Number.isFinite(Number(pkt.price?.mid)) ? Number(pkt.price.mid) : null),\n    pct_spread: (Number.isFinite(Number(pkt.price?.pct_spread)) ? Number(pkt.price.pct_spread) : null),\n    width:      (Number.isFinite(Number(pkt.price?.width)) ? Number(pkt.price.width) : null)\n  };\n  if (price.pct_spread == null) {\n    const cKey = `${weightSym(w)}:${String(pkt.strategy||'').toUpperCase()}`;\n    const c = CANDS.get(cKey);\n    if (c) {\n      const legsCand = legsFromCandidate(weightSym(w), c) || [];\n      price.pct_spread = scanPctSpread(c, legsCand);\n    } else if (Number.isFinite(Number(pkt.quality?.pct_spread))) {\n      price.pct_spread = Number(pkt.quality.pct_spread);\n    }\n  }\n\n  const limit = deriveMarketableLimit(price_mode, price, pkt?.per_contract?.wcPerContract);\n\n  // readiness check\n  let ready = true, reasons = [];\n  if (!legs.length)                           { ready = false; reasons.push('legs_missing'); }\n  if (!Number.isFinite(baseQty) || baseQty < 1) { ready = false; reasons.push('size_zero'); }\n  if (!Number.isFinite(limit) || limit <= 0)  { ready = false; reasons.push('price_unavailable'); }\n  const reason_if_not_ready = reasons.length ? reasons.join('|') : undefined;\n\n  // SIZING GUARDRAILS (auto-scale or drop)\n  let adjQty = baseQty;\n  if (ready) {\n    const perNotional = perContractNotionalUSD(pkt, limit, price_mode);\n    if (Number.isFinite(perNotional) && perNotional > 0) {\n      // floor: contracts\n      if (adjQty < MIN_CONTRACTS) adjQty = MIN_CONTRACTS;\n      // floor: order notional\n      const needQtyForFloor = Math.ceil(MIN_ORDER_DOLLARS / perNotional);\n      if (adjQty < needQtyForFloor) adjQty = needQtyForFloor;\n      // ceiling: order notional\n      const maxQtyByNotional = Math.floor(MAX_ORDER_DOLLARS / perNotional);\n      if (adjQty > maxQtyByNotional) {\n        if (MIN_CONTRACTS > maxQtyByNotional || needQtyForFloor > maxQtyByNotional) {\n          out.push({ json: { _routeType:'diag', reason:'ORDER_DROPPED_MAX_NOTIONAL',\n            play_id: String(pkt.play_id), per_contract_usd: perNotional,\n            floor_qty: Math.max(MIN_CONTRACTS, needQtyForFloor), max_qty: Math.max(0, maxQtyByNotional) } });\n          continue; // drop this order\n        }\n        adjQty = maxQtyByNotional;\n      }\n      if (adjQty > MAX_CONTRACTS_ABSOLUTE) adjQty = MAX_CONTRACTS_ABSOLUTE;\n    } else {\n      // unknown notional \u2192 at least apply a contract floor\n      if (adjQty < MIN_CONTRACTS) adjQty = MIN_CONTRACTS;\n    }\n  }\n\n  // Build request_body\n  let request_body = null;\n  if (ready) {\n    if (legs.length === 1) {\n      request_body = {\n        asset_class: 'option',\n        symbol: legs[0].opra,                  // LONG OPRA\n        qty: String(adjQty),\n        side: legs[0].side,\n        type: 'limit',\n        limit_price: String(r2(limit)),\n        time_in_force: 'day',\n        client_order_id: (String(w.trade_id || w.play_id || '').replace(/[^A-Z0-9-_|:]/gi,'').slice(0,48) || undefined)\n      };\n    } else {\n      request_body = {\n        asset_class: 'option',\n        order_class: 'mleg',\n        qty: String(adjQty),\n        type: 'limit',\n        limit_price: String(r2(limit)),\n        time_in_force: 'day',\n        legs: legs.map(L => ({\n          symbol: L.opra,                       // LONG OPRA\n          side: L.side,\n          ratio_qty: '1',\n          position_intent: (L.side === 'sell' ? 'sell_to_open' : 'buy_to_open')\n        })),\n        client_order_id: (String(w.trade_id || w.play_id || '').replace(/[^A-Z0-9-_|:]/gi,'').slice(0,48) || undefined)\n      };\n    }\n  }\n\n  out.push({\n    json: {\n      _routeType: 'orders',\n      route: 'http',\n      method: 'POST',\n      base_url: 'https://paper-api.alpaca.markets',\n      endpoint: '/v2/orders',\n      request_body,\n      play_id: String(pkt.play_id),\n      packet: pkt,\n      order: {\n        ready,\n        reason_if_not_ready,\n        type: (legs.length<=1?'single':'spread'),\n        price_mode,\n        qty: adjQty,\n        legs,\n        price,\n        limit_plan: {\n          start: (Number.isFinite(price.mid) ? Number(price.mid) : null),\n          marketable: Number.isFinite(limit) ? r2(limit) : null,\n          max_steps: 0,\n          tif: 'DAY',\n          expected_slip_pct: (Number.isFinite(price.mid) && Number(price.mid)>0 && Number.isFinite(limit))\n            ? r2(((Number(limit) - Number(price.mid)) / Number(price.mid)) * 100, 2)\n            : null\n        }\n      }\n    }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4416,
        384
      ],
      "id": "c0b2d89b-6ac3-49b5-b013-b95c0bc2c25a",
      "name": "Join Weights"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Join Weights \u2194 Enriched Play and build Alpaca order skeletons (ROBUST, $-aware)\n * Context: single-input, post-Merge:Append (weights + plays + candidate feeds in the input array)\n *\n * OUTPUT one item per weight (see structure in header of your original node)\n */\n\n/* ---------- $ sizing config ---------- */\nconst SIZING = { MIN_DOLLARS: 3000, MAX_DOLLARS: 30000, DEFAULT_BASE_DOLLARS: 10000 };\n\n/* ---------- helpers ---------- */\nfunction key(x){ return String(x?.play_id ?? '').trim(); }\nfunction sym(pid){ return String(pid ?? '').split(':')[0]; }\nfunction strat(pid){ return String(pid ?? '').split(':')[1]?.toUpperCase() || ''; }\nconst r2 = (x, p = 2) => Number((Math.round(Number(x) * 10**p) / 10**p).toFixed(p));\n\nfunction desiredDte(weight){\n  if (Number.isFinite(+weight?.dte)) return Number(weight.dte);\n  const m = String(weight?.play_id||'').match(/:D(\\d+)\\s*$/i);\n  return m ? Number(m[1]) : null;\n}\n\nfunction toOPRA(under, exp, type, strike) {\n  if (!under || !exp || !type || strike == null) return null;\n  const d = exp instanceof Date ? exp : new Date(exp);\n  if (Number.isNaN(d.getTime())) return null;\n  const yy = String(d.getUTCFullYear()).slice(-2);\n  const mm = String(d.getUTCMonth()+1).padStart(2,'0');\n  const dd = String(d.getUTCDate()).padStart(2,'0');\n  const cp = String(type).toUpperCase().startsWith('C') ? 'C' : 'P';\n  const k  = Math.round(Number(strike) * 1000);\n  const s8 = String(k).padStart(8,'0');\n  return `${String(under).toUpperCase()}${yy}${mm}${dd}${cp}${s8}`;\n}\nconst roleToSide = r => (String(r||'').toUpperCase()==='SHORT'||String(r||'').toUpperCase()==='SELL')?'sell':'buy';\n\nfunction legsFromCandidate(symbol, cand) {\n  if (!cand || !Array.isArray(cand.legs) || cand.legs.length === 0) return null;\n  const out = [];\n  for (const L of cand.legs) {\n    const opra = toOPRA(symbol, L.exp || L.expiry, L.type || L.option_type, L.strike);\n    const side = roleToSide(L.role);\n    if (!opra || !side) continue;\n    const mid = Number.isFinite(+L.mid) ? r2(+L.mid, 2) : undefined;\n    const ba = (L.baPct != null) ? Number(L.baPct) : undefined; // frac or %\n    out.push({ opra, side, mid, baPct: Number.isFinite(ba) ? ba : undefined });\n  }\n  return out.length ? out : null;\n}\n\nfunction classifyPriceMode(strategyRaw) {\n  const S = String(strategyRaw||'').toLowerCase();\n  if (S.includes('short put') || S.includes('bull put spread') || S.includes('bear call spread') || S.includes('short call')) return 'credit';\n  return 'debit';\n}\n\nfunction scanPctSpread(cand, legs) {\n  const m = cand?.metrics || {};\n  let pct = null;\n  if (Number.isFinite(+m.pct_spread)) pct = +m.pct_spread;\n  else if (Number.isFinite(+m.avg_bid_ask_pc)) pct = +m.avg_bid_ask_pc;\n  else if (Number.isFinite(+m.bidAskSpread)) { pct = +m.bidAskSpread; if (pct < 1) pct *= 100; }\n  if (pct == null && Array.isArray(legs) && legs.length) {\n    const vals = legs.map(L => Number(L.baPct)).filter(v => Number.isFinite(v));\n    if (vals.length) { const max = Math.max(...vals); pct = max < 1 ? max*100 : max; }\n  }\n  return Number.isFinite(pct) ? pct : null;\n}\n\nfunction priceFromCand(priceMode, cand, legs) {\n  const m = cand?.metrics || {};\n  let mid = null;\n  if (Array.isArray(legs) && legs.length && legs.every(L => Number.isFinite(L.mid))) {\n    const buys  = legs.filter(L => L.side === 'buy').reduce((a,b)=>a+(b.mid||0),0);\n    const sells = legs.filter(L => L.side === 'sell').reduce((a,b)=>a+(b.mid||0),0);\n    mid = r2(Math.max(0, priceMode==='credit' ? (sells-buys) : (buys-sells)));\n  }\n  if (mid == null) {\n    if (priceMode==='debit')      { if (Number.isFinite(+m.cost)) mid=r2(+m.cost); else if (Number.isFinite(+m.debit))  mid=r2(+m.debit); }\n    else /*credit*/               { if (Number.isFinite(+m.credit)) mid=r2(+m.credit); }\n  }\n  const pct_spread = scanPctSpread(cand, legs);\n  const width = Number.isFinite(+m.width) ? +m.width : null;\n  return { mid: (mid ?? null), pct_spread: (pct_spread ?? null), width };\n}\n\nfunction deriveMarketableLimit(priceMode, price, perContractWC) {\n  const mid = Number(price?.mid), pct = Number(price?.pct_spread);\n  if (Number.isFinite(mid) && Number.isFinite(pct) && mid > 0) {\n    const spreadAbs = (pct / 100) * mid;\n    const askEst = r2(mid + spreadAbs / 2);\n    const bidEst = r2(mid - spreadAbs / 2);\n    return priceMode === 'debit' ? Math.max(0.01, askEst) : Math.max(0.01, bidEst);\n  }\n  if (Number.isFinite(mid) && mid > 0) return r2(mid);\n  if (priceMode === 'debit' && Number.isFinite(+perContractWC) && +perContractWC > 0) return r2(+perContractWC);\n  return null;\n}\n\n/* Dollar-aware qty: qty>0 wins; else target dollars (weight.target_wc_dollars OR 10k*weight_pct), clamp to [3k,30k], / wcPerContract; fallback to units */\nfunction dollarAwareQty(weight, play) {\n  const qx = Number(weight?.qty);\n  if (Number.isFinite(qx) && qx > 0) return Math.floor(qx);\n\n  const per = Number(play?.per_contract?.wcPerContract);\n  let target = Number(weight?.target_wc_dollars);\n  if (!Number.isFinite(target) || target <= 0) {\n    const wp = Number(weight?.weight_pct);\n    target = SIZING.DEFAULT_BASE_DOLLARS * (Number.isFinite(wp) && wp > 0 ? wp : 1);\n  }\n  target = Math.max(SIZING.MIN_DOLLARS, Math.min(SIZING.MAX_DOLLARS, Math.round(target)));\n  if (Number.isFinite(per) && per > 0) return Math.max(1, Math.floor(target / per));\n\n  const unitsPerPct = Number(play?.units?.contracts_per_1pct_weight);\n  const w = Math.max(0, Number(weight?.weight_pct) || 0);\n  if (Number.isFinite(unitsPerPct) && unitsPerPct > 0 && w > 0) return Math.max(1, Math.floor(unitsPerPct * w));\n  return 1;\n}\n\n/* ---------- collect inputs ---------- */\nconst merged = $input.all().map(i => i.json || {});\nconst weights = [];\nconst plays   = [];\nconst candidates = [];\n\nfor (const j of merged) {\n  if (Array.isArray(j?.plays)) { for (const p of j.plays) if (p?.play_id) plays.push(p); continue; }\n  if (j?.symbol && Array.isArray(j?.candidates)) { candidates.push(j); continue; }\n  if (('weight_pct' in j) || ('profile' in j) || ('trade_id' in j) || ('target_wc_dollars' in j)) { weights.push(j); continue; }\n  if (j?.play_id && (j.strategy || j.symbol)) { plays.push(j); continue; }\n}\n\n/* best candidate per symbol:STRAT by score */\nconst CANDS = new Map();\nfor (const feed of candidates) {\n  const symbol = feed.symbol;\n  for (const cand of feed.candidates || []) {\n    if (!cand?.strategy) continue;\n    const key = `${symbol}:${String(cand.strategy).toUpperCase()}`;\n    const prev = CANDS.get(key);\n    if (!prev || (prev.score || 0) < (cand.score || 0)) CANDS.set(key, { ...cand, symbol });\n  }\n}\n\n/* enrich plays with candidate legs/price */\nconst enriched = [];\nfor (const play of plays) {\n  const s = sym(play.play_id);\n  const st = play.strategy || strat(play.play_id);\n  const pmode = classifyPriceMode(st);\n  const cand = CANDS.get(`${s}:${String(st).toUpperCase()}`);\n  if (cand) {\n    const legs = legsFromCandidate(s, cand);\n    const price = priceFromCand(pmode, cand, legs);\n    enriched.push({\n      ...play,\n      legs: legs || play.legs || null,\n      price,\n      price_mode: pmode,\n      contract_symbol: (legs && legs.length === 1 ? legs[0].opra : play.contract_symbol) || null\n    });\n  } else {\n    enriched.push({ ...play, price_mode: pmode, price: play.price || { mid:null, pct_spread:null, width:null } });\n  }\n}\n\n/* lookups */\nconst exact = new Map(enriched.map(p => [key(p), p]));\nconst bySym = new Map();\nfor (const p of enriched) {\n  const s = sym(p.play_id);\n  if (!bySym.has(s)) bySym.set(s, []);\n  bySym.get(s).push(p);\n}\n\n/* ---------- join & build order skeletons ---------- */\nconst out = [];\nconst seen = new Set();\n\nfor (const w of weights) {\n  const k = key(w);\n  const dedupeK = `${k}__${w.profile || ''}`;\n  if (seen.has(dedupeK)) continue;\n  seen.add(dedupeK);\n\n  let pkt = exact.get(k);\n  let matched = pkt ? 'exact' : 'unresolved';\n  const wantDte = desiredDte(w);\n\n  if (!pkt) {\n    const sameSym = bySym.get(sym(w.play_id)) || [];\n    if (sameSym.length === 1) { pkt = sameSym[0]; matched = 'fallback'; }\n    else if (sameSym.length > 1) {\n      const wantStrat = strat(w.play_id);\n      const sameStrat = sameSym.filter(p => String(p.strategy || '').toUpperCase() === wantStrat);\n      if (sameStrat.length === 1) { pkt = sameStrat[0]; matched = 'sameStrat'; }\n      else if (sameStrat.length > 1) {\n        let best = sameStrat[0], bestScore = Infinity;\n        for (const p of sameStrat) {\n          const dte = Number(p.dte || 0);\n          const dtePenalty = (wantDte != null) ? Math.abs(dte - wantDte) : dte;\n          const effPct = Number.isFinite(Number(p.price?.pct_spread)) ? Number(p.price.pct_spread)\n                       : (Number.isFinite(Number(p.quality?.pct_spread)) ? Number(p.quality.pct_spread) : 999);\n          const score = dtePenalty * 1000 + effPct;\n          if (score < bestScore) { best = p; bestScore = score; }\n        }\n        pkt = best; matched = 'dteClosest';\n      }\n    }\n  }\n\n  if (!pkt) {\n    out.push({ json: { ...w, join_error: 'UNRESOLVED_PLAY', diag: { matched, want_dte: wantDte } } });\n    continue;\n  }\n\n  // Quantity ($-aware)\n  const qty = Math.max(Number(w.qty || 0), dollarAwareQty(w, pkt));\n\n  // Legs & type\n  const legsSrc = Array.isArray(pkt.legs) ? pkt.legs : [];\n  const legs = legsSrc.map(L => ({ opra: L.opra, side: L.side })); // clean\n  const orderType = legs.length === 1 ? 'single' : (legs.length > 1 ? 'spread' : 'single');\n\n  // Price & pct_spread\n  const price_mode = pkt.price_mode || classifyPriceMode(pkt.strategy || strat(pkt.play_id));\n  const price = {\n    mid: (Number.isFinite(Number(pkt.price?.mid)) ? Number(pkt.price.mid) : null),\n    pct_spread: (Number.isFinite(Number(pkt.price?.pct_spread)) ? Number(pkt.price.pct_spread) : null),\n    width: (Number.isFinite(Number(pkt.price?.width)) ? Number(pkt.price.width) : null)\n  };\n  if (price.pct_spread == null) {\n    const cKey = `${sym(pkt.play_id)}:${String(pkt.strategy||'').toUpperCase()}`;\n    if (CANDS.has(cKey)) {\n      const c = CANDS.get(cKey);\n      const legsCand = legsFromCandidate(sym(pkt.play_id), c) || [];\n      price.pct_spread = scanPctSpread(c, legsCand);\n    } else if (Number.isFinite(Number(pkt.quality?.pct_spread))) {\n      price.pct_spread = Number(pkt.quality.pct_spread);\n    }\n  }\n\n  // Marketable limit (use wcPerContract as fallback)\n  const marketable = deriveMarketableLimit(price_mode, price, pkt?.per_contract?.wcPerContract);\n\n  // Readiness\n  let ready = true, reasons = [];\n  if (!legs.length)                               { ready = false; reasons.push('legs_missing'); }\n  if (!Number.isFinite(qty) || qty < 1)           { ready = false; reasons.push('size_zero'); }\n  if (!Number.isFinite(marketable) || marketable <= 0) { ready = false; reasons.push('price_unavailable'); }\n  const reason_if_not_ready = reasons.length ? reasons.join('|') : undefined;\n\n  // Normalized play_id for downstream logs\n  const playIdOut = `${String(sym(pkt.play_id) || sym(w.play_id) || w.symbol || '').toUpperCase()}:${String(pkt.strategy || strat(w.play_id) || w.strategy || '').toUpperCase()}`;\n\n  const trade_id = w.trade_id || undefined;\n  const order_id_base = trade_id ? `${trade_id}:L` : undefined;\n\n  out.push({\n    json: {\n      ...w,\n      play_id: playIdOut,\n      packet: pkt,\n      order: {\n        ready,\n        reason_if_not_ready,\n        type: orderType,\n        price_mode,\n        qty,\n        legs: legs.map(L => ({ opra: L.opra, side: L.side, qty })),\n        price,\n        limit_plan: {\n          start: price.mid,\n          marketable: Number.isFinite(marketable) ? r2(marketable) : null,\n          max_steps: 0,\n          tif: 'DAY',\n          expected_slip_pct: (Number.isFinite(price.mid) && Number(price.mid) > 0 && Number.isFinite(marketable))\n            ? r2(((Number(marketable) - Number(price.mid)) / Number(price.mid)) * 100, 2)\n            : null\n        }\n      },\n      ids: { trade_id, order_id_base },\n      diag: { matched, want_dte: wantDte }\n    }\n  });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4928,
        608
      ],
      "id": "82dcce29-02ea-493b-9788-75e59f1bbec4",
      "name": "Size contracts from weights",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Build Alpaca Orders (HARDENED v5a: agent-filtered, pass-through fallback, long-OCC aware)\n *\n * Guarantees:\n * - Uses agent approvals when present (trade_journal, pm_comms).\n * - Prefers pass-through orders; can also build from joiner packets.\n * - **Preserves existing long OCC symbols**; only converts true short OPRA \u2192 long OCC.\n * - Forces endpoint -> /v2/orders (Alpaca v2 only).\n * - Spreads: order_class:\"mleg\", asset_class:\"option\", legs with ratio_qty:\"1\" + position_intent per leg.\n * - Singles: removes position_intent.\n * - Dedupes orders (keeps best: pass-through > joiner).\n * - Fallback: if NO approvals detected, forwards pass-through orders anyway (never empty).\n */\n\nconst DEFAULT_BASE_URL = 'https://paper-api.alpaca.markets';\nconst FORCED_ENDPOINT  = '/v2/orders';\n\nconst r2 = v => Number((Math.round(Number(v) * 100) / 100).toFixed(2));\n\nfunction clean(obj) {\n  if (obj === null || obj === undefined) return undefined;\n  if (Array.isArray(obj)) return obj.map(clean).filter(v => v !== undefined);\n  if (typeof obj === 'object') {\n    const o = {};\n    for (const [k, v] of Object.entries(obj)) {\n      const c = clean(v);\n      if (c !== undefined) o[k] = c;\n    }\n    return o;\n  }\n  if (typeof obj === 'number' && !Number.isFinite(obj)) return undefined;\n  return obj;\n}\n\n/* ---------------- option symbol helpers ----------------\n   We must handle BOTH:\n   - Long OCC:  TICKER YYMMDD C/P + 8-digit strike (strike*1000)  e.g. YELP251017C00034000\n   - Short OPRA: TICKER YYMMDD C/P + strike (may include decimals) e.g. YELP251017C34 or C31.5\n--------------------------------------------------------- */\nconst LONG_OCC_RE  = /^([A-Z.]+)(\\d{6})([CP])(\\d{8})$/;\nconst SHORT_OPRA_RE= /^([A-Z.]+)(\\d{6})([CP])(\\d+(?:\\.\\d+)?)$/;\n\nfunction parseLongOcc(sym) {\n  const m = String(sym || '').toUpperCase().match(LONG_OCC_RE);\n  if (!m) return null;\n  const [_, under, yymmdd, cp, k8] = m;\n  return {\n    under,\n    yymmdd,\n    cp,\n    strike: Number(k8) / 1000, // normalized numeric strike\n    type: cp === 'C' ? 'CALL' : 'PUT',\n    isLong: true\n  };\n}\nfunction parseShortOpra(sym) {\n  const m = String(sym || '').toUpperCase().match(SHORT_OPRA_RE);\n  if (!m) return null;\n  const [_, under, yymmdd, cp, kstr] = m;\n  return {\n    under,\n    yymmdd,\n    cp,\n    strike: Number(kstr), // numeric strike as written\n    type: cp === 'C' ? 'CALL' : 'PUT',\n    isLong: false\n  };\n}\n/** Parse any option symbol (long OCC or short OPRA) to a normalized shape */\nfunction parseAnyOpt(sym) {\n  return parseLongOcc(sym) || parseShortOpra(sym);\n}\n/** Convert to long OCC if (and only if) it is short OPRA; preserve already-long OCC verbatim */\nfunction toLongOcc(sym) {\n  const s = String(sym || '').toUpperCase();\n  if (LONG_OCC_RE.test(s)) return s; // already long OCC \u2014 do NOT re-encode\n  const p = parseShortOpra(s);\n  if (!p) return s; // unknown form; return as-is (better than mangling)\n  const k1000 = Math.round(p.strike * 1000);\n  const s8 = String(k1000).padStart(8, '0');\n  return `${p.under}${p.yymmdd}${p.cp}${s8}`;\n}\n\nfunction isSpreadBody(rb) {\n  if (!rb) return false;\n  if (String(rb.order_class || '').toLowerCase() === 'mleg') return true;\n  return Array.isArray(rb.legs) && rb.legs.length > 1;\n}\nfunction legIntent(side) {\n  return String(side).toLowerCase() === 'sell' ? 'sell_to_open' : 'buy_to_open';\n}\n\n// pick a usable limit\nfunction pickLimitFromOrder(o) {\n  const lp = o?.limit_plan || {};\n  const p  = o?.price || {};\n  if (Number.isFinite(lp.marketable) && lp.marketable > 0) return r2(lp.marketable);\n  if (Number.isFinite(lp.final)      && lp.final > 0)      return r2(lp.final);\n  if (Number.isFinite(p.mid)         && p.mid > 0)         return r2(p.mid);\n  return null;\n}\n\n// ---- infer play_id from an order body (UNDER:Strategy) ----\nfunction inferStrategyFromLegs(legs) {\n  if (!Array.isArray(legs) || legs.length < 2) return null;\n  const buy  = legs.find(L => String(L.side).toLowerCase() === 'buy');\n  const sell = legs.find(L => String(L.side).toLowerCase() === 'sell');\n  if (!(buy && sell)) return null;\n\n  const pb = parseAnyOpt(buy.symbol);\n  const ps = parseAnyOpt(sell.symbol);\n  if (!(pb && ps) || pb.cp !== ps.cp) return null;\n\n  if (pb.cp === 'C') return (ps.strike > pb.strike) ? 'Bull Call Spread' : 'Bear Call Spread';\n  return (ps.strike > pb.strike) ? 'Bull Put Spread' : 'Bear Put Spread';\n}\nfunction inferStrategyFromSingle(symbol, side) {\n  const p = parseAnyOpt(symbol); if (!p) return null;\n  const s = String(side || 'buy').toLowerCase();\n  return p.type === 'CALL' ? (s === 'sell' ? 'Short Call' : 'Long Call')\n                           : (s === 'sell' ? 'Short Put'  : 'Long Put');\n}\nfunction inferPlayIdFromBody(rb) {\n  if (isSpreadBody(rb)) {\n    const legs = (rb.legs || []).map(L => ({ ...L, symbol: toLongOcc(L.symbol || L.opra) }));\n    const strat = inferStrategyFromLegs(legs);\n    const under = parseAnyOpt(legs[0]?.symbol)?.under;\n    if (strat && under) return `${under}:${strat}`;\n  } else {\n    const sym = toLongOcc(rb.symbol || '');\n    const p = parseAnyOpt(sym); if (!p) return null;\n    const strat = inferStrategyFromSingle(sym, rb.side);\n    if (strat && p.under) return `${p.under}:${strat}`;\n  }\n  return null;\n}\n\n// ---- build allowed set from agent approvals ----\nfunction parseTJtoPid(trade_id) {\n  // format \"...|SYMB:Strategy:D<n>\"\n  const m = String(trade_id || '').match(/\\|([^:|]+):([^:|]+):D\\d+\\b/);\n  if (!m) return null;\n  return `${m[1].toUpperCase().trim()}:${m[2].trim()}`;\n}\nfunction extractPidsFromPmComms(text) {\n  if (!text) return [];\n  const re = /\\b([A-Z.]+):(Bull Call Spread|Bull Put Spread|Bear Call Spread|Bear Put Spread|Long Call|Long Put|Short Call|Short Put):?D?\\d*\\b/g;\n  const out = new Set();\n  let m; while ((m = re.exec(String(text))) !== null) out.add(`${m[1].toUpperCase()}:${m[2]}`);\n  return [...out];\n}\n\n/* ---------------- main ---------------- */\nconst items = $input.all().map(x => x?.json ?? x ?? {});\nconst approvals = new Set();\nconst weightItems = [];  // fallback approvals if tagged from TJ\n\nfor (const it of items) {\n  if (it?._routeType === 'trade_journal' && it.trade_id) {\n    const pid = parseTJtoPid(it.trade_id);\n    if (pid) approvals.add(pid);\n  } else if (it?._routeType === 'pm_comms' && it.notes_for_other) {\n    for (const pid of extractPidsFromPmComms(it.notes_for_other)) approvals.add(pid);\n  } else if (it?._routeType === 'weights') {\n    weightItems.push(it);\n  }\n}\n\n// fallback approvals from weights tagged AUTO_FROM_TRADE_JOURNAL\nif (approvals.size === 0) {\n  for (const w of weightItems) {\n    if (String(w.tags || '').includes('AUTO_FROM_TRADE_JOURNAL') && w.play_id) {\n      approvals.add(String(w.play_id).trim());\n    }\n  }\n}\n\nconst out = [];\nconst seen = new Map(); // dkey -> { rank, index } ; rank 0 = pass-through, 1 = joiner\nconst FORWARD_PASS_THROUGH_IF_NO_APPROVALS = true;\n\n// normalize & emit helper\nfunction normalizeAndMaybeEmit(it, rank) {\n  const hasPassThrough = !!it.request_body;\n  const hasJoiner      = !!(it.order && it.order.ready);\n  if (!hasPassThrough && !hasJoiner) return;\n\n  let rb = null;\n  let isSpread = false;\n\n  if (hasPassThrough) {\n    rb = { ...(it.request_body || {}) };\n\n    if (isSpreadBody(rb)) {\n      isSpread = true;\n      rb.order_class = 'mleg';\n      rb.legs = (rb.legs || []).map(L => ({\n        symbol: toLongOcc(L.symbol || L.opra),\n        side: L.side,\n        ratio_qty: '1',\n        position_intent: L.position_intent || legIntent(L.side)\n      }));\n      rb.asset_class = rb.asset_class || 'option';\n    } else {\n      rb.symbol = toLongOcc(rb.symbol || it.order?.legs?.[0]?.opra || it.packet?.contract_symbol || '');\n      rb.side = rb.side || it.order?.legs?.[0]?.side || 'buy';\n      if ('position_intent' in rb) delete rb.position_intent;\n    }\n    if (rb.qty != null) rb.qty = String(rb.qty);\n    if (rb.limit_price != null) rb.limit_price = String(rb.limit_price);\n    rb.type = rb.type || 'limit';\n    rb.time_in_force = rb.time_in_force || 'day';\n\n  } else {\n    // from joiner\n    const ord = it.order;\n    const pkt = it.packet || {};\n    isSpread = Array.isArray(ord.legs) && ord.legs.length > 1;\n    const limit = pickLimitFromOrder(ord);\n    if (!Number.isFinite(limit) || limit <= 0) return;\n\n    if (!isSpread) {\n      const L = ord.legs?.[0] || {};\n      const opra = toLongOcc(L.opra || pkt.contract_symbol || '');\n      const side = L.side || 'buy';\n      if (!opra || !side) return;\n      rb = {\n        asset_class: 'option',\n        symbol: opra,\n        qty: String(ord.qty ?? 1),\n        side,\n        type: 'limit',\n        time_in_force: 'day',\n        limit_price: String(r2(limit))\n      };\n    } else {\n      const legs = (ord.legs || []).map(L => ({\n        symbol: toLongOcc(L.opra),\n        side: L.side,\n        ratio_qty: '1',\n        position_intent: legIntent(L.side)\n      }));\n      if (legs.some(L => !L.symbol || !L.side)) return;\n      rb = {\n        asset_class: 'option',\n        order_class: 'mleg',\n        qty: String(ord.qty ?? 1),\n        type: 'limit',\n        time_in_force: 'day',\n        limit_price: String(r2(limit)),\n        legs\n      };\n    }\n  }\n\n  // approvals gate (unless fallback mode)\n  let pid = (it.play_id && String(it.play_id).trim()) || inferPlayIdFromBody(rb) || null;\n\n  if (approvals.size > 0) {\n    if (!pid || !approvals.has(pid)) return; // skip non-approved\n  } else if (!FORWARD_PASS_THROUGH_IF_NO_APPROVALS) {\n    return; // strict mode (unused)\n  } else {\n    // fallback: no approvals detected \u2192 allow pass-through only\n    if (!hasPassThrough) return;\n  }\n\n  // build dedupe key using stable long-OCC representations\n  let dkey = '';\n  if (isSpread) {\n    const legsKey = (rb.legs || [])\n      .map(L => `${toLongOcc(L.symbol)}|${String(L.side).toLowerCase()}`)\n      .sort()\n      .join('||');\n    dkey = `ML|${legsKey}|${rb.qty}|${rb.limit_price}`;\n  } else {\n    dkey = `SN|${toLongOcc(rb.symbol)}|${String(rb.side).toLowerCase()}|${rb.qty}|${rb.limit_price}`;\n  }\n\n  const prev = seen.get(dkey);\n  if (prev && prev.rank <= rank) return; // keep earlier/better\n  seen.set(dkey, { rank, index: out.length });\n\n  out.push({\n    json: {\n      _routeType: 'orders',\n      route: 'http',\n      method: 'POST',\n      base_url: DEFAULT_BASE_URL,\n      endpoint: FORCED_ENDPOINT,\n      request_body: clean(rb),\n      play_id: pid || undefined,\n      approved: approvals.size > 0 ? true : undefined\n    }\n  });\n}\n\n// 1) pass-through first (rank 0) \u2192 always included when no approvals (fallback)\nfor (const it of items) if (it?.request_body) normalizeAndMaybeEmit(it, 0);\n// 2) joiner-built second (rank 1)\nfor (const it of items) if (it?.order && it.order.ready) normalizeAndMaybeEmit(it, 1);\n\n// if absolutely nothing made it through (edge), emit nothing (let flow surface)\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4880,
        384
      ],
      "id": "93352d68-b140-46f5-8ece-c7e1e32473f8",
      "name": "Build Orders Payload",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$json.base_url}}{{$json.endpoint}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.request_body}}",
        "options": {
          "timeout": 750000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5440,
        384
      ],
      "id": "f99e5e22-4d9a-4e15-a2f1-54ad7a990cc8",
      "name": "Place Orders",
      "retryOnFail": true,
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "url": "={{$json.base_url}}/v2/orders/{{$json.id}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5696,
        272
      ],
      "id": "997e9016-0b5a-4468-92a7-ca11f161d8f2",
      "name": "Poll status",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Grok Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Why did you make this trade?",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{$json.timestamp}}",
            "menu_id": "={{$json.menu_id}}",
            "event": "={{$json.event}}",
            "client_order_id": "={{$json.client_order_id}}",
            "order_id": "={{$json.order_id}}",
            "status": "={{$json.status}}",
            "error_reason": "={{$json.error_reason}}",
            "filled_avg_price": "={{$json.filled_avg_price}}",
            "filled_qty": "={{$json.filled_qty}}",
            "rationale": "={{$json.rationale}}",
            "symbol_or_legs": "={{$json.symbol_or_legs}}",
            "base_url": "={{$json.base_url}}",
            "endpoint": "={{$json.endpoint}}",
            "order_class": "={{$json.order_class}}",
            "net_type": "={{$json.net_type}}",
            "limit_price": "={{$json.limit_price}}",
            "qty": "={{$json.qty}}",
            "weight_pct": "={{$json.weight_pct}}",
            "profile": "={{$json.profile}}",
            "play_id": "={{$json.play_id}}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "event",
              "displayName": "event",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "menu_id",
              "displayName": "menu_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "client_order_id",
              "displayName": "client_order_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "order_id",
              "displayName": "order_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "play_id",
              "displayName": "play_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "profile",
              "displayName": "profile",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "weight_pct",
              "displayName": "weight_pct",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "qty",
              "displayName": "qty",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "limit_price",
              "displayName": "limit_price",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "net_type",
              "displayName": "net_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "order_class",
              "displayName": "order_class",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "symbol_or_legs",
              "displayName": "symbol_or_legs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "endpoint",
              "displayName": "endpoint",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "base_url",
              "displayName": "base_url",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "rationale",
              "displayName": "rationale",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "filled_qty",
              "displayName": "filled_qty",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "filled_avg_price",
              "displayName": "filled_avg_price",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "error_reason",
              "displayName": "error_reason",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "useAppend": true
        }
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5920,
        480
      ],
      "id": "881d5ba3-1dc3-414a-8f62-93b1de0200dd",
      "name": "Append row in sheet",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Join Place Orders (input 0) with Build Orders Payload (input 1) by client_order_id\nconst reqs = $input.all(1).map(i => i.json);\nconst reqByCID = new Map(reqs.map(r => [r.client_order_id, r]));\n\nconst out = [];\nfor (const it of $input.all(0)) {\n  const res = it.json || {};\n  const cid = res.client_order_id || it.json?.client_order_id || null;\n  const req = cid ? reqByCID.get(cid) : null;\n\n  // derive a compact legs/symbol string + net type (DEBIT/CREDIT)\n  let order_class = 'single';\n  let symbol_or_legs = '';\n  let net_type = null;\n  let qty = req?.request_body?.qty ?? req?.qty ?? null;\n  const limit = req?.request_body?.limit_price ?? null;\n\n  if (Array.isArray(req?.request_body?.legs) && req.request_body.legs.length) {\n    order_class = 'multileg';\n    symbol_or_legs = req.request_body.legs.map(l => `${l.side}:${l.symbol}`).join(' | ');\n    const sells = req.request_body.legs.filter(l => l.side === 'sell').length;\n    const buys  = req.request_body.legs.filter(l => l.side === 'buy').length;\n    net_type = sells > buys ? 'CREDIT' : 'DEBIT';\n  } else {\n    symbol_or_legs = `${req?.request_body?.side || ''}:${req?.request_body?.symbol || ''}`.trim();\n    net_type = (req?.request_body?.side === 'sell') ? 'CREDIT' : 'DEBIT';\n  }\n\n  out.push({ json: {\n    timestamp: new Date().toISOString(),\n    event: res.id ? 'submitted' : 'submit_error',\n    menu_id: req?.menu_id ?? null,\n    client_order_id: req?.client_order_id ?? cid ?? null,\n    order_id: res.id ?? null,\n    status: res.status ?? (res.message || 'error'),\n    play_id: req?.play_id ?? null,\n    profile: req?.profile ?? null,\n    weight_pct: req?.weight_pct ?? null,\n    qty,\n    limit_price: limit ?? null,\n    net_type,\n    order_class,\n    symbol_or_legs,\n    endpoint: req?.endpoint ?? null,\n    base_url: req?.base_url ?? null,\n    rationale: req?.rationale ?? null,\n    filled_qty: null,\n    filled_avg_price: null,\n    error_reason: res.error || it.json?.error || null,\n  }});\n}\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5696,
        480
      ],
      "id": "a6afebe8-7c0a-4fb9-8e70-490bbdcf69f0",
      "name": "Build log for journal"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4160,
        368
      ],
      "id": "b9d8ff92-3cef-445e-a167-7bb83268c900",
      "name": "Begin to Build Orders"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/positions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1184,
        -2224
      ],
      "id": "b7409621-4362-4212-b84b-7a8c62de0223",
      "name": "Portfolio summary1",
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "url": "https://paper-api.alpaca.markets/v2/account",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1200,
        -2048
      ],
      "id": "8a0e5cba-bb17-42fc-b1db-f0dbbd7c9a09",
      "name": "Current account balances1",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "url": "={{ \"https://query1.finance.yahoo.com/v8/finance/chart/\" \n   + encodeURIComponent($json.symbol) \n   + \"?interval=1d&range=1y&includePrePost=false\" }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2752,
        1088
      ],
      "id": "9117bcf7-c4e1-4e57-8647-2161cc86901a",
      "name": "Market Data"
    },
    {
      "parameters": {
        "jsCode": "// Output list of tickers for Yahoo v8 chart calls\nreturn [\n  { json: { symbol: \"^GSPC\",   name: \"S&P 500\" } },\n  { json: { symbol: \"^DJI\",    name: \"Dow Jones\" } },\n  { json: { symbol: \"^RUT\",    name: \"Russell 2000\" } },\n  { json: { symbol: \"^VIX\",    name: \"VIX\" } },\n  { json: { symbol: \"GC=F\",    name: \"Gold Futures\" } },\n  { json: { symbol: \"BTC-USD\", name: \"Bitcoin (USD)\" } },\n  { json: { symbol: \"DX-Y.NYB\",name: \"US Dollar Index (DXY)\" } }, // if this errors, try \"DX=F\"\n  { json: { symbol: \"^TNX\",    name: \"US 10Y Treasury Yield (\u00d710)\" } },\n  { json: { symbol: \"TIP\",     name: \"iShares TIPS ETF\" } }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2592,
        1200
      ],
      "id": "888df706-01eb-4414-a038-9319a4f380a5",
      "name": "Indexes"
    },
    {
      "parameters": {
        "jsCode": "// Robust index analyzer for n8n Code node (Yahoo v8 chart)\n// Adds options-focused metrics: HV20/HV60, 1d/5d expected move, ATR(14)/ATR%,\n// Bollinger (20,2) width/position, 52w distances/percentile, RVOL10.\n// Handles DXY quirks and yield scaling (^TNX/^TYX/^IRX).\n\nconst items = $input.all();\n\n/* ---------------- helpers ---------------- */\nfunction normalize(items) {\n  const out = [];\n  for (const it of items) {\n    const payload = it?.json ?? it;\n    if (Array.isArray(payload)) for (const el of payload) out.push(el?.json ?? el);\n    else out.push(payload);\n  }\n  return out;\n}\nfunction pickResult(node) {\n  const res = node?.chart?.result?.[0];\n  if (!res || !res.indicators?.quote?.[0]?.close || !res.timestamp) return null;\n  return res;\n}\nfunction normalizeSymbol(sym) {\n  if (!sym) return 'UNKNOWN';\n  if (sym === 'DX-F.NYB') return 'DX-Y.NYB'; // occasional server-side variant\n  return sym;\n}\nfunction nameFor(sym, meta) {\n  const map = {\n    '^GSPC':'S&P 500','^DJI':'Dow Jones','^RUT':'Russell 2000','^VIX':'VIX',\n    'GC=F':'Gold Futures','BTC-USD':'Bitcoin (USD)',\n    'DX-Y.NYB':'US Dollar Index (DXY)','DX=F':'US Dollar Index (futures)',\n    '^TNX':'US 10Y Treasury Yield','^TYX':'US 30Y Treasury Yield','^IRX':'US 13W T-Bill Yield',\n    'TIP':'iShares TIPS ETF'\n  };\n  return map[sym] || meta?.longName || meta?.shortName || sym;\n}\nconst YIELD_TICKERS = new Set(['^TNX','^TYX','^IRX']);\nfunction norm(n){ const x=Number(n); return isFinite(x)?x:null; }\n// Adaptive yield scaling (Yahoo sometimes returns \u00d710)\nfunction normClose(sym, c) {\n  const n = norm(c); if (n==null) return null;\n  return YIELD_TICKERS.has(sym) ? (n > 20 ? +(n/10).toFixed(3) : +n.toFixed(3)) : n;\n}\nfunction avg(arr){ const a=arr.filter(v=>v!=null); return a.length? a.reduce((s,x)=>s+x,0)/a.length : null; }\nfunction stddev(arr){\n  const a=arr.filter(v=>v!=null); if(a.length<2) return null;\n  const m=avg(a); const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/(a.length-1);\n  return Math.sqrt(v);\n}\nfunction calcSMA(data, p){ if(data.length<p) return null;\n  const out=new Array(data.length).fill(null); let sum=0;\n  for(let i=0;i<data.length;i++){ sum+=data[i].close; if(i>=p) sum-=data[i-p].close; if(i>=p-1) out[i]=+(sum/p).toFixed(2); }\n  return out;\n}\nfunction calcEMA(data, p){\n  if (data.length<p) return null;\n  const out=new Array(data.length).fill(null); const k=2/(p+1);\n  let sum=0; for(let i=0;i<p;i++) sum+=data[i].close;\n  let ema=sum/p; out[p-1]=+ema.toFixed(2);\n  for(let i=p;i<data.length;i++){ ema=data[i].close*k+ema*(1-k); out[i]=+ema.toFixed(2); }\n  return out;\n}\nfunction logReturns(prices){\n  const r=[]; for(let i=1;i<prices.length;i++){\n    const a=prices[i-1].close, b=prices[i].close;\n    if(a!=null && b!=null) r.push(Math.log(b/a));\n  } return r;\n}\nfunction trueRanges(prices){\n  const tr=[]; for(let i=0;i<prices.length;i++){\n    const h=prices[i].high, l=prices[i].low, pc=i>0?prices[i-1].close:null;\n    if(h==null||l==null||pc==null){ if(i>0) tr.push(h!=null&&l!=null? (h-l):null); continue; }\n    tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc)));\n  } return tr;\n}\n\n/* ---------------- main ---------------- */\nconst payloads = normalize(items);\nconst results = [];\n\nfor (const node of payloads) {\n  const res = pickResult(node);\n  if (!res) continue;\n\n  const sym  = normalizeSymbol(res.meta?.symbol ?? 'UNKNOWN');\n  const name = nameFor(sym, res.meta);\n\n  const q = res.indicators.quote?.[0] || {};\n  const ts = res.timestamp;\n\n  // Build series (O/H/L/C/V)\n  const prices = [];\n  for (let i=0;i<ts.length;i++){\n    const close = normClose(sym, q.close?.[i]);\n    if (close==null) continue;\n    prices.push({\n      date: new Date(ts[i]*1000).toISOString().slice(0,10),\n      ts: ts[i],\n      open:  normClose(sym, q.open?.[i]),\n      high:  normClose(sym, q.high?.[i]),\n      low:   normClose(sym, q.low?.[i]),\n      close,\n      volume: norm(q.volume?.[i])\n    });\n  }\n  if (prices.length < 10) continue;\n\n  // MAs\n  const SMA10=calcSMA(prices,10), SMA20=calcSMA(prices,20), SMA50=calcSMA(prices,50), SMA200=calcSMA(prices,200);\n  const EMA20=calcEMA(prices,20);\n  const last = prices[prices.length-1];\n  const last10=SMA10?.at(-1)??null, last20=SMA20?.at(-1)??null, last50=SMA50?.at(-1)??null, last200=SMA200?.at(-1)??null, lastE20=EMA20?.at(-1)??null;\n\n  // Trends\n  let shortTerm='INSUFFICIENT_DATA';\n  if(last10!=null && last20!=null){\n    shortTerm = (last.close>last10 && last10>last20) ? 'Bullish'\n            :  (last.close<last10 && last10<last20) ? 'Bearish' : 'Neutral';\n  }\n  let longTerm='INSUFFICIENT_DATA';\n  if(last50!=null && last200!=null) longTerm = last50>last200?'Bullish':(last50<last200?'Bearish':'Neutral');\n  else if(last20!=null && last50!=null) longTerm = last20>last50?'Bullish (20>50 fallback)':(last20<last50?'Bearish (20<50 fallback)':'Neutral');\n\n  let overall='Neutral';\n  if(last200!=null && last50!=null && last20!=null){\n    if(last.close>last20 && last20>last50 && last50>last200) overall='Strong Bullish';\n    else if(last.close<last20 && last20<last50 && last50<last200) overall='Strong Bearish';\n    else if(last.close>last50 && last50>last200) overall='Bullish';\n    else if(last.close<last50 && last50<last200) overall='Bearish';\n  } else if(last50!=null && last20!=null){\n    if(last.close>last20 && last20>last50) overall='Bullish';\n    else if(last.close<last20 && last20<last50) overall='Bearish';\n  }\n\n  let signal='Hold';\n  if(SMA20 && SMA50 && SMA20.length>=2 && SMA50.length>=2){\n    const prev20=SMA20[SMA20.length-2], prev50=SMA50[SMA50.length-2];\n    if(prev20!=null && prev50!=null){\n      if(prev20<=prev50 && last20>last50) signal='Golden Cross (20/50)';\n      if(prev20>=prev50 && last20<last50) signal='Death Cross (20/50)';\n    }\n  }\n\n  const refMA = last200 ?? last50 ?? last20 ?? null;\n  const refLabel = (last200!=null)?'200':(last50!=null?'50':'20');\n  let distPct=null, strength='INSUFFICIENT_DATA';\n  if(refMA!=null && refMA!==0){\n    distPct=+(((last.close-refMA)/refMA)*100).toFixed(2);\n    strength = distPct>10?'Very Strong': distPct>5?'Strong': distPct>0?'Above Average'\n            :  distPct>-5?'Below Average': distPct>-10?'Weak':'Very Weak';\n  }\n\n  // Perf windows\n  const dailyChange  = prices.length>1  ? +(((last.close - prices.at(-2).close)/prices.at(-2).close)*100).toFixed(2) : null;\n  const weeklyChange = prices.length>6  ? +(((last.close - prices.at(-6).close)/prices.at(-6).close)*100).toFixed(2) : null;\n  const monthlyChange= prices.length>21 ? +(((last.close - prices.at(-21).close)/prices.at(-21).close)*100).toFixed(2) : null;\n\n  // ---------- Options-oriented metrics ----------\n  const rets = logReturns(prices);\n  const sigma20 = rets.length>=20 ? stddev(rets.slice(-20)) : null;\n  const sigma60 = rets.length>=60 ? stddev(rets.slice(-60)) : null;\n  const hv20 = sigma20!=null ? +(sigma20*Math.sqrt(252)*100).toFixed(2) : null; // %\n  const hv60 = sigma60!=null ? +(sigma60*Math.sqrt(252)*100).toFixed(2) : null; // %\n\n  const em1d_pct = sigma20!=null ? +(sigma20*100).toFixed(2) : null;\n  const em5d_pct = sigma20!=null ? +((sigma20*Math.sqrt(5))*100).toFixed(2) : null;\n  const em1d_abs = (em1d_pct!=null) ? +((last.close*(em1d_pct/100))).toFixed(2) : null;\n  const em5d_abs = (em5d_pct!=null) ? +((last.close*(em5d_pct/100))).toFixed(2) : null;\n\n  // ATR(14)\n  const trs = trueRanges(prices);\n  const atr14 = trs.length>=14 ? +(avg(trs.slice(-14))?.toFixed(4)) : null;\n  const atrPct = (atr14!=null && last.close) ? +((atr14/last.close)*100).toFixed(2) : null;\n\n  // Bollinger (20, 2\u03c3)\n  const closes = prices.map(p=>p.close);\n  const last20Closes = closes.slice(-20);\n  const bbMid = (last20Closes.length===20) ? +(avg(last20Closes).toFixed(2)) : null;\n  const bbStd = (last20Closes.length===20) ? stddev(last20Closes) : null;\n  const bbUpper = (bbMid!=null && bbStd!=null) ? +(bbMid + 2*bbStd).toFixed(2) : null;\n  const bbLower = (bbMid!=null && bbStd!=null) ? +(bbMid - 2*bbStd).toFixed(2) : null;\n  const bbWidthPct = (bbUpper!=null && bbLower!=null && bbMid) ? +(((bbUpper-bbLower)/bbMid)*100).toFixed(2) : null;\n  let bbPos = null;\n  if (bbUpper!=null && bbLower!=null && (bbUpper-bbLower)!==0) {\n    bbPos = +(((last.close - bbLower)/(bbUpper - bbLower))).toFixed(2); // 0..1\n  }\n\n  // 52-week stats (use highs/lows if available, else closes)\n  const lookback = Math.min(prices.length, 252);\n  const highs = prices.slice(-lookback).map(p=>p.high ?? p.close);\n  const lows  = prices.slice(-lookback).map(p=>p.low  ?? p.close);\n  const hi52 = Math.max(...highs.filter(v=>v!=null));\n  const lo52 = Math.min(...lows.filter(v=>v!=null));\n  const distHiPct = (hi52 && last.close) ? +(((last.close-hi52)/hi52)*100).toFixed(2) : null; // negative if below high\n  const distLoPct = (lo52 && last.close) ? +(((last.close-lo52)/lo52)*100).toFixed(2) : null; // positive if above low\n  const range52 = (hi52!=null && lo52!=null) ? (hi52-lo52) : null;\n  const pctile52 = (range52 && range52!==0) ? +(((last.close - lo52)/range52).toFixed(2)) : null; // 0..1\n\n  // RVOL\n  const vols = prices.map(p=>p.volume).filter(v=>v!=null);\n  const avgVol10 = vols.length>=10 ? avg(vols.slice(-10)) : null;\n  const avgVol20 = vols.length>=20 ? avg(vols.slice(-20)) : null;\n  const rvol10 = (avgVol10 && last.volume!=null) ? +((last.volume/avgVol10)).toFixed(2) : null;\n\n  // DXY quality warning\n  const warnings = [];\n  if (sym==='DX-Y.NYB' && last200!=null) {\n    const dev = Math.abs((last.close - last200)/last200);\n    if (dev > 0.12) warnings.push('DXY_series_mismatch_consider_DX=F_or_UUP');\n  }\n\n  const units = YIELD_TICKERS.has(sym) ? 'yield_pct' : 'price';\n\n  results.push({\n    json: {\n      index: name,\n      symbol: sym,\n      units,\n      date: last.date,\n      currentPrice: +last.close.toFixed(2),\n      analysis: {\n        overallTrend: overall, shortTerm, longTerm, signal,\n        marketStrength: strength, referenceMA: refLabel, priceVsRefMA: distPct\n      },\n      movingAverages: { sma10:last10, sma20:last20, sma50:last50, sma200:last200, ema20:lastE20 },\n      technicals: {\n        priceAboveSMA20: last20!=null ? last.close > last20 : null,\n        priceAboveSMA50: last50!=null ? last.close > last50 : null,\n        priceAboveSMA200: last200!=null ? last.close > last200 : null,\n        sma20AboveSMA50: (last20!=null && last50!=null) ? last20>last50 : null,\n        sma50AboveSMA200: (last50!=null && last200!=null) ? last50>last200 : null\n      },\n      performance: { dailyChange, weeklyChange, monthlyChange },\n      optionsMetrics: {\n        hv20_pct: hv20, hv60_pct: hv60,\n        expectedMove_1d_pct: em1d_pct, expectedMove_5d_pct: em5d_pct,\n        expectedMove_1d_abs: em1d_abs, expectedMove_5d_abs: em5d_abs,\n        atr14: atr14, atrPct,\n        bollinger20: { mid: bbMid, upper: bbUpper, lower: bbLower, widthPct: bbWidthPct, position01: bbPos },\n        rvol10: rvol10, avgVol20: avgVol20!=null? +avgVol20.toFixed(0): null,\n        distTo52wHighPct: distHiPct, distTo52wLowPct: distLoPct, pctile52w_0to1: pctile52\n      },\n      meta: {\n        bars: prices.length,\n        nameFromMeta: res.meta?.longName || res.meta?.shortName || null,\n        rangeSufficientFor200: prices.length >= 200,\n        warnings: warnings.length ? warnings : null\n      }\n    }\n  });\n}\n\nreturn results.length\n  ? results\n  : [{ json: { error: 'NO_DATA', hint: 'Ensure URL uses encodeURIComponent(symbol), range >= 1y, items under .json, and handle chart.error.' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        992
      ],
      "id": "2ef3699c-ab3b-4182-b273-31dd3b6bcdad",
      "name": "Market Techicals"
    },
    {
      "parameters": {
        "url": "https://www.investing.com/rss/news_14.rss",
        "options": {}
      },
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        2560,
        720
      ],
      "id": "f12d59ec-4d88-4659-b8f0-9e70689012da",
      "name": "Investing.com",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://www.federalreserve.gov/feeds/press_all.xml",
        "options": {}
      },
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        2560,
        960
      ],
      "id": "961401f1-0a30-4d86-8553-3bc24cac86b5",
      "name": "Fed News",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1600,
        -1872
      ],
      "id": "b8100aa9-147c-4d7a-8a2d-769f9219ece4",
      "name": "Merge2"
    },
    {
      "parameters": {
        "model": "sonar",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "simplify": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Simplify_Output', ``, 'boolean') }}",
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        4816,
        32
      ],
      "id": "df5748d4-c1bc-47b6-996f-07c8daa60250",
      "name": "Perplxity Search",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1808,
        -1888
      ],
      "id": "2a1e6a9d-61f2-4f73-b031-ffc07a89d5b5",
      "name": "Merge3"
    },
    {
      "parameters": {
        "url": "={{\"https://query1.finance.yahoo.com/v8/finance/chart/\" + $json.symbol}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 10
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1504,
        624
      ],
      "id": "0a4bae6b-e3b4-480d-8d90-b05cac70a22f",
      "name": "Current Price1"
    },
    {
      "parameters": {
        "jsCode": "// Node: \"Parse & Filter Options (General DTE)\"\n// Takes Alpaca option snapshot responses and emits contracts ready for CandidateGen\n\nconst DTE_MIN = 1;        // keep broad; CandidateGen will rank\nconst DTE_MAX = 60;\nconst BA_MAX  = 0.60;     // relaxed cap; CG will tighten per regime\nconst OI_MIN  = 1;        // keep contracts that at least have some OI\n\nconst alpacaResponses = $input.all();\nconst now = new Date();\nconst filteredOptions = [];\n\nfunction isMonthlyFriday(expISO) {\n  const d = new Date(expISO + \"T00:00:00Z\");\n  // Friday between 15\u201321\n  return d.getUTCDay() === 5 && d.getUTCDate() >= 15 && d.getUTCDate() <= 21;\n}\n\nfor (const response of alpacaResponses) {\n  const data = response.json || response;\n  const snapshots = data.snapshots || data;\n\n  for (const [optionSymbol, snapshot] of Object.entries(snapshots)) {\n    if (!snapshot || (!snapshot.latestQuote && !snapshot.dailyBar)) continue;\n\n    // OPRA: ROOT YY MM DD C/P STRIKE(8)\n    // allow dots in root (e.g., BRK.B)\n    const m = optionSymbol.match(/^([A-Z.]+)(\\d{2})(\\d{2})(\\d{2})([CP])(\\d{8})$/);\n    if (!m) continue;\n\n    const [, root, yy, mm, dd, cp, strikeRaw] = m;\n    const underlying = root.replace(/\\.$/, ''); // normalize trailing dot if any\n    const expiration = `20${yy}-${mm}-${dd}`;\n\n    // DTE anchored to ~4pm ET via 20:00Z (handles EST/EDT without DST math)\n    const expAtCloseUTC = new Date(`${expiration}T20:00:00Z`);\n    const dte = Math.ceil((expAtCloseUTC - now) / 86400000);\n    if (dte < DTE_MIN || dte > DTE_MAX) continue;\n\n    // Quotes first: prefer latestQuote; fall back to dailyBar open/close\n    const bp = snapshot.latestQuote?.bp ?? snapshot.dailyBar?.o ?? 0;\n    const ap = snapshot.latestQuote?.ap ?? snapshot.dailyBar?.c ?? 0;\n    const mid = (bp > 0 && ap > 0) ? (bp + ap) / 2 : (snapshot.latestTrade?.p ?? snapshot.dailyBar?.vw ?? 0);\n    if (mid <= 0) continue;\n\n    const baPct = (bp > 0 && ap > 0) ? (ap - bp) / Math.max(0.01, mid) : 0.99;\n    if (baPct > BA_MAX) continue; // let CG do the finer-grained culling\n\n    // Volume / OI\n    const volume = snapshot.dailyBar?.v ?? snapshot.latestTrade?.s ?? 0;\n    const openInterest = snapshot.openInterest ?? 0;\n    if (volume === 0 && openInterest < OI_MIN) continue;\n\n    // Greeks & IV\n    const greeks = snapshot.greeks || {};\n    const iv =\n      snapshot.impliedVolatility ??\n      greeks.impliedVolatility ??\n      greeks.implied_volatility ??\n      null; // let CG fallback if null\n\n    filteredOptions.push({\n      json: {\n        // Identifiers\n        ticker: optionSymbol,\n        underlying,\n\n        // Contract details (CandidateGen expects this shape)\n        details: {\n          ticker: optionSymbol,\n          contract_type: cp === 'C' ? 'call' : 'put',\n          expiration_date: expiration,\n          strike_price: parseInt(strikeRaw, 10) / 1000,\n          exercise_style: 'american',\n          shares_per_contract: 100\n        },\n\n        // Normalize a top-level standardized type too (helps downstream filters)\n        type: cp === 'C' ? 'CALL' : 'PUT',\n\n        // Real quotes (quotes-first, not derived from bar range)\n        bid: +bp.toFixed(3),\n        ask: +ap.toFixed(3),\n        mid: +mid.toFixed(3),\n        baPct: +baPct.toFixed(4),\n\n        // Day payload (align CG's BA estimator by setting high/low to ask/bid)\n        day: {\n          bid: bp,\n          ask: ap,\n          close: snapshot.latestTrade?.p ?? mid,\n          open: snapshot.dailyBar?.o ?? mid,\n          high: ap, // <-- force BA inference to use quotes\n          low:  bp, // <--\n          volume,\n          vwap: snapshot.dailyBar?.vw ?? mid,\n          c: snapshot.dailyBar?.c ?? (snapshot.latestTrade?.p ?? mid),\n          change: snapshot.dailyBar ? (snapshot.dailyBar.c - snapshot.dailyBar.o) : 0,\n          change_percent:\n            (snapshot.dailyBar && snapshot.dailyBar.o > 0)\n              ? ((snapshot.dailyBar.c - snapshot.dailyBar.o) / snapshot.dailyBar.o) * 100\n              : 0\n        },\n\n        // Greeks (pass through if present)\n        greeks: {\n          delta: greeks.delta ?? null,\n          gamma: greeks.gamma ?? null,\n          theta: greeks.theta ?? null,\n          vega:  greeks.vega  ?? null,\n          rho:   greeks.rho   ?? null,\n          implied_volatility: iv\n        },\n\n        // Flat IV for convenience (CandidateGen reads either)\n        implied_volatility: iv ?? 0.40,\n\n        // Liquidity\n        open_interest: openInterest,\n        volume,\n\n        // Meta\n        dte,\n        monthly: isMonthlyFriday(expiration),\n        underlying_asset: { ticker: underlying },\n        lastUpdated: snapshot.latestQuote?.t ?? new Date().toISOString(),\n        hasRealQuotes: true,\n        source: 'alpaca'\n      }\n    });\n  }\n}\n\n// Sort by DTE, then volume, then OI\nfilteredOptions.sort((a, b) => {\n  if (a.json.dte !== b.json.dte) return a.json.dte - b.json.dte;\n  if ((b.json.volume || 0) !== (a.json.volume || 0)) return (b.json.volume || 0) - (a.json.volume || 0);\n  return (b.json.open_interest || 0) - (a.json.open_interest || 0);\n});\n\nconsole.log(`Filtered to ${filteredOptions.length} options (DTE ${DTE_MIN}-${DTE_MAX})`);\n\n// Summary\nfilteredOptions.push({\n  json: {\n    summary: {\n      type: 'filter_summary',\n      totalOptions: filteredOptions.length,\n      dteRange: `${DTE_MIN}-${DTE_MAX}`,\n      timestamp: new Date().toISOString(),\n      byUnderlying: filteredOptions.reduce((acc, opt) => {\n        const sym = opt.json.underlying;\n        if (sym) acc[sym] = (acc[sym] || 0) + 1;\n        return acc;\n      }, {})\n    }\n  }\n});\n\nreturn filteredOptions;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        96
      ],
      "id": "4b9309a6-0a12-4101-a122-37825cdab95d",
      "name": "Parse Contracts"
    },
    {
      "parameters": {
        "url": "=https://data.alpaca.markets/v1beta1/options/snapshots/{{ $json.symbol }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1520,
        96
      ],
      "id": "f53c2c6b-bcd1-449d-b2ff-987f9d8d9505",
      "name": "Alpaca Options",
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Function Node \u2014 TA Scanner v4.2 (HV floor + Regime-aware S1AD + OWG tweaks)\n *\n * Yahoo Finance Input: 60d, 1h interval (SPY must be included in the upstream universe)\n * Output: Top 15 BULLISH + Top 10 BEARISH (prefers option-worthy names, with fallbacks)\n *\n * Features:\n * - Stage-1 Accumulation Detection (S1AD) \u2014 finds stocks BEFORE they move (regime-aware gates)\n * - Option Worthiness Gate (OWG) \u2014 filters for weekly options tradability (tweaked thresholds)\n * - Robust Volatility & Expected Moves \u2014 floors HV by ATR-derived sigma to avoid under-reporting\n * - Gap Risk Analysis \u2014 avoids gap-prone stocks\n * - Market Regime Detection \u2014 adjusts thresholds by market conditions\n * - Relative Strength vs SPY \u2014 identifies leadership\n * - Demotes \u201calready moving\u201d setups \u2014 focuses on early entries\n *\n * For Weekly Options - Daily Trading\n */\n\nconst EMIT_LEADERBOARD = true;\nconst TOP_BULLS = 15;\nconst TOP_BEARS = 10;\nconst VERSION = '4.2-HVfloor-S1ADregime-OWGtweak';\n\n/* =====================  CORE HELPERS  ===================== */\n\nfunction num(x, d=2){ return (x==null || !Number.isFinite(x)) ? null : +x.toFixed(d); }\nconst clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));\nconst nz = (x, v=0) => (Number.isFinite(x) ? x : v);\n\nconst lastDefined = (arr) => {\n  if (!arr) return null;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const v = arr[i];\n    if (v != null && Number.isFinite(v)) return v;\n  }\n  return null;\n};\n\nconst avg = (arr) => {\n  const valid = (arr || []).filter(x => Number.isFinite(x));\n  return valid.length ? valid.reduce((a,b)=>a+b,0) / valid.length : null;\n};\n\nconst median = (arr) => {\n  const valid = (arr || []).filter(x => Number.isFinite(x));\n  if (!valid.length) return null;\n  const sorted = valid.sort((a, b) => a - b);\n  const mid = Math.floor(sorted.length / 2);\n  return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;\n};\n\nconst sma = (arr, period) => {\n  if (!arr || arr.length < period) return [];\n  const out = []; let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (i >= period) sum -= arr[i - period];\n    if (i >= period - 1) out.push(sum / period);\n  }\n  return out;\n};\n\nconst smaSeries = (arr, period) => {\n  const n = arr?.length ?? 0, out = Array(n).fill(undefined);\n  if (n < period) return out;\n  let sum = 0, q = [];\n  for (let i = 0; i < n; i++) {\n    const v = arr[i];\n    if (!(Number.isFinite(v))) { q = []; sum = 0; continue; }\n    q.push(v); sum += v;\n    if (q.length > period) sum -= q.shift();\n    if (q.length === period) out[i] = sum / period;\n  }\n  return out;\n};\n\nconst emaSeeded = (arr, period) => {\n  const n = arr?.length ?? 0;\n  if (!arr || n < period) return Array(n).fill(undefined);\n  const k = 2 / (period + 1);\n  const out = Array(n).fill(undefined);\n  let prev = arr.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  out[period - 1] = prev;\n  for (let i = period; i < n; i++) {\n    prev = arr[i] * k + prev * (1 - k);\n    out[i] = prev;\n  }\n  return out;\n};\n\nconst rollingMax = (arr, p) => {\n  const n = arr.length, out = Array(n).fill(undefined);\n  for (let i = p - 1; i < n; i++) out[i] = Math.max(...arr.slice(i - p + 1, i + 1));\n  return out;\n};\n\nconst rollingMin = (arr, p) => {\n  const n = arr.length, out = Array(n).fill(undefined);\n  for (let i = p - 1; i < n; i++) out[i] = Math.min(...arr.slice(i - p + 1, i + 1));\n  return out;\n};\n\nconst trueRange = (h, l, prevClose) => Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));\n\nconst atr = (highs, lows, closes, period = 14) => {\n  if (!highs || !lows || !closes || highs.length < period + 1) return null;\n  const trs = [];\n  for (let i = 1; i < highs.length; i++) trs.push(trueRange(highs[i], lows[i], closes[i - 1]));\n  let out = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  for (let i = period; i < trs.length; i++) out = (out * (period - 1) + trs[i]) / period;\n  return out;\n};\n\nconst calcRSI = (closes, period = 14) => {\n  if (!closes || closes.length < period + 1) return 50;\n  let gain = 0, loss = 0;\n  for (let i = 1; i <= period; i++) {\n    const ch = closes[i] - closes[i - 1];\n    if (ch > 0) gain += ch; else loss -= ch;\n  }\n  let avgGain = gain / period, avgLoss = loss / period;\n  for (let i = period + 1; i < closes.length; i++) {\n    const ch = closes[i] - closes[i - 1];\n    avgGain = (avgGain * (period - 1) + (ch > 0 ? ch : 0)) / period;\n    avgLoss = (avgLoss * (period - 1) + (ch < 0 ? -ch : 0)) / period;\n  }\n  if (avgLoss === 0) return 100;\n  const rs = avgGain / avgLoss;\n  return 100 - 100 / (1 + rs);\n};\n\nconst calcMACD = (closes, fastLen = 12, slowLen = 26, sigLen = 9) => {\n  const n = closes?.length ?? 0;\n  if (n < slowLen + sigLen) {\n    return { macdLine: null, signal: null, histogram: null, prevHistogram: null, histogramEff: null };\n  }\n  const emaFast = emaSeeded(closes, fastLen);\n  const emaSlow = emaSeeded(closes, slowLen);\n  const macdArr = [];\n  for (let i = slowLen - 1; i < n; i++) macdArr.push(emaFast[i] - emaSlow[i]);\n  const signalArr = emaSeeded(macdArr, sigLen);\n  const macdLine = macdArr[macdArr.length - 1];\n  const signal = signalArr[signalArr.length - 1];\n  const histogram = macdLine - signal;\n  const prevHistogram = (macdArr.length >= 2 && signalArr.length >= 2)\n    ? (macdArr[macdArr.length - 2] - signalArr[signalArr.length - 2])\n    : null;\n  return {\n    macdLine, signal, histogram, prevHistogram, histogramEff: histogram\n  };\n};\n\nconst calcHistoricalVolatility = (closes, period = 20) => {\n  if (!closes || closes.length < period + 1) return 25;\n  const rets = [];\n  for (let i = 1; i < closes.length; i++) {\n    const c0 = closes[i - 1], c1 = closes[i];\n    if (Number.isFinite(c0) && Number.isFinite(c1) && c0 > 0 && c1 > 0) {\n      rets.push(Math.log(c1 / c0));\n    }\n  }\n  const recent = rets.slice(-period);\n  if (!recent.length) return 25;\n  const mean = recent.reduce((a, b) => a + b, 0) / recent.length;\n  const varp = recent.reduce((s, r) => s + Math.pow(r - mean, 2), 0) / recent.length;\n  return Math.sqrt(varp * 252) * 100;\n};\n\n// ATR-derived HV floor to avoid under-reporting HV/EMs\nconst hvFromATR = (price, atrVal, k = 0.8) => {\n  if (!Number.isFinite(price) || !Number.isFinite(atrVal) || price <= 0) return null;\n  return (atrVal / price) * 100 * Math.sqrt(252) * k;\n};\n\nconst calcBollinger = (closes, period = 20, stdDev = 2) => {\n  if (!closes || closes.length < period) {\n    return { upper: null, middle: null, lower: null, bandwidth: null };\n  }\n  const window = closes.slice(-period);\n  const mid = window.reduce((a, b) => a + b, 0) / period;\n  const denom = Math.max(1, period - 1);\n  const variance = window.reduce((s, x) => s + Math.pow(x - mid, 2), 0) / denom;\n  const std = Math.sqrt(variance);\n  const upper = mid + stdDev * std;\n  const lower = mid - stdDev * std;\n  const bandwidth = mid !== 0 ? ((upper - lower) / mid) * 100 : null;\n  return { upper, middle: mid, lower, bandwidth };\n};\n\nconst momentumPct = (closes, nBack) => {\n  const L = closes?.length ?? 0;\n  if (!L || L <= nBack) return null;\n  const cur = closes[L - 1], ref = closes[L - 1 - nBack];\n  if (!ref) return null;\n  return ((cur - ref) / ref) * 100;\n};\n\n/* =====================  S1AD HELPERS  ===================== */\n\nfunction relStrengthSlope(assetCloses, benchCloses, lookback = 20) {\n  if (!assetCloses || !benchCloses || assetCloses.length < lookback + 2 || benchCloses.length < lookback + 2) return 0;\n  const n = assetCloses.length;\n  const rs = [];\n  for (let i = n - lookback - 1; i < n; i++) {\n    if (i < 1) continue;\n    const a = assetCloses[i] / assetCloses[i - 1];\n    const b = benchCloses[i] / benchCloses[i - 1];\n    if (!Number.isFinite(a) || !Number.isFinite(b) || b === 0) continue;\n    rs.push(Math.log(a / b));\n  }\n  return rs.length ? +rs.reduce((a, b) => a + b, 0).toFixed(4) : 0;\n}\n\nfunction adLine(highs, lows, closes, vols, lookback = 20) {\n  if (!highs || !lows || !closes || !vols) return { ad: 0, slope: 0 };\n  let ad = 0;\n  const hist = [];\n  for (let i = 0; i < closes.length; i++) {\n    const h = highs[i], l = lows[i], c = closes[i], v = vols[i] || 0;\n    const mfm = (h === l) ? 0 : ((c - l) - (h - c)) / (h - l);\n    ad += mfm * v;\n    hist.push(ad);\n  }\n  const L = hist.length;\n  if (L < lookback + 2) return { ad, slope: 0 };\n  const slope = hist.slice(-lookback).reduce((a, b, i, arr) => a + (i ? b - arr[i - 1] : 0), 0);\n  return { ad, slope };\n}\n\nfunction obvSlope(closes, vols, lookback = 20) {\n  if (!closes || !vols || closes.length < lookback + 2) return 0;\n  let obv = 0;\n  const hist = [];\n  for (let i = 1; i < closes.length; i++) {\n    if (closes[i] > closes[i - 1]) obv += vols[i] || 0;\n    else if (closes[i] < closes[i - 1]) obv -= vols[i] || 0;\n    hist.push(obv);\n  }\n  if (hist.length < lookback + 1) return 0;\n  return hist.slice(-lookback).reduce((a, b, i, arr) => a + (i ? b - arr[i - 1] : 0), 0);\n}\n\nfunction volumeDryUp(vols, shortWin = 5, longWin = 20) {\n  if (!vols || vols.length < longWin) return { ratio: 1, score: 0 };\n  const avgS = avg(vols.slice(-shortWin));\n  const avgL = avg(vols.slice(-longWin));\n  const ratio = avgL ? (avgS / avgL) : 1;\n  const score = ratio <= 0.5 ? 40 : ratio <= 0.65 ? 28 : ratio <= 0.8 ? 15 : 0;\n  return { ratio: +ratio.toFixed(2), score };\n}\n\nfunction bbSqueezePct(closes, period = 20, stdDev = 2) {\n  const bb = calcBollinger(closes, period, stdDev);\n  if (!bb.bandwidth || !closes?.length) return { pct: null, score: 0 };\n  const pct = bb.bandwidth;\n  const score = (pct < 2.0) ? 35 : (pct < 3.0) ? 25 : (pct < 4.0) ? 12 : 0;\n  return { pct: +pct.toFixed(2), score };\n}\n\nfunction clvPersistence(highs, lows, closes, lookback = 10) {\n  if (!highs || !lows || !closes || closes.length < lookback) return { ratio: 0, score: 0 };\n  let pos = 0, cnt = 0;\n  for (let i = closes.length - lookback; i < closes.length; i++) {\n    const H = highs[i], L = lows[i], C = closes[i];\n    const clv = (H === L) ? 0 : ((C - L) - (H - C)) / (H - L);\n    if (clv > 0) pos++;\n    cnt++;\n  }\n  const ratio = cnt ? pos / cnt : 0;\n  const score = ratio >= 0.7 ? 15 : ratio >= 0.6 ? 8 : 0;\n  return { ratio: +ratio.toFixed(2), score };\n}\n\nfunction proximityToAnchor(price, ema20, atrVal) {\n  if (!price || !ema20 || !atrVal) return { ok: false, score: 0, dist: null };\n  const dist = Math.abs(price - ema20);\n  const ok = dist <= Math.max(0.5 * atrVal, 0.006 * price);\n  return { ok, score: ok ? 10 : 0, dist: +dist.toFixed(2) };\n}\n\nfunction detectDivergence(closes, indicator, lookback = 10) {\n  if (!closes || !indicator || closes.length < lookback * 2) {\n    return { type: 'NONE', strength: 0 };\n  }\n\n  const priceSlice = closes.slice(-lookback);\n  const indicatorSlice = indicator.slice(-lookback);\n\n  const priceMin = Math.min(...priceSlice);\n  const priceMinIdx = priceSlice.indexOf(priceMin);\n  const indicatorAtPriceMin = indicatorSlice[priceMinIdx];\n\n  const currentIndicator = indicatorSlice[indicatorSlice.length - 1];\n  const currentPrice = priceSlice[priceSlice.length - 1];\n\n  if (currentPrice < priceMin * 1.02 && currentIndicator > indicatorAtPriceMin * 1.05) {\n    const strength = ((currentIndicator - indicatorAtPriceMin) / indicatorAtPriceMin) * 100;\n    return { type: 'BULLISH', strength: Math.min(30, strength) };\n  }\n\n  const priceMax = Math.max(...priceSlice);\n  const priceMaxIdx = priceSlice.indexOf(priceMax);\n  const indicatorAtPriceMax = indicatorSlice[priceMaxIdx];\n\n  if (currentPrice > priceMax * 0.98 && currentIndicator < indicatorAtPriceMax * 0.95) {\n    const strength = ((indicatorAtPriceMax - currentIndicator) / indicatorAtPriceMax) * 100;\n    return { type: 'BEARISH', strength: Math.min(30, strength) };\n  }\n\n  return { type: 'NONE', strength: 0 };\n}\n\nfunction detectFailedBreakouts(highs, closes, resistanceLevel, lookback = 30) {\n  if (!highs || !closes || !resistanceLevel) return { count: 0, penalty: 0, touches: 0 };\n  let failures = 0, consecutiveTouches = 0;\n  for (let i = highs.length - lookback; i < highs.length - 1; i++) {\n    if (i < 0) continue;\n    const touchedResistance = Math.abs(highs[i] - resistanceLevel) / resistanceLevel < 0.005;\n    if (touchedResistance) {\n      consecutiveTouches++;\n      if (closes[i] < resistanceLevel * 0.995) failures++;\n    } else {\n      consecutiveTouches = 0;\n    }\n  }\n  const penalty = failures >= 3 ? -25 : failures === 2 ? -15 : failures === 1 ? -8 : 0;\n  const touchPenalty = consecutiveTouches >= 5 ? -10 : 0;\n  return { count: failures, penalty: penalty + touchPenalty, touches: consecutiveTouches };\n}\n\nfunction calculateGapRisk(daily, lookback = 30) {\n  const { o: opens, c: closes } = daily;\n  if (!opens || !closes || opens.length < lookback + 1) {\n    return { acceptable: true, riskScore: 0, maxDownGap: 0, medianGap: 0 };\n  }\n\n  const gaps = [];\n  const downGaps = [];\n\n  for (let i = 1; i <= Math.min(lookback, opens.length - 1); i++) {\n    const idx = opens.length - i;\n    if (idx < 1) continue;\n    const prevClose = closes[idx - 1];\n    const nextOpen = opens[idx];\n    if (!prevClose || !nextOpen) continue;\n    const gapPct = ((nextOpen - prevClose) / prevClose) * 100;\n    gaps.push(Math.abs(gapPct));\n    if (nextOpen < prevClose) downGaps.push(Math.abs(gapPct));\n  }\n\n  const maxDownGap = downGaps.length ? Math.max(...downGaps) : 0;\n  const medianGap = median(gaps) || 0;\n  const gapFrequency = gaps.filter(g => g > 1.0).length / (gaps.length || 1);\n\n  let riskScore = 0;\n  if (maxDownGap > 3.0) riskScore += 40;\n  else if (maxDownGap > 2.0) riskScore += 25;\n  else if (maxDownGap > 1.5) riskScore += 15;\n\n  if (gapFrequency > 0.4) riskScore += 20;\n  if (medianGap > 1.5) riskScore += 15;\n\n  return {\n    maxDownGap: num(maxDownGap, 2),\n    medianGap: num(medianGap, 2),\n    riskScore,\n    acceptable: riskScore < 50\n  };\n}\n\n// Regime- & liquidity-aware S1AD\nfunction buildS1AD(ctx) {\n  const { price, atrVal, ema20, daily, benchCloses, regime = 'RANGE' } = ctx;\n\n  const squeeze = bbSqueezePct(daily.c, 20, 2);\n  const vdi = volumeDryUp(daily.v, 5, 20);\n  const { slope: adSlope } = adLine(daily.h, daily.l, daily.c, daily.v, 20);\n  const obvS = obvSlope(daily.c, daily.v, 20);\n  const clv = clvPersistence(daily.h, daily.l, daily.c, 10);\n  const prox = proximityToAnchor(price, ema20, atrVal);\n  const rs = benchCloses ? relStrengthSlope(daily.c, benchCloses, 20) : 0;\n\n  const adv20 = avg(daily.v.slice(-20)) || 0;\n\n  const squeezeLimit = ({\n    BULL_QUIET: 4.0,\n    RANGE: 3.5,\n    BULL_VOLATILE: 3.0,\n    CHOP: 3.0,\n    BEAR: 2.8\n  }[regime]) || 3.5;\n\n  let dryLimit = 0.75;\n  if (adv20 >= 2_000_000) dryLimit = 0.85; // liquid names need less dramatic dry-up\n  if (price >= 80) dryLimit = Math.max(dryLimit, 0.80);\n\n  const hasCompression = squeeze.pct != null && squeeze.pct < squeezeLimit;\n  const hasDryUp = vdi.ratio <= dryLimit;\n  const hasAnchor = prox.ok;\n\n  if (!hasCompression || !hasDryUp || !hasAnchor) {\n    return {\n      score: 0,\n      quality: 'FAIL',\n      reason: `GATES: compression=${hasCompression}, dryup=${hasDryUp} (limit=${dryLimit}), anchor=${hasAnchor}`,\n      components: { squeeze, vdi, prox }\n    };\n  }\n\n  let base = 40;\n  if (squeeze.pct < 2.0) base *= 1.4;\n  if (vdi.ratio <= 0.50) base *= 1.3;\n\n  let conviction = 0;\n  if (adSlope > 0) conviction += 12;\n  if (obvS > 0) conviction += 12;\n  if (clv.ratio >= 0.65) conviction += 8;\n  if (rs > 0.005) conviction += 15;\n  else if (rs > 0) conviction += 8;\n\n  let divBonus = 0;\n  // (Optional divergence hook: pass rsiArray in ctx if you compute it elsewhere)\n  if (ctx.rsiArray) {\n    const div = detectDivergence(daily.c, ctx.rsiArray, 15);\n    if (div.type === 'BULLISH') divBonus += Math.min(30, div.strength);\n    ctx._divergence = div;\n  }\n\n  const resist = Math.max(...daily.h.slice(-20));\n  const fb = detectFailedBreakouts(daily.h, daily.c, resist, 30);\n  const penalty = fb.penalty;\n\n  let finalScore = Math.round(base + conviction + divBonus + penalty);\n  finalScore = clamp(finalScore, 0, 100);\n\n  const quality = finalScore >= 75 ? 'A+' :\n                  finalScore >= 65 ? 'A' :\n                  finalScore >= 55 ? 'B+' : 'B';\n\n  return {\n    score: finalScore,\n    quality,\n    components: {\n      squeezePct: squeeze.pct,\n      dryUp: vdi.ratio,\n      anchorDist: prox.dist,\n      adSlope,\n      obvSlope: obvS,\n      clvUp: clv.ratio,\n      rsSlope: rs,\n      failedBreakouts: fb.count,\n      divergence: ctx._divergence\n    }\n  };\n}\n\n/* =====================  FAST INDICATORS (1-5 DAY)  ===================== */\n\nconst tightCoil = (highs, lows, closes, period = 5) => {\n  if (!highs || highs.length < period * 2) return { quality: 'C', score: 0, readiness: 'EARLY', bearReadiness: 'EARLY', atApex: false, atLow: false };\n\n  const ranges = highs.map((h, i) => h - lows[i]);\n  const recentRanges = ranges.slice(-period);\n  const earlierRanges = ranges.slice(-period * 2, -period);\n\n  const avgRecent = avg(recentRanges);\n  const avgEarlier = avg(earlierRanges);\n\n  if (!avgRecent || !avgEarlier) return { quality: 'C', score: 0, readiness: 'EARLY', bearReadiness: 'EARLY', atApex: false, atLow: false };\n\n  const contractionRatio = avgRecent / avgEarlier;\n  const price = closes[closes.length - 1];\n  const tightDays = recentRanges.filter(r => (r / price) < 0.015).length;\n  const recentHigh = Math.max(...highs.slice(-period));\n  const recentLow = Math.min(...lows.slice(-period));\n  const atApex = (price >= recentHigh * 0.98);\n  const atLow = (price <= recentLow * 1.02);\n\n  let quality = 'C', score = 0;\n  if (contractionRatio < 0.35 && tightDays >= 3) { quality = 'A+'; score = 100; }\n  else if (contractionRatio < 0.45 && tightDays >= 2) { quality = 'A'; score = 85; }\n  else if (contractionRatio < 0.55) { quality = 'B+'; score = 70; }\n  else if (contractionRatio < 0.65) { quality = 'B'; score = 55; }\n  else { quality = 'C'; score = 30; }\n\n  let readiness = 'EARLY';\n  if (atApex && score >= 85) readiness = 'READY';\n  else if (atApex && score >= 70) readiness = 'FORMING';\n  else if (score >= 70) readiness = 'COILING';\n\n  let bearReadiness = 'EARLY';\n  if (atLow && score >= 85) bearReadiness = 'READY';\n  else if (atLow && score >= 70) bearReadiness = 'FORMING';\n\n  return { quality, score, readiness, bearReadiness, atApex, atLow };\n};\n\nconst rapidVolumeAccel = (volumes, period = 3) => {\n  if (!volumes || volumes.length < period * 3) return { type: 'Flat', acceleration: 1.0, quality: 'C' };\n\n  const now = volumes.slice(-period);\n  const recent = volumes.slice(-period * 2, -period);\n  const earlier = volumes.slice(-period * 3, -period * 2);\n\n  const avgNow = avg(now);\n  const avgRecent = avg(recent);\n  const avgEarlier = avg(earlier);\n\n  if (!avgNow || !avgRecent) return { type: 'Flat', acceleration: 1.0, quality: 'C' };\n\n  const accel1 = avgNow / avgRecent;\n\n  const progressive = (accel1 >= 1.25) && (avgRecent / (avgEarlier || 1)) >= 1.15;\n  const explosive = (accel1 >= 2.5);\n  const building = (accel1 >= 1.3) && (accel1 < 2.0);\n  const drying = (accel1 < 0.7);\n  const surging = (accel1 >= 1.5) && (accel1 < 2.5);\n\n  let type = 'Flat', quality = 'C';\n  if (progressive) { type = 'Progressive'; quality = 'A+'; }\n  else if (building) { type = 'Building'; quality = 'A'; }\n  else if (drying) { type = 'Drying'; quality = 'A-'; }\n  else if (surging) { type = 'Surging'; quality = 'B+'; }\n  else if (explosive) { type = 'Explosive'; quality = 'B'; }\n  else if (accel1 > 1.1) { type = 'Rising'; quality = 'B-'; }\n\n  return { type, acceleration: num(accel1, 2), quality };\n};\n\nconst intradayMomentumBurst = (hourly) => {\n  const { c: closes, v: volumes } = hourly;\n  if (!closes || closes.length < 30) return { signal: 'WAIT', bullStrength: 0, bearStrength: 0 };\n\n  const last = arr => arr[arr.length - 1];\n  const price = last(closes);\n  const last4h = closes.slice(-4);\n  const prior8h = closes.slice(-12, -4);\n\n  const chg4h = ((last(last4h) - last4h[0]) / last4h[0]) * 100;\n  const chg8h = ((last(prior8h) - prior8h[0]) / prior8h[0]) * 100;\n\n  const vol4h = avg(volumes.slice(-4));\n  const vol8h = avg(volumes.slice(-12, -4));\n  const volRatio = (vol8h && vol8h !== 0) ? vol4h / vol8h : 1;\n\n  const accelerating = (chg4h > 0) && (chg4h > Math.abs(chg8h) * 1.4);\n  const decelerating = (chg4h < 0) && (Math.abs(chg4h) > Math.abs(chg8h) * 1.4);\n  const volumeConfirm = volRatio >= 1.35;\n\n  const ema5 = last(emaSeeded(closes, 5));\n  const ema13 = last(emaSeeded(closes, 13));\n  const ema21 = last(emaSeeded(closes, 21));\n  const bullAligned = (ema5 > ema13) && (ema13 > ema21);\n  const bearAligned = (ema5 < ema13) && (ema13 < ema21);\n\n  const aboveAll = price > ema5 && price > ema13 && price > ema21;\n  const belowAll = price < ema5 && price < ema13 && price < ema21;\n\n  let bullStrength = 0, bearStrength = 0;\n\n  if (accelerating) bullStrength += 4;\n  if (volumeConfirm) bullStrength += 3;\n  if (bullAligned) bullStrength += 2;\n  if (aboveAll) bullStrength += 1;\n  if (chg4h > 1.5) bullStrength += 1;\n\n  if (decelerating) bearStrength += 4;\n  if (volumeConfirm) bearStrength += 3;\n  if (bearAligned) bearStrength += 2;\n  if (belowAll) bearStrength += 1;\n  if (chg4h < -1.5) bearStrength += 1;\n\n  let signal = 'WAIT';\n  if (bullStrength >= 7) signal = 'GO_BULL';\n  else if (bullStrength >= 5) signal = 'WATCH_BULL';\n  else if (bearStrength >= 7) signal = 'GO_BEAR';\n  else if (bearStrength >= 5) signal = 'WATCH_BEAR';\n\n  return { signal, bullStrength, bearStrength };\n};\n\nconst breakoutProximity = (daily, hourly) => {\n  const { c: dc, h: dh, l: dl } = daily;\n  const { c: hc } = hourly;\n\n  if (!dc || !dh || dc.length < 20) return {\n    breaking_up: false,\n    breaking_down: false,\n    imminent_up: false,\n    imminent_down: false,\n    resistance: null,\n    support: null,\n    resistanceTouches: 0,\n    supportTouches: 0\n  };\n\n  const price = dc[dc.length - 1];\n  const resistance = Math.max(...dh.slice(-20));\n  const support = Math.min(...dl.slice(-20));\n  const distanceToPct = ((resistance - price) / price) * 100;\n  const distanceFromPct = ((price - support) / price) * 100;\n\n  let resistanceTouches = 0, supportTouches = 0;\n  const tolerance = 0.5;\n\n  if (hc && hc.length >= 20) {\n    for (let i = hc.length - 20; i < hc.length; i++) {\n      const distR = Math.abs(((hc[i] - resistance) / resistance) * 100);\n      const distS = Math.abs(((hc[i] - support) / support) * 100);\n      if (distR < tolerance) resistanceTouches++;\n      if (distS < tolerance) supportTouches++;\n    }\n  }\n\n  const breaking_up = price > resistance;\n  const breaking_down = price < support;\n  const imminent_up = (distanceToPct < 1.0) && (resistanceTouches >= 2);\n  const imminent_down = (distanceFromPct < 1.0) && (supportTouches >= 2);\n\n  return {\n    breaking_up, breaking_down, imminent_up, imminent_down,\n    resistance, support, resistanceTouches, supportTouches\n  };\n};\n\n/* =====================  EARLY WARNING SYSTEM  ===================== */\n\nconst earlyWarning = (coil, volAccel, intradayBurst, breakout, baseline, side = 'bull') => {\n  let prob = 0;\n\n  if (coil.quality === 'A+') prob += 30;\n  else if (coil.quality === 'A') prob += 25;\n  else if (coil.quality === 'B+') prob += 15;\n  else if (coil.quality === 'B') prob += 10;\n\n  if (side === 'bull' && coil.atApex) prob += 15;\n  else if (side === 'bear' && coil.atLow) prob += 15;\n  else if (side === 'bull' && coil.readiness === 'FORMING') prob += 10;\n  else if (side === 'bear' && coil.bearReadiness === 'FORMING') prob += 10;\n\n  if (volAccel.type === 'Progressive') prob += 20;\n  else if (volAccel.type === 'Building') prob += 16;\n  else if (volAccel.type === 'Surging') prob += 12;\n  else if (volAccel.type === 'Drying' && coil.score >= 70) prob += 10;\n  else if (volAccel.type === 'Explosive') prob += 8;\n\n  if (side === 'bull') {\n    if (intradayBurst.signal === 'GO_BULL') prob += 25;\n    else if (intradayBurst.signal === 'WATCH_BULL') prob += 15;\n    else if (intradayBurst.bullStrength >= 4) prob += 8;\n  } else {\n    if (intradayBurst.signal === 'GO_BEAR') prob += 25;\n    else if (intradayBurst.signal === 'WATCH_BEAR') prob += 15;\n    else if (intradayBurst.bearStrength >= 4) prob += 8;\n  }\n\n  if (side === 'bull') {\n    if (breakout.breaking_up) prob += 20;\n    else if (breakout.imminent_up) prob += 15;\n    else if (breakout.resistance && ((breakout.resistance - baseline.price) / baseline.price * 100) < 2) prob += 8;\n  } else {\n    if (breakout.breaking_down) prob += 20;\n    else if (breakout.imminent_down) prob += 15;\n    else if (breakout.support && ((baseline.price - breakout.support) / baseline.price * 100) < 2) prob += 8;\n  }\n\n  if ((breakout.breaking_up || breakout.breaking_down) && (volAccel.acceleration ?? 1) < 1.2) {\n    prob -= 15;\n  }\n\n  if (breakout.resistanceTouches >= 5 || breakout.supportTouches >= 5) {\n    prob -= 10;\n  }\n\n  if (volAccel.type === 'Explosive' && coil.score < 60) {\n    prob -= 10;\n  }\n\n  prob = clamp(prob, 0, 100);\n\n  let timeframe = '5+ days';\n  if (prob >= 75) timeframe = '0-2 days';\n  else if (prob >= 60) timeframe = '2-3 days';\n  else if (prob >= 45) timeframe = '3-5 days';\n\n  let urgency = 'LOW';\n  if (prob >= 70) urgency = 'ALERT';\n  else if (prob >= 50) urgency = 'WATCH';\n  else if (prob >= 30) urgency = 'EARLY';\n\n  return {\n    probability: +prob.toFixed(0),\n    timeframe,\n    urgency,\n    conviction: prob >= 70 ? 'HIGH' : prob >= 50 ? 'MEDIUM' : 'LOW'\n  };\n};\n\n/* =====================  DIRECTIONAL SCORING  ===================== */\n\nfunction scoreFastMoves(coil, volAccel, intradayBurst, breakout, baseline) {\n  let bull = 0, bear = 0;\n\n  const bullStr = intradayBurst?.bullStrength ?? 0;\n  const bearStr = intradayBurst?.bearStrength ?? 0;\n\n  if (bullStr >= 7) bull += 35;\n  else if (bullStr >= 5) bull += 20;\n  else if (bullStr >= 3) bull += 8;\n\n  if (bearStr >= 7) bear += 35;\n  else if (bearStr >= 5) bear += 20;\n  else if (bearStr >= 3) bear += 8;\n\n  if (coil.readiness === 'READY') bull += 25;\n  else if (coil.readiness === 'FORMING') bull += 18;\n  else if (coil.readiness === 'COILING') bull += 12;\n  else if (coil.score >= 70) bull += 8;\n\n  if (coil.bearReadiness === 'READY') bear += 25;\n  else if (coil.bearReadiness === 'FORMING') bear += 18;\n  else if (coil.score >= 70) bear += 8;\n\n  if (volAccel.type === 'Progressive') { bull += 20; bear += 20; }\n  else if (volAccel.type === 'Building') { bull += 16; bear += 16; }\n  else if (volAccel.type === 'Surging') { bull += 12; bear += 12; }\n  else if (volAccel.type === 'Drying' && coil.score >= 70) { bull += 10; bear += 10; }\n  else if (volAccel.type === 'Explosive') { bull += 6; bear += 6; }\n\n  if (breakout.breaking_up) bull += 20;\n  else if (breakout.imminent_up) bull += 15;\n\n  if (breakout.breaking_down) bear += 20;\n  else if (breakout.imminent_down) bear += 15;\n\n  const shortTrend = baseline.trend?.short;\n  const aligned = baseline.trend?.aligned;\n\n  if (aligned) {\n    if (shortTrend === 'up') bull += 15;\n    else if (shortTrend === 'down') bear += 15;\n  } else {\n    if (shortTrend === 'up') bull += 8;\n    else if (shortTrend === 'down') bear += 8;\n  }\n\n  if (breakout.breaking_up && breakout.resistanceTouches >= 5) bull -= 12;\n  if (breakout.breaking_down && breakout.supportTouches >= 5) bear -= 12;\n\n  if ((breakout.breaking_up || breakout.breaking_down) && (volAccel.acceleration ?? 1) < 1.15) {\n    bull -= 10; bear -= 10;\n  }\n\n  const rsi = baseline.rsi14 ?? 50;\n  if (rsi > 80) bull -= 8;\n  if (rsi < 20) bear -= 8;\n\n  const atrPct = baseline.atrPct ?? 0;\n  if (atrPct < 0.8) { bull -= 5; bear -= 5; }\n\n  bull = clamp(bull, 0, 100);\n  bear = clamp(bear, 0, 100);\n\n  return {\n    bullScore: +bull.toFixed(1),\n    bearScore: +bear.toFixed(1),\n    dirScore: +(bull - bear).toFixed(1)\n  };\n}\n\n/* =====================  MARKET REGIME DETECTION  ===================== */\n\nfunction detectMarketRegime(spyCloses) {\n  if (!spyCloses || spyCloses.length < 50) return 'RANGE';\n  const ema20 = lastDefined(emaSeeded(spyCloses, 20));\n  const ema50 = lastDefined(emaSeeded(spyCloses, 50));\n  const price = spyCloses[spyCloses.length - 1];\n  const hv = calcHistoricalVolatility(spyCloses, 10);\n\n  const trendUp = (price > ema20) && (ema20 > ema50);\n  const trendDown = (price < ema20) && (ema20 < ema50);\n  const highVol = hv > 25;\n\n  if (trendUp && !highVol) return 'BULL_QUIET';\n  if (trendUp && highVol) return 'BULL_VOLATILE';\n  if (trendDown) return 'BEAR';\n  if (highVol) return 'CHOP';\n  return 'RANGE';\n}\n\n/* =====================  PLAN A (BREAKOUT TRIGGER)  ===================== */\n\nfunction calculatePlanA(daily, coil, atr14, s1ad) {\n  const { h: highs, l: lows } = daily;\n  if (s1ad.score < 55) return null;\n\n  const compressionPeriod = 7;\n  const recentHighs = highs.slice(-compressionPeriod);\n  const recentLows = lows.slice(-compressionPeriod);\n\n  const pivot = Math.max(...recentHighs);\n  const base = Math.min(...recentLows);\n\n  const buffer = (s1ad.quality === 'A+' || s1ad.quality === 'A') ? 0.15 : 0.20;\n  const trigger = num(pivot + (buffer * atr14), 2);\n  const stop = num(base - (0.30 * atr14), 2);\n\n  const risk = trigger - stop;\n  const target1 = num(trigger + (1.5 * risk), 2);\n  const target2 = num(trigger + (2.0 * risk), 2);\n\n  return {\n    type: 'planA_breakoutStop',\n    trigger,\n    stop,\n    targets: [target1, target2],\n    risk: num(risk, 2),\n    riskReward: 1.5\n  };\n}\n\n/* =====================  OPTION WORTHINESS GATE (tweaked)  ===================== */\n\nfunction optionWorthinessGate(ctx) {\n  const {\n    regime, s1ad, coil, volType, hv20, atrPct, gap, catalyst,\n    volumeConfirm, rsSlope, failedBreakouts, avgVolume20, todayVolume,\n    price, hourly, plan, chainData\n  } = ctx;\n\n  const chain_quality = chainData ? 'chain' : 'proxy';\n\n  const s1Threshold = {\n    'BULL_QUIET': 55, 'BULL_VOLATILE': 62, 'RANGE': 60, 'CHOP': 65, 'BEAR': 70\n  }[regime] || 60;\n  const s1Pass = (s1ad >= s1Threshold);\n\n  // Relaxed ADV for $10\u2013$20, keep others same/tight\n  const advTierPass = (\n    (price >= 20 && price <= 100 && avgVolume20 >= 1_000_000) ||\n    (price > 100 && price <= 500 && avgVolume20 >= 600_000) ||\n    (price >= 10 && price < 20 && avgVolume20 >= 1_200_000)\n  );\n\n  const sessionActive = todayVolume ? (todayVolume / (avgVolume20 || 1)) >= 0.60 : true;\n\n  const tightUnderlying = (() => {\n    if (!hourly?.h || !hourly?.l || !hourly?.c || hourly.h.length < 10) return true;\n    const last10 = hourly.h.slice(-10).map((h, i) => {\n      const l = hourly.l[hourly.l.length - 10 + i];\n      const c = hourly.c[hourly.c.length - 10 + i];\n      return c ? (h - l) / c : 0;\n    }).filter(x => x > 0);\n    if (!last10.length) return true;\n    const med = last10.sort((a,b)=>a-b)[Math.floor(last10.length/2)];\n    const tightThresh = (price < 20) ? 0.0035 : 0.0015; // 0.35% vs 0.15%\n    return med <= tightThresh;\n  })();\n\n  const liqPass = advTierPass && sessionActive && tightUnderlying;\n  const pricePass = (price >= 20 && price <= 500);\n  const gapPass = (gap.maxDownGap <= 3.0) && (gap.medianGap <= 1.5);\n  const catPass = !(catalyst?.fdaBinary) && !(catalyst?.daysToEarnings != null && catalyst.daysToEarnings <= 2);\n  const volPass = (atrPct >= 1.2 && hv20 >= 18 && hv20 <= 70);\n\n  let chainPass = true;\n  if (chainData) {\n    const { oi, bidAskPct } = chainData;\n    chainPass = (oi >= 1000) && (bidAskPct <= 0.08);\n  }\n\n  const gatesOK = s1Pass && liqPass && pricePass && gapPass && catPass && volPass && chainPass;\n\n  // OAS SCORE\n  let oas = 0;\n\n  if (s1Pass) {\n    oas += 30;\n    if (coil === 'A+' || coil === 'A') oas += 10;\n  }\n\n  if (volType === 'Progressive' || volType === 'Building') oas += 15;\n  else if (volType === 'Surging') oas += 10;\n  else if (volType === 'Drying') oas += 8;\n\n  if (volumeConfirm) oas += 10;\n\n  if (rsSlope > 0.005) oas += 15;\n  else if (rsSlope > 0) oas += 8;\n\n  if (failedBreakouts === 0) oas += 10;\n  else if (failedBreakouts === 1) oas += 5;\n\n  if (hv20 >= 25 && hv20 <= 35) oas += 10;\n  else if (hv20 >= 20 && hv20 <= 45) oas += 5;\n\n  // Penalties\n  if (gap.maxDownGap > 2.5) oas -= 15;\n  else if (gap.maxDownGap > 2.0) oas -= 8;\n\n  if (hv20 > 70) oas -= 12;\n  if (!advTierPass) oas -= 12;\n  if (!sessionActive) oas -= 8;\n  if (!tightUnderlying) oas -= 8;\n\n  if (failedBreakouts >= 3) oas -= 15;\n  else if (failedBreakouts === 2) oas -= 8;\n\n  if (chain_quality === 'proxy') oas -= 4; // softened (was -8)\n\n  oas = Math.max(0, Math.min(100, Math.round(oas)));\n\n  const highIV = hv20 > 35;\n  const direction = plan?.bullish !== false ? 'BULL' : 'BEAR';\n\n  let structure = 'cash';\n  if (direction === 'BULL') {\n    structure = highIV ? 'bull_put_spread' : 'call_debit';\n  } else if (direction === 'BEAR') {\n    structure = highIV ? 'bear_call_spread' : 'put_debit';\n  }\n\n  const dteHint = structure.includes('debit') ? 7 : 14;\n  const deltaHint = structure.includes('debit') ? 0.45 : 0.25;\n\n  const oasThreshold = regime === 'CHOP' ? 65 : 60;\n  const buy_options = gatesOK && (oas >= oasThreshold);\n\n  const reason_tags = [\n    s1Pass ? 'S1AD_PASS' : 'S1AD_FAIL',\n    volumeConfirm ? 'VOL_CONF' : 'VOL_SOFT',\n    liqPass ? 'LIQ_OK' : 'LIQ_WEAK',\n    pricePass ? 'PRICE_OK' : 'PRICE_BAD',\n    gapPass ? 'GAP_LOW' : 'GAP_HIGH',\n    volPass ? 'VOL_OK' : 'VOL_EXTREME',\n    catPass ? 'CAT_CLEAR' : 'CAT_RISK',\n    chainPass ? 'CHAIN_OK' : 'CHAIN_THIN'\n  ];\n\n  const failedGates = reason_tags.filter(t =>\n    t.includes('FAIL') || t.includes('WEAK') || t.includes('BAD') ||\n    t.includes('HIGH') || t.includes('EXTREME') || t.includes('RISK') || t.includes('THIN')\n  );\n\n  const note = buy_options ?\n    `OAS ${oas}/100 (${chain_quality}): Worth trading ${structure}` :\n    `OAS ${oas}/100: Skip - ${failedGates.join(', ')}`;\n\n  return {\n    buy_options,\n    option_worthiness_score: oas,\n    chain_quality,\n    eligibility: {\n      s1ad_ok: s1Pass, liquidity_ok: liqPass, price_ok: pricePass,\n      gap_risk_ok: gapPass, catalyst_ok: catPass, volatility_ok: volPass,\n      chain_ok: chainPass, session_active: sessionActive, tight_underlying: tightUnderlying\n    },\n    structure, dte_hint: dteHint, delta_hint: deltaHint,\n    entry_plan: plan?.type || 'none',\n    levels: {\n      trigger: plan?.trigger || null, stop: plan?.stop || null,\n      t1: plan?.targets?.[0] || null, t2: plan?.targets?.[1] || null\n    },\n    reason_tags, note\n  };\n}\n\n/* =====================  RESAMPLE 1h \u2192 1D (gmtoffset-aware)  ===================== */\n\nfunction groupBySession(ts, open, high, low, close, vol, gmtoffset = 0) {\n  const byDay = new Map();\n  for (let i = 0; i < ts.length; i++) {\n    if (![open[i], high[i], low[i], close[i]].every(Number.isFinite)) continue;\n    const tAdjMs = (ts[i] + (gmtoffset || 0)) * 1000; // align to feed timezone\n    const d = new Date(tAdjMs);\n    const key = d.toISOString().slice(0,10);\n    if (!byDay.has(key)) byDay.set(key, { o:null,h:-Infinity,l:+Infinity,c:null,v:0 });\n    const k = byDay.get(key);\n    if (k.o === null) k.o = open[i];\n    k.h = Math.max(k.h, high[i]);\n    k.l = Math.min(k.l, low[i]);\n    k.c = close[i];\n    k.v += (vol[i] ?? 0);\n  }\n  const days = [...byDay.keys()].sort();\n  const o=[],h=[],l=[],c=[],v=[];\n  for (const day of days) {\n    const k = byDay.get(day);\n    if (!Number.isFinite(k.o)||!Number.isFinite(k.h)||!Number.isFinite(k.l)||!Number.isFinite(k.c)) continue;\n    o.push(k.o); h.push(k.h); l.push(k.l); c.push(k.c); v.push(k.v);\n  }\n  return { o,h,l,c,v, days };\n}\n\n/* =====================  AGENT-COMPATIBLE OUTPUT BUILDER  ===================== */\n\nfunction buildAgentOutput(sym, daily, hourly, spyCloses = null) {\n  const { c: closes, h: highs, l: lows, v: volumes } = daily;\n  if (!closes || closes.length < 50) return null;\n\n  const price = closes[closes.length - 1];\n  const prevPrice = closes[closes.length - 2];\n  const dayChange = prevPrice ? ((price - prevPrice) / prevPrice) * 100 : 0;\n\n  // MOVING AVERAGES\n  const sma20 = lastDefined(smaSeries(closes, 20));\n  const sma50 = lastDefined(smaSeries(closes, 50));\n  const ema9 = lastDefined(emaSeeded(closes, 9));\n  const ema20 = lastDefined(emaSeeded(closes, 20));\n  const ema50 = lastDefined(emaSeeded(closes, 50));\n\n  // VOLATILITY (robust HV + EMs)\n  const atr14 = atr(highs, lows, closes, 14);\n  const atrPct = (atr14 && price) ? (atr14 / price) * 100 : null;\n  const hv5_raw  = calcHistoricalVolatility(closes, 5);\n  const hv20_raw = calcHistoricalVolatility(closes, 20);\n  const hv_floor = hvFromATR(price, atr14) ?? 0;\n  const hv5  = Math.max(hv5_raw  ?? 0, hv_floor);\n  const hv20 = Math.max(hv20_raw ?? 0, hv_floor);\n  const bb20 = calcBollinger(closes, 20, 2);\n\n  // VOLUME\n  const recentVol = volumes[volumes.length - 1];\n  const avgVol = avg(volumes.slice(-20));\n  const volRatio = avgVol ? recentVol / avgVol : 1;\n\n  // RSI\n  const rsi7 = calcRSI(closes, 7);\n  const rsi14 = calcRSI(closes, 14);\n\n  // TREND\n  const shortTrend = (ema9 > ema20) ? 'up' : (ema9 < ema20) ? 'down' : 'flat';\n  const longTrend = (ema20 > ema50) ? 'up' : (ema20 < ema50) ? 'down' : 'flat';\n\n  const baseline = {\n    price, dayChange,\n    trend: { short: shortTrend, long: longTrend, aligned: (shortTrend === longTrend) },\n    rsi14, atrPct\n  };\n\n  // FAST INDICATORS\n  const coil = tightCoil(highs, lows, closes, 5);\n  const volAccel = rapidVolumeAccel(volumes, 3);\n  const intradayBurst = intradayMomentumBurst(hourly);\n  const breakout = breakoutProximity(daily, hourly);\n\n  // EARLY WARNING\n  const earlyWarnBull = earlyWarning(coil, volAccel, intradayBurst, breakout, baseline, 'bull');\n  const earlyWarnBear = earlyWarning(coil, volAccel, intradayBurst, breakout, baseline, 'bear');\n\n  // DIRECTIONAL SCORING\n  const scores = scoreFastMoves(coil, volAccel, intradayBurst, breakout, baseline);\n\n  // MARKET REGIME\n  const regime = detectMarketRegime(spyCloses);\n\n  // === S1AD ===\n  const s1ad = buildS1AD({\n    price, atrVal: atr14, ema20, daily,\n    benchCloses: spyCloses, regime\n  });\n\n  // GAP RISK\n  const gapRisk = calculateGapRisk(daily, 30);\n\n  // PLAN A (BREAKOUT)\n  const planA = calculatePlanA(daily, coil, atr14, s1ad);\n\n  // VOLUME CONFIRMATION (intraday vs 20D avg)\n  const volumeConfirm = hourly.v && hourly.v.length >= 2 ?\n    (avg(hourly.v.slice(-2)) >= (avgVol || 1) * 1.3) : false;\n\n  // TODAY'S VOLUME\n  const todayVolume = hourly.v ? hourly.v.reduce((sum, v) => sum + (v || 0), 0) : null;\n\n  // OPTION WORTHINESS GATE\n  const tradeGate = optionWorthinessGate({\n    regime, s1ad: s1ad.score, coil: coil.quality, volType: volAccel.type,\n    hv20, atrPct,\n    gap: { maxDownGap: gapRisk.maxDownGap, medianGap: gapRisk.medianGap },\n    catalyst: { daysToEarnings: null, fdaBinary: false },\n    volumeConfirm,\n    rsSlope: s1ad.components?.rsSlope || 0,\n    failedBreakouts: s1ad.components?.failedBreakouts || 0,\n    avgVolume20: avgVol || 0, todayVolume, price, hourly,\n    plan: planA || { type: 'none', bullish: true },\n    chainData: null\n  });\n\n  // WEEK OUTLOOK\n  const ema5_week = lastDefined(emaSeeded(closes, 5));\n  const ema13_week = lastDefined(emaSeeded(closes, 13));\n  const macd_week = calcMACD(closes, 8, 17, 9);\n  const mom1 = momentumPct(closes, 1);\n  const mom3 = momentumPct(closes, 3);\n  const mom5 = momentumPct(closes, 5);\n  const bb_week = calcBollinger(closes, 10, 2);\n\n  const sigma = Math.max(hv5, hv20) / 100;\n  const dailyMove = price * sigma / Math.sqrt(252);\n  const weekMove  = price * sigma / Math.sqrt(52);\n  const monthMove = price * sigma / Math.sqrt(12);\n\n  let weekChecks = 0, weekTotal = 8;\n  if (price > ema5_week) weekChecks++; else {}\n  if (price > ema13_week) weekChecks++; else {}\n  if (ema5_week > ema13_week) weekChecks++; else {}\n  if ((macd_week.histogram ?? -1) > 0) weekChecks++; else {}\n  if ((macd_week.histogram ?? -1) > (macd_week.prevHistogram ?? -1)) weekChecks++; else {}\n  if ((mom1 ?? -1) > 0) weekChecks++; else {}\n  if ((mom3 ?? -1) > 0) weekChecks++; else {}\n  if ((mom5 ?? -1) > 0) weekChecks++; else {}\n\n  const weekVote = (weekChecks >= 5) ? 'Bull' : (weekChecks <= 3) ? 'Bear' : 'Neutral';\n  const weekStrength = (weekChecks >= 6 || weekChecks <= 2) ? 'strong' : (weekChecks === 4) ? 'neutral' : 'weak';\n  const weekReasons = [];\n  if (coil.readiness === 'READY' || coil.readiness === 'FORMING') weekReasons.push(`COIL_${coil.quality}_${coil.readiness}`);\n  if (volAccel.type !== 'Flat') weekReasons.push(`VOL_${volAccel.type}`);\n  if (intradayBurst.signal !== 'WAIT') weekReasons.push(`INTRADAY_${intradayBurst.signal}`);\n  if (breakout.breaking_up) weekReasons.push('BREAKING_RESISTANCE');\n  if (breakout.imminent_up) weekReasons.push('NEAR_BREAKOUT');\n  if (weekVote === 'Bull') weekReasons.push(`TREND_UP (${weekChecks}/${weekTotal})`);\n  if (weekVote === 'Bear') weekReasons.push(`TREND_DOWN (${weekChecks}/${weekTotal})`);\n\n  const weekOutlook = {\n    direction: weekVote, score: num((scores.bullScore > scores.bearScore ? scores.bullScore : -scores.bearScore) / 10, 1),\n    quickChecks: { checksPassed: weekChecks, checksTotal: weekTotal, vote: weekVote, strength: weekStrength },\n    gates: { trendUp: (ema5_week > ema13_week), lowRangeDampened: (bb_week.bandwidth < 3) },\n    metrics: {\n      rsi: num(rsi7, 2), emaFast: num(ema5_week, 2), emaSlow: num(ema13_week, 2),\n      macd: { macdLine: num(macd_week.macdLine, 3), signal: num(macd_week.signal, 3),\n              histogram: num(macd_week.histogram, 3), histogramEff: num(macd_week.histogram, 3) },\n      mom: { m1: num(mom1, 2), m3: num(mom3, 2), m5: num(mom5, 2) },\n      bb: { middle: num(bb_week.middle, 2), bandwidth: num(bb_week.bandwidth, 2) },\n      atr: num(atr14, 2), atrPct: num(atrPct, 2), hv: num(hv5, 1),\n      expectedMoves: { daily: num(dailyMove, 2), oneWeek: num(weekMove, 2), oneMonth: num(monthMove, 2) }\n    },\n    reasons: weekReasons\n  };\n\n  // MONTH OUTLOOK\n  const macd_month = calcMACD(closes, 12, 26, 9);\n  const mom5_m = momentumPct(closes, 5);\n  const mom10 = momentumPct(closes, 10);\n  const mom20 = momentumPct(closes, 20);\n\n  let monthChecks = 0, monthTotal = 8;\n  if (price > ema20) monthChecks++;\n  if (price > ema50) monthChecks++;\n  if (ema20 > ema50) monthChecks++;\n  if ((macd_month.histogram ?? -1) > 0) monthChecks++;\n  if ((macd_month.histogram ?? -1) > (macd_month.prevHistogram ?? -1)) monthChecks++;\n  if ((mom5_m ?? -1) > 0) monthChecks++;\n  if ((mom10 ?? -1) > 0) monthChecks++;\n  if ((mom20 ?? -1) > 0) monthChecks++;\n\n  const monthVote = (monthChecks >= 5) ? 'Bull' : (monthChecks <= 3) ? 'Bear' : 'Neutral';\n  const monthStrength = (monthChecks >= 6 || monthChecks <= 2) ? 'strong' : 'weak';\n\n  const monthOutlook = {\n    direction: monthVote, score: num(monthChecks * 1.25, 1),\n    quickChecks: { checksPassed: monthChecks, checksTotal: monthTotal, vote: monthVote, strength: monthStrength },\n    gates: { trendUp: (ema20 > ema50), lowRangeDampened: (bb20.bandwidth < 4) },\n    metrics: {\n      rsi: num(rsi14, 2), emaFast: num(ema20, 2), emaSlow: num(ema50, 2),\n      macd: { macdLine: num(macd_month.macdLine, 3), signal: num(macd_month.signal, 3),\n              histogram: num(macd_month.histogram, 3), histogramEff: num(macd_month.histogram, 3) },\n      mom: { m5: num(mom5_m, 2), m10: num(mom10, 2), m20: num(mom20, 2) },\n      bb: { middle: num(bb20.middle, 2), bandwidth: num(bb20.bandwidth, 2) },\n      atr: num(atr14, 2), atrPct: num(atrPct, 2), hv: num(hv20, 1),\n      expectedMoves: { daily: num(dailyMove, 2), oneWeek: num(weekMove, 2), oneMonth: num(monthMove, 2) }\n    },\n    reasons: [`TREND_${monthVote.toUpperCase()} (${monthChecks}/${monthTotal})`]\n  };\n\n  // Early (intraday hint)\n  let bullHint = 'None', bullConf = 0.25;\n  let bearHint = 'None', bearConf = 0.25;\n\n  if (intradayBurst.signal === 'GO_BULL') { bullHint = 'BreakoutSet'; bullConf = 0.85; }\n  else if (intradayBurst.signal === 'WATCH_BULL') { bullHint = 'Building'; bullConf = 0.65; }\n  else if (coil.readiness === 'READY') { bullHint = 'CoiledReady'; bullConf = 0.75; }\n  else if (breakout.imminent_up) { bullHint = 'NearBreakout'; bullConf = 0.60; }\n\n  if (intradayBurst.signal === 'GO_BEAR') { bearHint = 'BreakdownSet'; bearConf = 0.85; }\n  else if (intradayBurst.signal === 'WATCH_BEAR') { bearHint = 'Fading'; bearConf = 0.65; }\n  else if (coil.bearReadiness === 'READY') { bearHint = 'CoiledWeak'; bearConf = 0.75; }\n\n  const earlyData = {\n    hint: bullHint, confidence: num(bullConf, 2),\n    triggers: {\n      preBreakout: breakout.imminent_up || breakout.breaking_up,\n      pullbackEMA: false,\n      macdZeroCross: (macd_week.histogram ?? -1) > 0 && (macd_week.prevHistogram ?? -1) < 0\n    },\n    bear: {\n      hint: bearHint, confidence: num(bearConf, 2),\n      triggers: {\n        preBreakdown: breakout.imminent_down || breakout.breaking_down,\n        rallyToEMA: false,\n        macdZeroDown: (macd_week.histogram ?? 1) < 0 && (macd_week.prevHistogram ?? 1) > 0\n      }\n    }\n  };\n\n  return {\n    symbol: sym,\n    currentPrice: num(price, 2),\n    dayChange: num(dayChange, 2),\n\n    movingAverages: {\n      sma20: num(sma20, 2), sma50: num(sma50, 2),\n      ema9: num(ema9, 2), ema20: num(ema20, 2)\n    },\n\n    volatility: {\n      hv20: num(hv20, 1), volumeRatio: num(volRatio, 2),\n      bbBandwidth: num(bb20.bandwidth, 2), atr: num(atr14, 2)\n    },\n\n    outlooks: { week: weekOutlook, month: monthOutlook },\n    early: earlyData,\n\n    stage1_quality: {\n      score: s1ad.score,\n      grade: s1ad.quality,\n      ready: s1ad.score >= 60,\n      components: s1ad.components\n    },\n\n    probability: {\n      bull: earlyWarnBull.probability,\n      bear: earlyWarnBear.probability,\n      bull_urgency: earlyWarnBull.urgency,\n      bear_urgency: earlyWarnBear.urgency,\n      bull_timeframe: earlyWarnBull.timeframe,\n      bear_timeframe: earlyWarnBear.timeframe\n    },\n\n    setup_quality: {\n      coil: coil.quality,\n      coil_readiness: coil.readiness,\n      volume_type: volAccel.type,\n      intraday_signal: intradayBurst.signal\n    },\n\n    trade_gate: tradeGate,\n\n    gap_risk: calculateGapRisk(daily, 30),\n\n    timestamp: new Date().toISOString(),\n\n    _scoring: {\n      bullScore: scores.bullScore,\n      bearScore: scores.bearScore,\n      dirScore: scores.dirScore,\n      earlyWarnBull, earlyWarnBear,\n      coil, volAccel, intradayBurst, breakout\n    }\n  };\n}\n\n/* =====================  MAIN PROCESSING  ===================== */\n\nconst items = $input.all();\nconst stash = [];\nlet spyCloses = null;\n\n// === EXTRACT SPY BENCHMARK (FIRST PASS) ===\nfor (const item of items) {\n  const r = item.json?.chart?.result?.[0];\n  if (!r?.indicators?.quote?.[0]) continue;\n  const sym = r.meta?.symbol ?? 'UNKNOWN';\n  if (sym === 'SPY') {\n    const q = r.indicators.quote[0];\n    const ts = r.timestamp || [];\n    const opens  = (q.open  || []).map(Number);\n    const highs  = (q.high  || []).map(Number);\n    const lows   = (q.low   || []).map(Number);\n    const closes = (q.close || []).map(Number);\n    const vols   = (q.volume|| []).map(x => Number.isFinite(x) ? x : 0);\n    const gmtoffset = r.meta?.gmtoffset || 0;\n    const daily = groupBySession(ts, opens, highs, lows, closes, vols, gmtoffset);\n    spyCloses = daily.c;\n    break;\n  }\n}\n\n// === PROCESS ALL SYMBOLS (SECOND PASS) ===\nfor (const item of items) {\n  const r = item.json?.chart?.result?.[0];\n  if (!r?.indicators?.quote?.[0]) continue;\n\n  const sym = r.meta?.symbol ?? 'UNKNOWN';\n  const q = r.indicators.quote[0];\n  const ts = r.timestamp || [];\n  const opens  = (q.open  || []).map(Number);\n  const highs  = (q.high  || []).map(Number);\n  const lows   = (q.low   || []).map(Number);\n  const closes = (q.close || []).map(Number);\n  const vols   = (q.volume|| []).map(x => Number.isFinite(x) ? x : 0);\n  const gmtoffset = r.meta?.gmtoffset || 0;\n\n  const hourly = { o:opens, h:highs, l:lows, c:closes, v:vols, ts };\n  const daily = groupBySession(ts, opens, highs, lows, closes, vols, gmtoffset);\n\n  const output = buildAgentOutput(sym, daily, hourly, spyCloses);\n  if (output) stash.push(output);\n}\n\n/* =====================  RANKING & FILTERING (EARLY-ENTRY BIAS)  ===================== */\n\nconst scored = stash.map((item, idx) => {\n  const sc = item._scoring || {};\n  const s1 = item.stage1_quality?.score ?? 0;\n  const s1Quality = item.stage1_quality?.grade ?? 'FAIL';\n  const gapOk = item.gap_risk?.acceptable ?? true;\n  const worthTrading = item.trade_gate?.buy_options ?? false;\n\n  const isGO = sc?.intradayBurst?.signal === 'GO_BULL' || sc?.intradayBurst?.signal === 'GO_BEAR';\n  const nearBreak = sc?.breakout?.imminent_up || sc?.breakout?.imminent_down;\n\n  let bull = sc?.bullScore ?? 0;\n  let bear = sc?.bearScore ?? 0;\n\n  // Early preference \u2014 reward S1 pre-move\n  const premoveBonus = Math.round(0.65 * s1);\n  bull += premoveBonus;\n  bear += Math.round(0.25 * s1);\n\n  // Demote already \"GO\" to avoid late entries\n  if (isGO) { bull -= 15; bear -= 15; }\n\n  // Boost imminent (not yet GO)\n  if (nearBreak && !isGO) { bull += 8; bear += 8; }\n\n  // Gap risk penalty\n  if (!gapOk) { bull -= 12; bear -= 12; }\n\n  // Quality gates\n  if (s1Quality === 'FAIL' || s1Quality === 'C') { bull *= 0.5; bear *= 0.5; }\n\n  // Tradability boost\n  if (worthTrading) { bull += 5; bear += 5; }\n\n  return {\n    idx, symbol: item.symbol,\n    bull: Math.max(0, bull), bear: Math.max(0, bear),\n    s1, s1Quality, gapOk, worthTrading,\n    price: item.currentPrice\n  };\n});\n\n// Prefer option-worthy + quality; fallback gracefully if too few\nconst filterOW = scored.filter(r => r.s1 >= 55 && r.gapOk && r.worthTrading);\nconst filterQ  = scored.filter(r => r.s1 >= 55 && r.gapOk);\n\nconst poolBulls = filterOW.length >= TOP_BULLS ? filterOW : (filterQ.length >= TOP_BULLS ? filterQ : scored);\nconst poolBears = filterOW.length >= TOP_BEARS ? filterOW : (filterQ.length >= TOP_BEARS ? filterQ : scored);\n\nconst topBulls = poolBulls.slice().sort((a, b) => b.bull - a.bull).slice(0, TOP_BULLS);\nconst topBears = poolBears.slice().sort((a, b) => b.bear - a.bear).slice(0, TOP_BEARS);\n\n// ORDINAL RANKINGS\nconst bullRanks = new Map();\nconst bearRanks = new Map();\ntopBulls.forEach((r, i) => bullRanks.set(r.idx, i + 1));\ntopBears.forEach((r, i) => bearRanks.set(r.idx, i + 1));\n\n// OUTPUT\nconst outputSet = new Set([...topBulls.map(r => r.idx), ...topBears.map(r => r.idx)]);\nconst results = [];\n\nfor (const idx of outputSet) {\n  const item = stash[idx];\n  item.ranking = {\n    bullScore: item._scoring.bullScore,\n    bearScore: item._scoring.bearScore,\n    dirScore: item._scoring.dirScore,\n    ordinal: {\n      bullRank: bullRanks.get(idx) || null,\n      bearRank: bearRanks.get(idx) || null\n    }\n  };\n  delete item._scoring;\n  results.push({ json: item });\n}\n\n// LEADERBOARD\nif (EMIT_LEADERBOARD) {\n  const mapOut = (r) => ({\n    symbol: r.symbol,\n    bull: r.bull,\n    bear: r.bear,\n    s1: r.s1,\n    s1Quality: r.s1Quality,\n    worthTrading: r.worthTrading,\n    price: r.price\n  });\n\n  results.push({\n    json: {\n      meta: {\n        type: 'leaderboard',\n        totalSymbols: stash.length,\n        outputCount: results.length - 1,\n        generatedAt: new Date().toISOString(),\n        version: VERSION,\n        optimization: 'Stage-1 Accumulation + Option Worthiness for Weekly Options',\n        regime: detectMarketRegime(spyCloses),\n        spyFound: spyCloses !== null\n      },\n      leaderboard: {\n        topBullish: topBulls.map(mapOut),\n        topBearish: topBears.map(mapOut)\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        32
      ],
      "id": "43e6cc9e-e8d8-47d6-adcd-870e86e8b445",
      "name": "TAOutlook v2.0"
    },
    {
      "parameters": {
        "model": "sonar-reasoning",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "simplify": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Simplify_Output', ``, 'boolean') }}",
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        3616,
        720
      ],
      "id": "a3aeb311-6faf-4a56-bdaf-768a6dc053ce",
      "name": "Perplexity Macro Tool",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "// === Portfolio Aggregator \u2014 outputs ONE item with { portfolio: { ... } } ===\n// Accepts: many items (each a position object) OR items that contain arrays of positions\n// Dedupes by asset_id (fallback: symbol|side|avg_entry_price)\n// Normalizes numbers, parses OPRA, computes per-symbol rollups + totals\n\nconst toNum = (v) => (v === null || v === undefined || v === \"\" ? 0 : +v);\n\n// Parse OPRA like \"SFM250919C00155000\"\nfunction parseOpra(opra) {\n  const m = /^([A-Z.]{1,6})(\\d{2})(\\d{2})(\\d{2})([CP])(\\d{8})$/.exec(opra || \"\");\n  if (!m) return { underlying: null, expiry: null, right: null, strike: null };\n  const [, u, yy, mm, dd, cp, strike8] = m;\n  const y = 2000 + Number(yy), mo = Number(mm) - 1, d = Number(dd);\n  return {\n    underlying: u,\n    expiry: new Date(Date.UTC(y, mo, d)).toISOString().slice(0, 10),\n    right: cp === \"C\" ? \"call\" : \"put\",\n    strike: Number(strike8) / 1000\n  };\n}\n\n// 1) Flatten inputs (items or arrays) and de-duplicate\nconst incoming = $input.all().flatMap(it => {\n  const j = it.json;\n  return Array.isArray(j) ? j : [j];\n});\n\nconst dedup = new Map();\nfor (const p of incoming) {\n  const key = p.asset_id ?? `${p.symbol}|${p.side}|${p.avg_entry_price}`;\n  dedup.set(key, p); // keep latest occurrence\n}\nconst raw = [...dedup.values()];\n\n// 2) Normalize + enrich each position\nconst positions = raw.map(p => {\n  const meta = parseOpra(p.symbol);\n  return {\n    asset_id: p.asset_id ?? null,\n    opra: p.symbol ?? null,\n    underlying: meta.underlying,\n    expiry: meta.expiry,\n    right: meta.right,               // \"call\" | \"put\" | null\n    strike: meta.strike,             // number or null\n    side: (p.side || \"\").toLowerCase(), // \"long\" | \"short\"\n    qty: toNum(p.qty),\n    avg_entry: toNum(p.avg_entry_price),\n    market_value: toNum(p.market_value),\n    cost_basis: toNum(p.cost_basis),\n    unrealized_pl: toNum(p.unrealized_pl),\n    unrealized_plpc: toNum(p.unrealized_plpc),\n    current_price: toNum(p.current_price),\n    lastday_price: toNum(p.lastday_price),\n    change_today: toNum(p.change_today)\n  };\n});\n\n// 3) Per-symbol rollups\nconst symMap = new Map();\nfor (const r of positions) {\n  const s = r.underlying || \"UNKNOWN\";\n  if (!symMap.has(s)) {\n    symMap.set(s, {\n      symbol: s,\n      legs: 0,\n      qty_long: 0,\n      qty_short: 0,\n      qty_net: 0,\n      long_calls: 0, short_calls: 0, long_puts: 0, short_puts: 0,\n      cost_basis: 0, market_value: 0, unrealized_pl: 0\n    });\n  }\n  const g = symMap.get(s);\n  g.legs += 1;\n  if (r.side === \"short\") g.qty_short += Math.abs(r.qty);\n  else g.qty_long += Math.max(0, r.qty);\n\n  g.qty_net += r.qty;\n  g.cost_basis += r.cost_basis;\n  g.market_value += r.market_value;\n  g.unrealized_pl += r.unrealized_pl;\n\n  if (r.right === \"call\" && r.side === \"long\") g.long_calls += Math.abs(r.qty);\n  if (r.right === \"call\" && r.side === \"short\") g.short_calls += Math.abs(r.qty);\n  if (r.right === \"put\"  && r.side === \"long\") g.long_puts  += Math.abs(r.qty);\n  if (r.right === \"put\"  && r.side === \"short\") g.short_puts += Math.abs(r.qty);\n}\nconst per_symbol = [...symMap.values()]\n  .sort((a, b) => a.symbol.localeCompare(b.symbol));\n\n// 4) Totals\nconst totals = positions.reduce((t, r) => {\n  t.positions += 1;\n  t.underlyings.add(r.underlying || \"UNKNOWN\");\n  if (r.side === \"short\") t.contracts_short += Math.abs(r.qty);\n  else t.contracts_long += Math.max(0, r.qty);\n  t.cost_basis += r.cost_basis;\n  t.market_value += r.market_value;\n  t.unrealized_pl += r.unrealized_pl;\n  return t;\n}, {\n  positions: 0,\n  underlyings: new Set(),\n  contracts_long: 0,\n  contracts_short: 0,\n  cost_basis: 0,\n  market_value: 0,\n  unrealized_pl: 0\n});\n\nconst portfolio = {\n  asof: new Date().toISOString(),\n  positions: positions\n    .sort((a, b) =>\n      (a.underlying || \"\").localeCompare(b.underlying || \"\") ||\n      (a.expiry || \"\").localeCompare(b.expiry || \"\") ||\n      (a.right || \"\").localeCompare(b.right || \"\") ||\n      (a.strike ?? 0) - (b.strike ?? 0)\n    ),\n  per_symbol,\n  totals: {\n    positions: totals.positions,\n    underlyings_count: totals.underlyings.size,\n    contracts_long: totals.contracts_long,\n    contracts_short: totals.contracts_short,\n    contracts_net: totals.contracts_long - totals.contracts_short,\n    cost_basis: totals.cost_basis,\n    market_value: totals.market_value,\n    unrealized_pl: totals.unrealized_pl\n  }\n};\n\n// 5) Return ONE item with the portfolio object\nreturn [{ json: { portfolio } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        368
      ],
      "id": "bc6ec053-71d5-42b5-ac17-d9b0e517211a",
      "name": "Parse portsummary"
    },
    {
      "parameters": {
        "jsCode": "// --- Collapse Account + Portfolio -> ONE item (robust) ---\n// Accepts EITHER:\n//  \u2022 multiple input items (some account-like, some {portfolio:{...}}), OR\n//  \u2022 a single input item whose json is an array containing those objects.\n//\n// Emits ONE item: { account, balances, portfolio, summary }\n\nconst items = $input.all();\n\n// Flatten any arrays embedded in item.json\nconst flat = [];\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) flat.push(...j);\n  else flat.push(j);\n}\n\n// Predicates\nconst isAcct = o =>\n  o && typeof o === 'object' &&\n  (o.account_number || o.options_buying_power || o.buying_power);\n\nconst isPortWrap = o =>\n  o && typeof o === 'object' &&\n  o.portfolio && Array.isArray(o.portfolio.positions);\n\n// Pick latest account (by balance_asof, then created_at)\nconst acctCandidates = flat.filter(isAcct);\nacctCandidates.sort((a, b) => {\n  const aKey = (a.balance_asof || a.created_at || '').toString();\n  const bKey = (b.balance_asof || b.created_at || '').toString();\n  return aKey.localeCompare(bKey);\n});\nconst acct = acctCandidates.length ? acctCandidates[acctCandidates.length - 1] : {};\n\n// Pick latest portfolio (by portfolio.asof)\nconst portCandidates = flat.filter(isPortWrap);\nportCandidates.sort((a, b) => {\n  const aKey = (a.portfolio.asof || '').toString();\n  const bKey = (b.portfolio.asof || '').toString();\n  return aKey.localeCompare(bKey);\n});\nconst portWrap = portCandidates.length ? portCandidates[portCandidates.length - 1] : null;\n\nconst portfolio = portWrap?.portfolio ?? {\n  asof: null,\n  positions: [],\n  per_symbol: [],\n  totals: {}\n};\n\n// Number coercion\nconst n = v => (v === null || v === undefined || v === '' ? 0 : +v);\n\n// Balances slice for executor math\nconst balances = {\n  options_buying_power: n(acct.options_buying_power),\n  cash: n(acct.cash),\n  equity: n(acct.equity),\n  portfolio_value: n(acct.portfolio_value),\n  buying_power: n(acct.buying_power),\n  regt_buying_power: n(acct.regt_buying_power),\n  non_marginable_buying_power: n(acct.non_marginable_buying_power),\n  daytrading_buying_power: n(acct.daytrading_buying_power),\n  multiplier: n(acct.multiplier || 1),\n  asof: (acct.balance_asof || '').toString() || new Date().toISOString().slice(0,10)\n};\n\n// Lightweight account identity/config\nconst account = {\n  id: acct.id,\n  account_number: acct.account_number,\n  status: acct.status,\n  options_approved_level: n(acct.options_approved_level),\n  options_trading_level: n(acct.options_trading_level),\n  pattern_day_trader: !!acct.pattern_day_trader,\n  shorting_enabled: !!acct.shorting_enabled,\n  created_at: acct.created_at\n};\n\n// Summary for quick guards/logging\nconst summary = {\n  positions_count: portfolio.totals?.positions ?? (Array.isArray(portfolio.positions) ? portfolio.positions.length : 0),\n  underlyings_count: portfolio.totals?.underlyings_count ?? 0,\n  symbols: Array.isArray(portfolio.per_symbol) ? portfolio.per_symbol.map(x => x.symbol) : [],\n  asof: portfolio.asof\n};\n\n// Optional diagnostics (helps you confirm the picker grabbed the right objects)\n// Remove if you don\u2019t want this.\nconst _diag = {\n  inputs_seen: flat.length,\n  account_found: !!acct.account_number || !!acct.options_buying_power || !!acct.buying_power,\n  portfolio_found: Array.isArray(portfolio.positions),\n  portfolio_asof: portfolio.asof\n};\n\nreturn [{\n  json: { account, balances, portfolio, summary, _diag }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2480,
        336
      ],
      "id": "4c2da2d0-0e0b-4148-82c0-af300714331a",
      "name": "Account and open positions"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Step 2: Validator & Normalizer (HARDENED v1.1, upside-friendly)\n *\n * INPUT  : items[0].json = raw payload (array with one object OR a single object)\n * OUTPUT : ONE item:\n * {\n *   executor,          // normalized executor_input.v1 (plays annotated with play_uid + prequote flags)\n *   snapshot,          // { account, balances, portfolio, summary }\n *   market_context,    // string|object|null (from input.market_context or fallback to executor.output)\n *   resolved,          // [] if absent\n *   diag               // normalization + validation notes, never throws\n * }\n *\n * Design goals:\n * - Never hard-throw. All discrepancies are absorbed into diag.\n * - Coerce/guard all numeric fields (tolerate %, commas).\n * - Safe handling of flags/arrays/strings.\n * - Deterministic play_uid (play_id + \":D\" + dte [+#n] if duplicates).\n */\n\n/////////////////////// helpers ///////////////////////\n\nfunction num(x, d = 0) {\n  if (x === null || x === undefined) return d;\n  if (typeof x === 'number') return Number.isFinite(x) ? x : d;\n  let s = String(x).trim();\n  if (!s) return d;\n  s = s.replace(/,/g, '').replace(/%$/,''); // \"1,234.5%\" -> \"1234.5\"\n  const n = Number(s);\n  return Number.isFinite(n) ? n : d;\n}\nfunction nneg(x, d = 0) { const n = num(x, d); return n < 0 ? 0 : n; }\nfunction isFin(x) { return typeof x === 'number' && Number.isFinite(x); }\nfunction clone(o) { return o && typeof o === 'object' ? JSON.parse(JSON.stringify(o)) : o; }\nfunction asISO(d) { try { return new Date(d).toISOString(); } catch { return null; } }\nfunction lowerArray(a) {\n  if (!Array.isArray(a)) return [];\n  const out = [];\n  for (const v of a) out.push(String(v ?? '').toLowerCase());\n  return out;\n}\nfunction asBool(x, def=false){\n  if (typeof x === 'boolean') return x;\n  const s = String(x ?? '').trim().toLowerCase();\n  if (!s) return def;\n  if (['y','yes','true','1','t'].includes(s)) return true;\n  if (['n','no','false','0','f'].includes(s)) return false;\n  return def;\n}\n\nfunction computeBudgetWindow(dayBudget, tolPctPoints) {\n  const tolFrac = num(tolPctPoints, 0) / 100;\n  const min = dayBudget * (1 - tolFrac);\n  const max = dayBudget * (1 + tolFrac);\n  return { min, max, tol_frac: tolFrac };\n}\n\nfunction perSymbolCapDollars(obp, pct) {\n  return num(obp, 0) * (num(pct, 0) / 100);\n}\n\nfunction hasOverride(play) {\n  const q = play?.quality || {};\n  const flags = lowerArray(q.flags);\n  return Boolean(\n    play?.override === true ||\n    play?.override_ok === true ||\n    q?.override === true ||\n    q?.quality_override === true ||\n    flags.includes('override') ||\n    flags.includes('force') ||\n    flags.includes('bypass') ||\n    flags.includes('ok')\n  );\n}\n\nfunction basicQualityViolations(play, policyQ) {\n  const v = [];\n  const q = play.quality || {};\n  const pc = play.per_contract || {};\n\n  // pct_spread (prefer price if available)\n  const pricePct = num(play?.price?.pct_spread, NaN);\n  const qPct = num(q.pct_spread, NaN);\n  const effPct = Number.isFinite(pricePct) ? pricePct : (Number.isFinite(qPct) ? qPct : 0);\n  if (effPct > num(policyQ.max_pct_spread, 150)) v.push(`pct_spread>${num(policyQ.max_pct_spread, 150)}`);\n\n  // slippage_to_wc_ratio (accept provided or compute from slippage$/wc)\n  let slipRatio = num(q.slippage_to_wc_ratio, NaN);\n  if (!Number.isFinite(slipRatio)) {\n    const s$ = num(pc.slippage$, NaN);\n    const wc$ = num(pc.wc, NaN);\n    if (Number.isFinite(s$) && Number.isFinite(wc$) && wc$ > 0) slipRatio = s$ / wc$;\n  }\n  if (Number.isFinite(slipRatio) && slipRatio > num(policyQ.max_slippage_to_wc_ratio, 1)) {\n    v.push(`slippage_to_wc_ratio>${num(policyQ.max_slippage_to_wc_ratio, 1)}`);\n  }\n\n  // min wc\n  if (!(num(pc.wc, -1) >= num(policyQ.min_wc_dollars, 0))) {\n    v.push(`wc<${num(policyQ.min_wc_dollars, 0)}`);\n  }\n\n  // Greeks presence / finiteness\n  if (!Number.isFinite(num(pc['delta$'], NaN))) v.push('delta$_missing');\n  if (!Number.isFinite(num(pc['theta$/day'], NaN))) v.push('theta_day_missing');\n  if (!Number.isFinite(num(pc['vega$/pt'], NaN))) v.push('vega_pt_missing');\n\n  return { violations: v, effPct, slipRatio: Number.isFinite(slipRatio) ? slipRatio : null };\n}\n\nfunction pickExecutorFields(src) {\n  const keep = [\n    'schema_version','menu_id','timestamp','context','policy','budget',\n    'plays','plays_by_id','impact_picks','decisions','meta','output'\n  ];\n  const out = {};\n  for (const k of keep) if (k in src) out[k] = clone(src[k]);\n  return out;\n}\n\nfunction buildSnapshot(src) {\n  return {\n    account  : clone(src.account)   || {},\n    balances : clone(src.balances)  || {},\n    portfolio: clone(src.portfolio) || {},\n    summary  : clone(src.summary)   || {}\n  };\n}\n\n/////////////////////// main ///////////////////////\n\ntry {\n  const rawIn = items?.[0]?.json;\n  const diag = {\n    normalization: {},\n    validation: { ok: true, warnings: [], errors: [] },\n    policy: {},\n    budget: {},\n    asof_checks: {}\n  };\n\n  if (rawIn == null) {\n    return [{ json: { executor: {}, snapshot: {}, market_context: null, resolved: [], diag: { ...diag, validation: { ok: false, errors: ['no input found'] } } } }];\n  }\n\n  // Unwrap if array\n  const root = Array.isArray(rawIn) ? (rawIn[0] || {}) : rawIn;\n  diag.normalization.input_was_array = Array.isArray(rawIn);\n  diag.normalization.took_index = Array.isArray(rawIn) ? 0 : null;\n\n  // If it's already an executor_input.v1 at top, use it; else if root.executor exists, use that\n  let executor = (root && root.schema_version === 'executor_input.v1')\n    ? pickExecutorFields(root)\n    : (root && root.executor && root.executor.schema_version === 'executor_input.v1'\n        ? pickExecutorFields(root.executor)\n        : pickExecutorFields(root)); // last resort\n\n  // Ensure schema\n  executor.schema_version = 'executor_input.v1';\n  executor.menu_id = String(executor.menu_id || '');\n\n  // Snapshot from sibling keys if present\n  const snapshot = buildSnapshot(root);\n  diag.normalization.built_snapshot_from = Object.keys(snapshot).filter(k => Object.keys(snapshot[k]).length);\n\n  // Market context\n  const market_context = ('market_context' in root)\n    ? clone(root.market_context)\n    : (('market_context' in executor) ? clone(executor.market_context) : (executor.output || null));\n\n  // Resolved (if provided upstream)\n  const resolved = Array.isArray(root.resolved) ? clone(root.resolved) : [];\n\n  // --- sanitize policy/budget/context ---\n  executor.context = executor.context || {};\n  if (typeof executor.context.risk_appetite !== 'number') executor.context.risk_appetite = 8;\n\n  executor.policy = executor.policy || {};\n  executor.policy.quality = executor.policy.quality || {};\n  executor.policy.risk = executor.policy.risk || {};\n  const polQ = executor.policy.quality;\n  const polR = executor.policy.risk;\n\n  // Upside-tilted but still guarded defaults\n  polQ.max_pct_spread = num(polQ.max_pct_spread, 150);            // was 100\n  polQ.max_slippage_to_wc_ratio = num(polQ.max_slippage_to_wc_ratio, 1); // keep 1.0 default\n  polQ.min_wc_dollars = num(polQ.min_wc_dollars, 0);              // no floor unless specified\n\n  polR.per_symbol_cap_pct = num(polR.per_symbol_cap_pct, 50);     // align with Impact's 50% per-name cap\n\n  executor.budget = executor.budget || {};\n  const bud = executor.budget;\n  bud.options_buying_power = num(bud.options_buying_power, snapshot?.balances?.options_buying_power ?? 0);\n  bud.day_budget_dollars   = num(bud.day_budget_dollars, 0);\n  bud.tolerance_pct        = num(bud.tolerance_pct, 0);\n\n  // budget window & per-symbol cap\n  const bw = computeBudgetWindow(bud.day_budget_dollars, bud.tolerance_pct);\n  const symCap$ = perSymbolCapDollars(bud.options_buying_power, polR.per_symbol_cap_pct);\n\n  diag.policy.quality = clone(polQ);\n  diag.policy.risk = { per_symbol_cap_pct: polR.per_symbol_cap_pct, per_symbol_cap_dollars: symCap$ };\n  diag.budget = {\n    options_buying_power: bud.options_buying_power,\n    day_budget_dollars: bud.day_budget_dollars,\n    tolerance_pct_points: bud.tolerance_pct,\n    window_min: bw.min, window_max: bw.max\n  };\n\n  // As-of checks\n  const balAsOf = snapshot?.balances?.asof || null;\n  const portAsOf = snapshot?.portfolio?.asof || null;\n  if (balAsOf && portAsOf && String(balAsOf) !== String(portAsOf)) {\n    diag.asof_checks.mismatch = { balances_asof: balAsOf, portfolio_asof: portAsOf };\n    diag.validation.warnings.push('balances.asof != portfolio.asof');\n  }\n\n  // --- normalize plays ---\n  if (!Array.isArray(executor.plays)) {\n    executor.plays = [];\n    diag.validation.errors.push('executor.plays missing or not an array; defaulted to []');\n  }\n\n  const plays = executor.plays;\n  const seen = new Map();\n  let eligible = 0, skipped = 0;\n  const reasonCounts = {};\n\n  for (const p of plays) {\n    // Ensure base structures\n    p.symbol = String(p.symbol || '').toUpperCase();\n    p.strategy = String(p.strategy || '');\n    p.play_id = String(p.play_id || (p.symbol ? `${p.symbol}:${p.strategy}` : 'PLAY')).trim() || 'PLAY';\n    p.dte = Math.max(0, Math.floor(num(p.dte, 0)));\n\n    p.quality = p.quality || {};\n    p.quality.pct_spread = nneg(p.quality.pct_spread, 0);\n    // tolerate non-numeric slippage_to_wc_ratio\n    p.quality.slippage_to_wc_ratio = Number.isFinite(Number(p.quality.slippage_to_wc_ratio))\n      ? Number(p.quality.slippage_to_wc_ratio)\n      : p.quality.slippage_to_wc_ratio;\n\n    p.per_contract = p.per_contract || {};\n    p.per_contract.wc = nneg(p.per_contract.wc, 0);\n    p.per_contract['delta$'] = num(p.per_contract['delta$'], p.per_contract['delta$']);\n    p.per_contract['theta$/day'] = num(p.per_contract['theta$/day'], p.per_contract['theta$/day']);\n    p.per_contract['vega$/pt'] = num(p.per_contract['vega$/pt'], p.per_contract['vega$/pt']);\n\n    p.units = p.units || {};\n    p.units.contracts_per_1pct_weight = nneg(p.units.contracts_per_1pct_weight, 0);\n    p.units.percent_for_one_contract = nneg(p.units.percent_for_one_contract, 0);\n\n    p.scores = p.scores || {};\n\n    // Unique play_uid (dedupe-friendly)\n    const base = `${p.play_id}:D${p.dte}`;\n    let uid = base;\n    if (seen.has(base)) {\n      const n = seen.get(base) + 1;\n      seen.set(base, n);\n      uid = `${base}#${n}`;\n    } else {\n      seen.set(base, 1);\n    }\n    p.play_uid = uid;\n\n    // overrides\n    p.override_used = hasOverride(p);\n\n    // Pre-quote quality checks\n    const { violations, effPct, slipRatio } = basicQualityViolations(p, polQ);\n    p.violations_prequote = violations;\n    p.eligible_prequote = violations.length === 0 || p.override_used === true;\n    p.quality._computed = Object.assign({}, p.quality._computed || {}, {\n      pct_spread_effective: effPct,\n      slippage_to_wc_ratio_effective: slipRatio\n    });\n\n    if (p.eligible_prequote) eligible++; else skipped++;\n    for (const r of violations) reasonCounts[r] = (reasonCounts[r] || 0) + 1;\n  }\n\n  executor.meta = executor.meta || {};\n  executor.meta.total_candidates = plays.length;\n\n  // Ensure plays_by_id\n  if (!executor.plays_by_id || typeof executor.plays_by_id !== 'object') {\n    executor.plays_by_id = {};\n    plays.forEach((p, i) => { executor.plays_by_id[p.play_id] = i; });\n  }\n\n  diag.validation.prequote = {\n    total: plays.length,\n    eligible,\n    skipped,\n    skip_reasons: reasonCounts\n  };\n\n  if (diag.validation.errors.length > 0) diag.validation.ok = false;\n\n  // Final return\n  return [{\n    json: {\n      executor,\n      snapshot,\n      market_context,\n      resolved,\n      diag\n    }\n  }];\n\n} catch (err) {\n  // Last-resort soft error\n  return [{\n    json: {\n      executor: {},\n      snapshot: {},\n      market_context: null,\n      resolved: [],\n      diag: {\n        normalization: {},\n        validation: { ok: false, errors: [String(err && err.message || err)] },\n        policy: {},\n        budget: {},\n        asof_checks: {},\n        caught: String(err && err.stack || err)\n      }\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4288,
        -176
      ],
      "id": "31e97d7a-35eb-4f6f-aef3-17c34aafb9ee",
      "name": "Validate/Normalize"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Step 3: QuoteAttach & Post-Quote Quality (v1.1, hardened & upside-friendly)\n *\n * INPUT  : items[0].json from the Validator node:\n *          { executor, snapshot, market_context, resolved, diag }\n * OUTPUT : one item with the same shape, but with quotes/legs merged onto executor.plays[]\n *          and post-quote eligibility flags computed.\n *\n * What this node does\n * - Attaches resolved[].legs and resolved[].quote to matching plays (by play_uid if available, else play_id with DTE heuristic)\n * - Recomputes price: { bid, ask, mid, pct_spread } with safe defaults (tolerates %, commas)\n * - Updates effective pct_spread and runs quality checks again \u2192 eligible_postquote / violations_postquote\n * - Tags skip_reason_postquote if violations and no override\n * - Emits diagnostics in diag.quote_attach\n *\n * No external libraries. Never hard-throw; uses safe defaults. I/O shape unchanged.\n */\n\nfunction toNumber(x, def = 0) {\n  if (x === null || x === undefined) return def;\n  if (typeof x === 'number') return Number.isFinite(x) ? x : def;\n  let s = String(x).trim();\n  if (!s) return def;\n  s = s.replace(/,/g, '').replace(/%$/,''); // \"1,234.5%\" -> \"1234.5\"\n  const n = Number(s);\n  return Number.isFinite(n) ? n : def;\n}\nfunction nonNeg(x, def = 0) {\n  const n = toNumber(x, def);\n  return n < 0 ? 0 : n;\n}\nfunction isFiniteNumber(x) {\n  return typeof x === 'number' && Number.isFinite(x);\n}\nfunction clone(obj) {\n  return obj && typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : obj;\n}\n\n// Parse OPRA/OCC symbol to expiry date (YYMMDD just before C/P code)\nfunction parseOpraExpiry(opra) {\n  if (typeof opra !== 'string') return null;\n  const m = opra.match(/(\\d{6})([CP])/);\n  if (!m) return null;\n  const y = 2000 + parseInt(m[1].slice(0, 2), 10);\n  const mo = parseInt(m[1].slice(2, 4), 10) - 1;\n  const d = parseInt(m[1].slice(4, 6), 10);\n  const dt = new Date(Date.UTC(y, mo, d, 0, 0, 0));\n  return Number.isNaN(dt.getTime()) ? null : dt;\n}\nfunction daysUntil(dateFrom, dateTo) {\n  if (!(dateFrom instanceof Date) || !(dateTo instanceof Date)) return null;\n  const ms = dateTo.getTime() - dateFrom.getTime();\n  return Math.floor(ms / 86400000);\n}\n\nfunction computeQuoteStats(q) {\n  const bid = toNumber(q?.bid, NaN);\n  const ask = toNumber(q?.ask, NaN);\n  let mid = toNumber(q?.mid, NaN);\n  if (!Number.isFinite(mid)) {\n    if (Number.isFinite(bid) && Number.isFinite(ask)) mid = (bid + ask) / 2;\n    else if (Number.isFinite(bid)) mid = bid;\n    else if (Number.isFinite(ask)) mid = ask;\n  }\n  let pctSpread = toNumber(q?.pct_spread, NaN);\n  if (!Number.isFinite(pctSpread)) {\n    if (Number.isFinite(bid) && Number.isFinite(ask) && Number.isFinite(mid) && mid > 0) {\n      pctSpread = ((ask - bid) / mid) * 100;\n    }\n  }\n  return {\n    bid: Number.isFinite(bid) ? bid : null,\n    ask: Number.isFinite(ask) ? ask : null,\n    mid: Number.isFinite(mid) ? mid : null,\n    pct_spread: Number.isFinite(pctSpread) ? nonNeg(pctSpread, 0) : null,\n  };\n}\n\nfunction qualityViolations(play, policyQuality) {\n  const v = [];\n  const q = play.quality || {};\n  const pc = play.per_contract || {};\n\n  // Effective pct_spread prefers price if present, else quality.pct_spread\n  const pricePct = toNumber(play?.price?.pct_spread, NaN);\n  const qPct = toNumber(q.pct_spread, NaN);\n  const effectivePct = Number.isFinite(pricePct) ? pricePct : (Number.isFinite(qPct) ? qPct : 0);\n\n  if (effectivePct > toNumber(policyQuality.max_pct_spread, 150)) v.push(`pct_spread>${toNumber(policyQuality.max_pct_spread, 150)}`);\n\n  // slippage_to_wc_ratio: use provided; else derive from slippage$/wc\n  let slipRatio = toNumber(q.slippage_to_wc_ratio, NaN);\n  if (!Number.isFinite(slipRatio)) {\n    const slip$ = toNumber(pc.slippage$, NaN);\n    const wc$ = toNumber(pc.wc, NaN);\n    if (Number.isFinite(slip$) && Number.isFinite(wc$) && wc$ > 0) slipRatio = slip$ / wc$;\n  }\n  if (Number.isFinite(slipRatio) && slipRatio > toNumber(policyQuality.max_slippage_to_wc_ratio, 1)) {\n    v.push(`slippage_to_wc_ratio>${toNumber(policyQuality.max_slippage_to_wc_ratio, 1)}`);\n  }\n\n  // min wc\n  const wc = toNumber(pc.wc, -1);\n  if (!(wc >= toNumber(policyQuality.min_wc_dollars, 0))) v.push(`wc<${toNumber(policyQuality.min_wc_dollars, 0)}`);\n\n  // Greeks presence / finiteness (basic check)\n  const delta$ = toNumber(pc['delta$'], NaN);\n  const thetaDay = toNumber(pc['theta$/day'], NaN);\n  const vegaPt = toNumber(pc['vega$/pt'], NaN);\n  if (!Number.isFinite(delta$)) v.push('delta$_missing');\n  if (!Number.isFinite(thetaDay)) v.push('theta_day_missing');\n  if (!Number.isFinite(vegaPt)) v.push('vega_pt_missing');\n\n  return { violations: v, effectivePct, slipRatio, wc };\n}\n\ntry {\n  const input = items[0]?.json || {};\n  const executor = clone(input.executor) || {};\n  const snapshot = clone(input.snapshot) || {};\n  const resolved = Array.isArray(input.resolved) ? clone(input.resolved) : [];\n  const baseDiag = clone(input.diag) || { validation: { warnings: [], errors: [] } };\n\n  const plays = Array.isArray(executor.plays) ? executor.plays : [];\n  const policyQ = executor?.policy?.quality || { max_pct_spread: 150, max_slippage_to_wc_ratio: 1, min_wc_dollars: 0 };\n\n  // Build indexes for matching\n  const byUid = new Map();\n  const byId = new Map();\n  for (const p of plays) {\n    if (p.play_uid) byUid.set(p.play_uid, p);\n    const id = p.play_id || `${p.symbol}:${p.strategy}`;\n    if (!byId.has(id)) byId.set(id, []);\n    byId.get(id).push(p);\n  }\n\n  // Reference date for DTE heuristic\n  const asofStr = executor?.timestamp || snapshot?.portfolio?.asof || snapshot?.balances?.asof || null;\n  const asof = asofStr ? new Date(asofStr) : new Date();\n\n  // Diagnostics\n  const qaDiag = {\n    total_resolved: resolved.length,\n    matched_by_uid: 0,\n    matched_by_id_unique: 0,\n    matched_by_dte_heuristic: 0,\n    ambiguous_unresolved: 0,\n    unmatched_resolved: 0,\n    quotes_attached: 0,\n    legs_attached: 0,\n    eligible_postquote: 0,\n    skipped_postquote: 0,\n    skip_reasons: {}\n  };\n\n  function chooseByDteHeuristic(candidates, res) {\n    // Attempt to infer target DTE from first leg's OPRA\n    let targetDte = null;\n    const leg = Array.isArray(res?.legs) && res.legs.length > 0 ? res.legs[0] : null;\n    if (leg?.opra) {\n      const exp = parseOpraExpiry(leg.opra);\n      if (exp) {\n        const dte = daysUntil(asof instanceof Date ? asof : new Date(), exp);\n        if (Number.isFinite(dte)) targetDte = dte;\n      }\n    }\n    if (targetDte == null) {\n      // Fallback: pick smallest dte\n      let best = candidates[0];\n      for (const c of candidates) if (toNumber(c.dte, 999999) < toNumber(best.dte, 999999)) best = c;\n      return best;\n    } else {\n      let best = candidates[0], bestDiff = Math.abs(toNumber(candidates[0].dte, 999999) - targetDte);\n      for (const c of candidates.slice(1)) {\n        const diff = Math.abs(toNumber(c.dte, 999999) - targetDte);\n        if (diff < bestDiff) { best = c; bestDiff = diff; }\n      }\n      return best;\n    }\n  }\n\n  // Attach quotes/legs\n  for (const r of resolved) {\n    let play = null;\n    if (r.play_uid && byUid.has(r.play_uid)) {\n      play = byUid.get(r.play_uid);\n      qaDiag.matched_by_uid++;\n    } else if (r.play_id && byId.has(r.play_id)) {\n      const arr = byId.get(r.play_id) || [];\n      if (arr.length === 1) {\n        play = arr[0];\n        qaDiag.matched_by_id_unique++;\n      } else if (arr.length > 1) {\n        play = chooseByDteHeuristic(arr, r);\n        qaDiag.matched_by_dte_heuristic++;\n      } else {\n        qaDiag.unmatched_resolved++;\n      }\n    } else {\n      qaDiag.unmatched_resolved++;\n    }\n    if (!play) continue;\n\n    // Attach legs\n    if (Array.isArray(r.legs)) {\n      play.legs = clone(r.legs);\n      qaDiag.legs_attached++;\n      // Contract symbol convenience: single-leg => use OPRA, else null\n      if (r.legs.length === 1) {\n        play.contract_symbol = r.legs[0]?.opra || null;\n      } else {\n        play.contract_symbol = null;\n      }\n    }\n\n    // Attach quotes \u2192 price\n    if (r.quote && typeof r.quote === 'object') {\n      const stats = computeQuoteStats(r.quote);\n      play.price = {\n        bid: stats.bid,\n        ask: stats.ask,\n        mid: stats.mid,\n        pct_spread: stats.pct_spread\n      };\n      if (isFiniteNumber(stats.pct_spread)) qaDiag.quotes_attached++;\n      // Update effective pct_spread for downstream\n      play.quality = play.quality || {};\n      play.quality._computed = Object.assign({}, play.quality._computed || {}, {\n        pct_spread_effective: isFiniteNumber(stats.pct_spread)\n          ? stats.pct_spread\n          : toNumber(play.quality._computed?.pct_spread_effective, toNumber(play.quality.pct_spread, 0))\n      });\n    }\n  }\n\n  // Post-quote eligibility pass\n  let eligible = 0, skipped = 0;\n  for (const p of plays) {\n    const { violations, effectivePct } = qualityViolations(p, policyQ);\n    p.violations_postquote = violations;\n    // Respect explicit overrides from earlier node (p.override_used)\n    const isOk = violations.length === 0 || p.override_used === true;\n    p.eligible_postquote = !!isOk;\n\n    if (!isOk && p.override_used !== true) {\n      const reason = violations.join('|') || 'quality_violation';\n      p.skip_reason_postquote = reason;\n      qaDiag.skip_reasons[reason] = (qaDiag.skip_reasons[reason] || 0) + 1;\n      skipped++;\n    } else {\n      eligible++;\n    }\n\n    // Persist effective pct spread field for transparency\n    p.quality = p.quality || {};\n    p.quality._computed = Object.assign({}, p.quality._computed || {}, {\n      pct_spread_effective_post: effectivePct\n    });\n  }\n\n  qaDiag.eligible_postquote = eligible;\n  qaDiag.skipped_postquote = skipped;\n\n  // Attach diagnostics and return original shape\n  input.executor = executor; // plays mutated in place\n  input.diag = input.diag || {};\n  input.diag.quote_attach = qaDiag;\n  input.diag.validation = input.diag.validation || {};\n  input.diag.validation.postquote = {\n    total: plays.length,\n    eligible,\n    skipped,\n    skip_reasons: qaDiag.skip_reasons\n  };\n\n  return [{ json: input }];\n} catch (err) {\n  return [{\n    json: {\n      error: 'QuoteAttach encountered an exception',\n      message: String(err && err.message || err),\n      stack: (err && err.stack) ? String(err.stack) : undefined\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4512,
        -176
      ],
      "id": "4873f2c3-3fe7-4d54-b637-80492a3a4584",
      "name": "Attach quality for agent"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "trade_id": "={{$json.trade_id}}",
            "symbol": "={{$json.symbol}}",
            "strategy": "={{$json.strategy}}",
            "direction": "={{$json.direction}}",
            "rationale": "={{$json.rationale}}",
            "risk_rating": "={{$json.risk_rating}}",
            "exit_plan": "={{$json.exit_plan}}"
          },
          "matchingColumns": [
            "trade_id"
          ],
          "schema": [
            {
              "id": "trade_id",
              "displayName": "trade_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "symbol",
              "displayName": "symbol",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "strategy",
              "displayName": "strategy",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "direction",
              "displayName": "direction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "rationale",
              "displayName": "rationale",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "risk_rating",
              "displayName": "risk_rating",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "exit_plan",
              "displayName": "exit_plan",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "route",
              "displayName": "route",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "sheet",
              "displayName": "sheet",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "row",
              "displayName": "row",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5520,
        -128
      ],
      "id": "a58ef2ed-022e-4f21-984d-d35ec4858e75",
      "name": "Updated Executor Log",
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Legs Fan-out (minimal plan-time fields)\n *\n * INPUT  : items from the Output Parser, each with at least:\n *          { trade_id, symbol, strategy, dte, menu_id }\n * OUTPUT : one item per leg with EXACT columns you want to append:\n *          { trade_id, leg_no, order_id, side, qty, asset, root_symbol, expiry, right, strike }\n */\n\nfunction legsForStrategy(strategyRaw) {\n  const s = String(strategyRaw || '').toLowerCase();\n\n  // Spreads\n  if (s.includes('bull call spread')) return [{ side: 'BUY', right: 'C' }, { side: 'SELL', right: 'C' }];\n  if (s.includes('bear call spread')) return [{ side: 'SELL', right: 'C' }, { side: 'BUY',  right: 'C' }];\n  if (s.includes('bull put spread'))  return [{ side: 'SELL', right: 'P' }, { side: 'BUY',  right: 'P' }];\n  if (s.includes('bear put spread'))  return [{ side: 'BUY',  right: 'P' }, { side: 'SELL', right: 'P' }];\n\n  // Singles\n  if (s.includes('short put'))  return [{ side: 'SELL', right: 'P' }];\n  if (s.includes('short call')) return [{ side: 'SELL', right: 'C' }];\n  if (s.includes('long put'))   return [{ side: 'BUY',  right: 'P' }];\n  if (s.includes('long call'))  return [{ side: 'BUY',  right: 'C' }];\n\n  // Fallback: one leg, unknown right\n  return [{ side: 'BUY', right: '' }];\n}\n\nconst out = [];\nfor (const it of $input.all()) {\n  const j = it.json || {};\n  const symbol = String(j.symbol || '').toUpperCase();\n  // safety: rebuild trade_id if upstream forgot it\n  const trade_id = j.trade_id || `${j.menu_id || ''}|${symbol}:${j.strategy || ''}:D${j.dte || 0}`;\n  const legs = legsForStrategy(j.strategy);\n\n  legs.forEach((def, idx) => {\n    const leg_no = idx + 1;\n    out.push({\n      json: {\n        trade_id,\n        leg_no,\n        order_id: `${trade_id}:L${leg_no}`,\n        side: def.side,         // BUY / SELL\n        qty: \"\",                // unknown at plan time\n        asset: \"OPT\",\n        root_symbol: symbol,\n        expiry: \"\",             // unknown at plan time\n        right: def.right,       // C / P / \"\"\n        strike: \"\"              // unknown at plan time\n      }\n    });\n  });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6112,
        -80
      ],
      "id": "224166ff-f521-4fae-ad5e-eb133e5bb028",
      "name": "Legs Fan Out"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 533898805,
          "mode": "list",
          "cachedResultName": "Legs",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "trade_id": "={{$json.trade_id}}",
            "leg_no": "={{$json.leg_no}}",
            "order_id": "={{$json.order_id}}",
            "side": "={{$json.side}}",
            "qty": "={{$json.qty}}",
            "asset": "={{$json.asset}}",
            "root_symbol": "={{$json.root_symbol}}",
            "expiry": "={{$json.expiry}}",
            "right": "={{$json.right}}",
            "strike": "={{$json.strike}}"
          },
          "matchingColumns": [
            "order_id"
          ],
          "schema": [
            {
              "id": "trade_id",
              "displayName": "trade_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "leg_no",
              "displayName": "leg_no",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "order_id",
              "displayName": "order_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "side",
              "displayName": "side",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "qty",
              "displayName": "qty",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "asset",
              "displayName": "asset",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "root_symbol",
              "displayName": "root_symbol",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "expiry",
              "displayName": "expiry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "right",
              "displayName": "right",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "strike",
              "displayName": "strike",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        6128,
        -352
      ],
      "id": "93c97691-434e-4f28-b466-2c43665a47f9",
      "name": "Append or update row in sheet",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Build Alpaca Orders (STRICT AGENT-ONLY v5.3, approvals-hardened + $ sizing guard)\n * - Approvals: trade_journal w/ or w/o :D##, PM comms with \":\" or space, and `_routeType:\"weights\"` play_id.\n * - If approvals are absent, DO NOT early-return; log diag and proceed (gate only when approvals exist).\n * - Long OCC preserved; short OPRA \u2192 long OCC. Enforces $5k\u2013$30k per-order premium sizing.\n */\n\nconst DEFAULT_BASE_URL = 'https://paper-api.alpaca.markets';\nconst FORCED_ENDPOINT  = '/v2/orders';\n\nconst SIZING = { MIN_DOLLARS: 5000, MAX_DOLLARS: 30000, RESIZE_PASSTHROUGH: true, MAX_CONTRACTS: 999 };\nconst r2 = v => Number((Math.round(Number(v) * 100) / 100).toFixed(2));\n\nfunction clean(obj){ if (obj==null) return undefined; if (Array.isArray(obj)) return obj.map(clean).filter(v=>v!==undefined);\n  if (typeof obj==='object'){ const o={}; for (const [k,v] of Object.entries(obj)){ const c=clean(v); if (c!==undefined) o[k]=c; } return o; }\n  if (typeof obj==='number' && !Number.isFinite(obj)) return undefined; return obj; }\n\n/* ---------- Symbol helpers ---------- */\nconst LONG_OCC_RE   = /^([A-Z0-9.]+)(\\d{6})([CP])(\\d{8})$/;\nconst SHORT_OPRA_RE = /^([A-Z0-9.]+)(\\d{6})([CP])(\\d+(?:\\.\\d+)?)$/;\nfunction parseLongOcc(s){ const m=String(s||'').toUpperCase().match(LONG_OCC_RE); if(!m) return null;\n  const [_,under,yy,cp,k8]=m; return {under,yymmdd:yy,cp,strike:Number(k8)/1000,type:cp==='C'?'CALL':'PUT',isLong:true}; }\nfunction parseShortOpra(s){ const m=String(s||'').toUpperCase().match(SHORT_OPRA_RE); if(!m) return null;\n  const [_,under,yy,cp,kstr]=m; return {under,yymmdd:yy,cp,strike:Number(kstr),type:cp==='C'?'CALL':'PUT',isLong:false}; }\nfunction parseAnyOpt(s){ return parseLongOcc(s)||parseShortOpra(s); }\nfunction toLongOcc(sym){ const s=String(sym||'').toUpperCase(); if (LONG_OCC_RE.test(s)) return s;\n  const p=parseShortOpra(s); if(!p) return s; const k1000=Math.round(p.strike*1000);\n  return `${p.under}${p.yymmdd}${p.cp}${String(k1000).padStart(8,'0')}`; }\n\nfunction isSpreadBody(rb){ return rb && ((String(rb.order_class||'').toLowerCase()==='mleg') || (Array.isArray(rb.legs)&&rb.legs.length>1)); }\nfunction legIntent(side){ return String(side).toLowerCase()==='sell' ? 'sell_to_open' : 'buy_to_open'; }\n\nfunction pickLimitFromOrder(o){ const lp=o?.limit_plan||{}, p=o?.price||{};\n  if (Number.isFinite(lp.marketable)&&lp.marketable>0) return r2(lp.marketable);\n  if (Number.isFinite(lp.final)     &&lp.final>0)      return r2(lp.final);\n  if (Number.isFinite(p.mid)        &&p.mid>0)         return r2(p.mid);\n  return null; }\n\n/* ---------- Strategy inference ---------- */\nfunction inferStrategyFromLegs(legs){\n  if (!Array.isArray(legs)||legs.length<2) return null;\n  const buy = legs.find(L=>String(L.side).toLowerCase()==='buy');\n  const sell= legs.find(L=>String(L.side).toLowerCase()==='sell');\n  if(!(buy&&sell)) return null;\n  const pb=parseAnyOpt(buy.symbol), ps=parseAnyOpt(sell.symbol);\n  if(!(pb&&ps) || pb.cp!==ps.cp) return null;\n  if (pb.cp==='C') return (ps.strike>pb.strike)?'Bull Call Spread':'Bear Call Spread';\n  return (ps.strike>pb.strike)?'Bull Put Spread':'Bear Put Spread';\n}\nfunction inferStrategyFromSingle(symbol, side){\n  const p=parseAnyOpt(symbol); if(!p) return null;\n  const s=String(side||'buy').toLowerCase();\n  return p.type==='CALL' ? (s==='sell'?'Short Call':'Long Call') : (s==='sell'?'Short Put':'Long Put');\n}\nfunction inferPlayIdFromBody(rb){\n  if (isSpreadBody(rb)){\n    const legs=(rb.legs||[]).map(L=>({...L, symbol:toLongOcc(L.symbol||L.opra)}));\n    const strat=inferStrategyFromLegs(legs);\n    const under=parseAnyOpt(legs[0]?.symbol)?.under;\n    if (strat&&under) return `${under}:${strat}`;\n  } else {\n    const sym=toLongOcc(rb.symbol||''); const p=parseAnyOpt(sym); if(!p) return null;\n    const strat=inferStrategyFromSingle(sym, rb.side); if (strat&&p.under) return `${p.under}:${strat}`;\n  }\n  return null;\n}\n\n/* ---------- Approvals (hardened) ---------- */\n// Accept with or without :D## suffix\nfunction parseTJtoPid(trade_id){\n  const m=String(trade_id||'').match(/\\|([^:|]+):([^:|]+)(?::D\\d+)?\\b/);\n  return m ? `${m[1].toUpperCase().trim()}:${m[2].trim()}` : null;\n}\n// Accept \"TICKER:Strategy\" OR \"TICKER Strategy\" in PM comms\nfunction extractPidsFromPmComms(text){\n  if (!text) return [];\n  const re=/\\b([A-Z.]{1,8})\\s*[:\\s]\\s*(Bull Call Spread|Bull Put Spread|Bear Call Spread|Bear Put Spread|Long Call|Long Put|Short Call|Short Put)\\b/g;\n  const set=new Set(); let m; while ((m=re.exec(String(text)))!==null) set.add(`${m[1].toUpperCase()}:${m[2]}`);\n  return [...set];\n}\n\n/* ---------- Sizing guard (premium-based) ---------- */\nfunction perContractDollars(limitPrice){ const p=Number(limitPrice); return (Number.isFinite(p)&&p>0) ? Math.abs(p)*100 : null; }\nfunction clamp(n,lo,hi){ return Math.max(lo, Math.min(hi, n)); }\nfunction maybeResize(rb, { isSpread }){\n  if (!rb || String(rb.asset_class).toLowerCase()!=='option') return null;\n  const pcd=perContractDollars(rb.limit_price); if (pcd==null) return null;\n  let qty=Number(rb.qty ?? 1); if (!Number.isFinite(qty)||qty<1) qty=1;\n  const notional=qty*pcd; let newQty=qty, action=null;\n  if (notional < SIZING.MIN_DOLLARS){ newQty=Math.ceil(SIZING.MIN_DOLLARS/pcd); action='SIZED_UP'; }\n  else if (notional > SIZING.MAX_DOLLARS){ newQty=Math.floor(SIZING.MAX_DOLLARS/pcd); action='SIZED_DOWN'; }\n  newQty=clamp(newQty,1,SIZING.MAX_CONTRACTS);\n  if (newQty!==qty){ rb.qty=String(newQty); return { action, prev_qty:qty, new_qty:newQty, pcd, prev_notional:notional, new_notional:newQty*pcd, isSpread:!!isSpread }; }\n  return null;\n}\n\n/* ---------------- main ---------------- */\nconst items = $input.all().map(x=>x?.json ?? x ?? {});\nconst approvals = new Set();\nconst weightItems = [];\n\nfor (const it of items){\n  if (it?._routeType==='trade_journal' && it.trade_id){ const pid=parseTJtoPid(it.trade_id); if (pid) approvals.add(pid); }\n  else if (it?._routeType==='pm_comms' && it.notes_for_other){ for (const pid of extractPidsFromPmComms(it.notes_for_other)) approvals.add(pid); }\n  else if (it?._routeType==='weights'){ weightItems.push(it); }\n}\n// seed from weights (intent-derived)\nfor (const w of weightItems){ const pid=String(w.play_id||'').trim(); if (pid) approvals.add(pid); }\n\nconst out=[]; const seen=new Map(); // dkey -> rank\n\nfunction diag(reason, details){ out.push({ json:{ _routeType:'diag', reason, details } }); }\n\n// Note: do NOT early-return when approvals missing; just log\nif (approvals.size===0) diag('NO_AGENT_APPROVALS_DETECTED', { hint:'proceeding without gate; approvals will be enforced when present' });\n\nfunction normalizeAndConsider(it, rank){\n  const hasPass=!!it.request_body, hasJoin=!!(it.order && it.order.ready);\n  if (!hasPass && !hasJoin) return;\n\n  let rb=null, isSpread=false;\n\n  if (hasPass){\n    rb={ ...(it.request_body||{}) };\n    if (isSpreadBody(rb)){\n      isSpread=true; rb.order_class='mleg'; rb.asset_class = rb.asset_class || 'option';\n      rb.legs=(rb.legs||[]).map(L=>({ symbol: toLongOcc(L.symbol||L.opra), side:L.side, ratio_qty:'1', position_intent: L.position_intent || legIntent(L.side) }));\n    } else {\n      rb.asset_class=rb.asset_class || 'option';\n      rb.symbol=toLongOcc(rb.symbol || it.order?.legs?.[0]?.opra || it.packet?.contract_symbol || '');\n      rb.side = rb.side || it.order?.legs?.[0]?.side || 'buy';\n      if ('position_intent' in rb) delete rb.position_intent;\n    }\n    if (rb.qty!=null) rb.qty=String(Math.max(1, Math.floor(Number(rb.qty)||1)));\n    if (!rb.limit_price && hasJoin){ const lim=pickLimitFromOrder(it.order); if (Number.isFinite(lim)&&lim>0) rb.limit_price=String(lim); }\n    else if (rb.limit_price!=null) rb.limit_price=String(rb.limit_price);\n    rb.type = rb.type || 'limit';\n    rb.time_in_force = rb.time_in_force || 'day';\n    if (SIZING.RESIZE_PASSTHROUGH){ const s=maybeResize(rb,{isSpread}); if (s) diag(s.action, { client_order_id: rb.client_order_id, ...s }); }\n\n  } else {\n    const ord=it.order, pkt=it.packet||{}; isSpread=Array.isArray(ord.legs)&&ord.legs.length>1;\n    const limit=pickLimitFromOrder(ord); if (!Number.isFinite(limit)||limit<=0) return;\n    if (!isSpread){\n      const L=ord.legs?.[0]||{}; const opra=toLongOcc(L.opra || pkt.contract_symbol || ''); const side=L.side || 'buy';\n      if (!opra||!side) return;\n      rb={ asset_class:'option', symbol:opra, qty:String(Math.max(1,Math.floor(Number(ord.qty??1)||1))), side, type:'limit', time_in_force:'day', limit_price:String(r2(limit)) };\n    } else {\n      const legs=(ord.legs||[]).map(L=>({ symbol: toLongOcc(L.opra), side:L.side, ratio_qty:'1', position_intent: legIntent(L.side) }));\n      if (legs.some(L=>!L.symbol||!L.side)) return;\n      rb={ asset_class:'option', order_class:'mleg', qty:String(Math.max(1,Math.floor(Number(ord.qty??1)||1))), type:'limit', time_in_force:'day', limit_price:String(r2(limit)), legs };\n    }\n    const s=maybeResize(rb,{isSpread}); if (s) diag(s.action, s);\n  }\n\n  const inferredPid=inferPlayIdFromBody(rb);\n  const pid=(it.play_id && String(it.play_id).trim()) || inferredPid || null;\n\n  // Gate only when approvals exist\n  if (approvals.size>0 && (!pid || !approvals.has(pid))){\n    diag('NOT_APPROVED', { explicit_pid: it.play_id, inferred_pid: inferredPid });\n    return;\n  }\n\n  // dedupe\n  let dkey='';\n  if (isSpread){\n    const legsKey=(rb.legs||[]).map(L=>`${toLongOcc(L.symbol)}|${String(L.side).toLowerCase()}`).sort().join('||');\n    dkey=`ML|${legsKey}|${rb.qty}|${rb.limit_price}`;\n  } else {\n    dkey=`SN|${toLongOcc(rb.symbol)}|${String(rb.side).toLowerCase()}|${rb.qty}|${rb.limit_price}`;\n  }\n  const prev=seen.get(dkey); if (prev!=null && prev<=rank) return; seen.set(dkey, rank);\n\n  const bodyClean=clean(rb); if (!bodyClean) return;\n\n  out.push({ json: {\n    _routeType:'orders',\n    route:'http', method:'POST',\n    base_url: DEFAULT_BASE_URL,\n    endpoint: FORCED_ENDPOINT,\n    request_body: bodyClean,\n    play_id: pid || undefined,\n    approved: approvals.size>0 ? true : undefined\n  }});\n}\n\n// pass-through first, then joiner-built\nfor (const it of items) if (it?.request_body) normalizeAndConsider(it, 0);\nfor (const it of items) if (it?.order && it.order.ready) normalizeAndConsider(it, 1);\n\nif (!out.some(x => x?.json?._routeType === 'orders')) diag('NO_MATCHING_ORDERS_EMITTED', { approvals:[...approvals] });\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4624,
        384
      ],
      "id": "6d39747f-9cf4-4b7a-bf4a-925a4860b025",
      "name": "Force Build Orders",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "url": "=https://query1.finance.yahoo.com/v8/finance/chart/{{ $json.symbol.toString().trim().toUpperCase() }}\n",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "range",
              "value": "60d"
            },
            {
              "name": "interval",
              "value": "1h"
            },
            {
              "name": "includePrePost",
              "value": "false"
            },
            {
              "name": "events",
              "value": "div,splits"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; Trading Bot)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        32
      ],
      "id": "08eb60e5-c0ea-4753-b6b8-2ae1467106f0",
      "name": "Yahoo Finance Call",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// PREOPEN \u2014 Ticker Emitter (RSS + yfinance only)\n// Outputs ONE item per ticker: { json: { symbol } } \u2014 no filters.\n// Exception: include ETF \"SPY\" (must be FIRST).\n\n// === Base universe (original) ===\nconst UNIVERSE = [\n  // Big Tech / Megacaps\n  \"AAPL\",\"MSFT\",\"NVDA\",\"AMZN\",\"META\",\"GOOGL\",\"TSLA\",\"AVGO\",\"ORCL\",\"CRM\",\n  // Semis / Chips\n  \"AMD\",\"INTC\",\"TSM\",\"QCOM\",\"MU\",\n  // Cloud / Security / SaaS\n  \"ADBE\",\"NOW\",\"PANW\",\"SNOW\",\"NET\",\"DDOG\",\"ZM\",\"AI\",\"BBAI\",\"PLTR\",\"DOCU\",\n  // Fintech / Payments / Crypto infra\n  \"XYZ\",\"PYPL\",\"AFRM\",\"SOFI\",\"CRCL\",\"UPST\",\"KLAR\",\"CHYM\",\"BLSH\",\"BULL\",\"NU\",\"TOST\",\n  // Rides / Travel / Trading / Crypto\n  \"UBER\",\"LYFT\",\"ABNB\",\"COIN\",\"HOOD\",\"MSTR\",\"RIOT\",\"MARA\",\"GEMI\",\"IREN\",\"CLSK\",\n  // Consumer / Retail / Apparel / CPG / Autos\n  \"WMT\",\"TGT\",\"COST\",\"NKE\",\"LULU\",\"AEO\",\"HSY\",\"BABA\",\"RL\",\"SJM\",\"BBW\",\"UAA\",\"CROX\",\"CVNA\",\"GPRO\",\n  // Beverage / Alt-protein / Food\n  \"KO\",\"PEP\",\"CELH\",\"MNST\",\"OTLY\",\"BYND\",\"CALM\",\"TSN\",\n  // Pets\n  \"WOOF\",\"FRPT\",\n  // EVs / Autos / Charging / Energy\n  \"NIO\",\"LI\",\"RIVN\",\"LCID\",\"RACE\",\"BLNK\",\"XPEV\",\"PLUG\",\n  // Media / Sports / Social / Gaming / Dating / Education\n  \"NFLX\",\"FOXA\",\"TKO\",\"YELP\",\"RDDT\",\"RBLX\",\"SNAP\",\"TTWO\",\"PENN\",\"DKNG\",\"FUBO\",\"WYNN\",\"FUN\",\n  \"MTCH\",\"GME\",\"CZR\",\"BMBL\",\"GRND\",\"CHGG\",\"DUOL\",\n  // Restaurants (core)\n  \"MCD\",\"SBUX\",\"BROS\",\"DPZ\",\"WING\",\"CAKE\",\"CMG\",\"CAVA\",\"SG\",\"RR\",\n  \"RRGB\",\"DNUT\",\"CBRL\",\"SHAK\",\"TXRH\",\"WEN\",\"PZZA\",\"DRI\",\"BJRI\",\"PLAY\",\"JACK\",\n  \"PTLO\",\"QSR\",\"EAT\",\"YUM\",\n  // Grocers & Club\n  \"ACI\",\"SFM\",\n  // Exchange / Platforms\n  \"CME\",\"DASH\",\"PGY\",\n  // Industrials / Utility\n  \"BA\",\"PCG\",\"ED\",\n  // Contract food service\n  \"ARMK\",\n  // Health & Wellness\n  \"PTON\",\"PLBY\",\"PLNT\",\"WW\",\"HIMS\",\n  // Design / Ordering rails\n  \"FIG\"\n];\n\n// === Additions pack (validated; includes SPY by request) ===\nconst APPENDS = [\n  // ETF exception\n  \"SPY\",\n\n  // Europe / UK (ADRs or foreign-domiciled w/ US options)\n  \"ASML\",\"NVO\",\"SAP\",\"SHEL\",\"BP\",\"BTI\",\"AZN\",\"GSK\",\"TTE\",\n  \"RIO\",\"BHP\",\"STM\",\"PHG\",\"NOK\",\"ERIC\",\"ING\",\"SAN\",\"BBVA\",\"DB\",\n  \"UBS\",\"BUD\",\"RYAAY\",\"VOD\",\"SNY\",\"NVS\",\n\n  // Japan / Taiwan\n  \"TM\",\"HMC\",\"SONY\",\"TAK\",\"UMC\",\"ASX\",\n\n  // China / HK (US-listed)\n  \"PDD\",\"JD\",\"BIDU\",\"NTES\",\"TME\",\"IQ\",\"BILI\",\"YUMC\",\"BEKE\",\n\n  // LatAm (US-listed)\n  \"MELI\",\"PBR\",\"VALE\",\"ITUB\",\"BBD\",\"SQM\",\"FMX\",\"AMX\",\"PAGS\",\"STNE\",\"DLO\",\n\n  // Canada (US-listed)\n  \"SHOP\",\"CNQ\",\"SU\",\"ENB\",\"RY\",\"TD\",\"BNS\",\"CP\",\"CNI\",\"TECK\",\"NTR\",\"CCJ\",\"KGC\",\"AG\",\n\n  // Nordics / Israel / Middle East\n  \"EQNR\",\"E\",\"HSBC\",\"TEVA\",\"NICE\",\"WIX\",\"MNDY\",\"GLBE\",\"ZIM\",\n\n  // Korea / SEA (US-listed)\n  \"CPNG\",\"FLUT\",\n\n  // Solar & materials\n  \"JKS\",\"DQ\",\"CSIQ\",\n\n  // Airlines / transport (international)\n  \"CPA\",\n\n  // U.S. high-beta / technical favorites\n  \"SMCI\",\"ARM\",\"CRWD\",\"ZS\",\"OKTA\",\"MDB\",\"TTD\",\"U\",\"PATH\",\"PINS\",\"ROKU\",\"ETSY\",\"XYZ\",\"SOUN\",\"IONQ\",\"NKLA\",\"ASTS\",\"SPCE\",\"JOBY\",\n\n  // Meme pack (optionable)\n  \"AMC\",\"BB\",\"TLRY\",\"CGC\",\"SNDL\",\"DJT\",\"RUM\",\"QS\",\"CLOV\",\"KOSS\",\"RKT\",\"GCT\",\"ENVX\",\"SAVA\",\"VFS\"\n];\n\n// === Extra user adds (intimates/lifestyle + restaurants + fun small caps) ===\nconst APPENDS_MORE = [\n  \"RICK\",\"VSCO\",\"HBI\",\"CHD\",\n  \"PBPB\",\"NDLS\",\n  \"LOVE\",\"FIGS\",\"GDRX\"\n];\n\n// --- Build final set (dedupe + normalize) and force SPY first ---\nconst combined = [...new Set([...UNIVERSE, ...APPENDS, ...APPENDS_MORE].map(t => String(t).toUpperCase()))];\nconst ordered = combined.includes(\"SPY\") ? [\"SPY\", ...combined.filter(t => t !== \"SPY\")] : combined;\n\n// n8n requires: return array of { json: { symbol } }\nreturn ordered.map(symbol => ({ json: { symbol } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        -1648
      ],
      "id": "bb2d61c2-5d53-4d54-abdd-c56393cfce8f",
      "name": "02 Expand Tickers2"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        3456,
        -1168
      ],
      "id": "a9b182de-21b9-46fe-a910-c951ad40a552",
      "name": "Calculator2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2384,
        -1536
      ],
      "id": "fc09989d-cd9f-4b82-bbbf-cf7987bceb80",
      "name": "Merge4"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Merge Macro Briefing + Portfolio Snapshot for PM\n * Input: Two items - macro briefing output, portfolio snapshot\n * Output: Single combined item for PM consumption\n */\n\nconst itemsIn = $input.all().map(i => i.json);\n\n// Initialize outputs\nlet macro_briefing = null;\nlet portfolio_snapshot = null;\nlet portfolio_meta = null;\nlet portfolio_render = null;\n\n// Process each input item\nfor (const item of itemsIn) {\n  // Check for macro briefing (has 'output' field with text)\n  if (item?.output && typeof item.output === 'string') {\n    macro_briefing = item.output;\n  }\n  \n  // Check for portfolio snapshot (has 'snapshot' or 'account' structure)\n  if (item?.snapshot) {\n    portfolio_snapshot = item.snapshot;\n    portfolio_meta = item.meta;\n    portfolio_render = item.render;\n  }\n}\n\n// Build combined output\nconst combined = {\n  macro_briefing,\n  portfolio: {\n    snapshot: portfolio_snapshot,\n    meta: portfolio_meta,\n    render: portfolio_render\n  },\n  generated_at: new Date().toISOString()\n};\n\n// Validate we got the key pieces\nconst missing = [];\nif (!macro_briefing) missing.push('macro_briefing');\nif (!portfolio_snapshot) missing.push('portfolio_snapshot');\n\nif (missing.length > 0) {\n  console.warn(`Warning: Missing ${missing.join(', ')} - PM may have incomplete context`);\n}\n\nreturn [{\n  json: combined\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2656,
        -1536
      ],
      "id": "578e8bce-f594-475a-b79d-822608ee15bd",
      "name": "Snippet for PM"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{$json}}",
        "options": {
          "systemMessage": "PM PROMPT \u2014 v4.11 \"Manage with Protected Hold Window (Proactive) \u2014 Macro-Aware, Conviction-Gated, Sheets-First Output\"\nthe PHW IS 4 hours not 24! _ GET OUT OF BAD TRADES UNLESS YIU HAVE CONVICTION ITS GOING TO GO UP\nRole: PM (Options) \u2014 trims, exits, manages; honors Executor HOLD guards; outputs broker-ready items.\nStop randomly trimming brand new plays (defined: <24h or <288 5-min bars since entry)\u2014if new, leave it unless \u22652 justifications (EV\u22640 + TA break/catalyst).\nBias: ACTIVE > passive. Risk-on temperament with GS-style judgment. Defined, informed risk. P&L symmetry. Dont just exit because of low DTE\u2014You are allowed to let some stick if conviction \u22651 (TA alignment + catalyst confirm via tools); make good judgement calls mandating perplexity search and TA for all trim/exit rationales.\n\nCore principle: We are not smarter than the market; we intend to beat it with analysis, disciplined structure selection, and highly informed risk-taking.\n\n--------------------------------------------------------------------------------\nFYI\n- DNUT 11/21: NO BID plays are to be ignored.\n- If no trade-specific plan is found: default +45% profit and \u221240% loss, still subject to PHW and conviction check.\n- PHW minimum hold: 2 hours from entry (hard floor). Set protected_until = entry_time + 3h, min_hold_bars = 36 (5-min bars), thesis_window_hours = 3. \"New\" plays: <4h default to HOLD unless overrides met. \n- Liquidity for exits: if BEST BID > 0, we go. Do not width-gate exits.\n\nMISSION\nActively manage positions with urgency and judgment. Do NOT auto-exit fresh entries during PHW. You MUST: (a) read HOLD metadata, (b) perform explicit PHW Check per trade (log status in sheets: Active/Hold | Expired/Proceed), (c) honor PHW, (d) apply Conviction Threshold (\u22651 for holds; <1 triggers trim/exit review), (e) override only via rules below.\nPHW Check Step: For each position, compute: now < protected_until? OR bars_since_entry < min_hold_bars? OR hours_since_entry < thesis_window_hours? \u2192 If yes, append \"PHW Active: No Action\" to Pm_Executor_coms and emit 0 orders.\nOutput contract: emit a single JSON ARRAY whose FIRST 3 ITEMS are sheets.append (to the tabs below), THEN 0\u2013N Alpaca options http.order items. Do NOT block on, or verify, sheet success \u2014 downstream nodes perform the appends. No prose.\n\nTOOLS (may repeat)\n- think()\n- sheets.read (intake only) / sheets.append (emit as first 3 items)\n- http.get_contract(opra)\n- http.order (emit-only; Alpaca POST https://paper-api.alpaca.markets/v2/orders)\n- http.list_open_orders(symbol)  // optional: for cancel-first guard\n- http.cancel(order_id)          // optional: for cancel-first guard\n- http.replace(order_id, body)   // optional: for fast re-quote\n- calculator.compute(numbers_only)\n- perplexity.search(query) \u2014 macro calendar/catalyst confirmation only (MANDATORY for all trim/exit rationales: \u22651 call per ticker/action; use for TA/catalyst to compute conviction).\n- Do NOT emit memory.set.\n- dont ask for multiple ticker info in same search unless sector specific- I would rather have you do one search per ticker\n\nREAD FIRST (batch)\n- sheets.read(\"Pm_Executor_coms\", 20) \u2014 latest hold_meta + run notes\n- sheets.read(\"Trade entry/exit Log\", 20) \u2014 entries, trade_id/play_id, strategies\n- sheets.read(\"PM_Actions\", 10)\n\u2014 Then, for each open position: Extract PHW status, DTE, entry_time, bars_since_entry; flag \"New\" if <24h/<288 bars.\n\nMACRO BRIEF INTAKE & MAPPING (PM-tuned)\nInputs:\n- Use inbound macro brief (executor_input.v1.market_context, or WHAT MATTERS TODAY / TECH-FUND SYNTHESIS).\n- Optionally confirm macro calendar/catalysts via perplexity.search (no chains/greeks/OPRA). Mandate \u22651 search if acting on low-DTE plays.\n\nExtract & Log:\n- Regime tag (bullish | mixed | bearish), top-3 drivers, 1\u20135 day key dates, risk flags (shutdown/CPI/FOMC/earnings/credit).\n- One-liner to run.market_view (e.g., \"Mixed-Positive: small-cap stretch; shutdown risk; VIX < 18\").\n\nMap to Management Posture (guidance, not absolute):\n- Pace: risk-on or compress-vol \u2192 harvest winners faster (but only if conviction \u22651). Risk-off or vol-expand \u2192 cut laggards faster (conviction <1 required).\n- Floors/Stops: tighten on headwind or event \u226448h; relax slightly with tailwind once PHW expires and conviction \u22651.\n- Remainders: allow only with EV>0 after \u03b8 + clear catalyst + logged recheck time + conviction \u22651.\n- Event windows: prefer flattening/downsizing weeklies; keep only justified pilots through the event if tools confirm tailwind.\n\nMACRO DISCIPLINE & NEUTRALITY\n- We are not smarter than the market; we intend to beat it with analysis, disciplined structure selection, and highly informed risk-taking.\n- Align management pace with the tape; avoid one-sided clustering; keep net delta balanced unless explicitly hedged.\n- If acting against macro skew, add a brief note in Pm_Executor_coms (\u2264120 chars).\n\nPROTECTED HOLD WINDOW (PHW)\nDo NOT close/flip if ANY true (unless using the override set):\n- HARD MIN TIME: 3h from entry (no trims/partials/closes before 3h). Implement via protected_until = entry_time + 3h, min_hold_bars = 36 (5-min bars), thesis_window_hours = 3. For \"new\" plays (<24h/<288 bars), extend effective PHW to 24h unless overrides.\n- Time guard: now < protected_until OR bars_since_entry < min_hold_bars OR hours_since_entry < thesis_window_hours.\n- DTE guard: DTE > earliest_exit_dte \u2014but override for hold if conviction \u22651 via tools.\n- Same-session no-flip: never fully close a series in the same session it was opened unless a stop/catalyst triggers.\n\nPROACTIVE MANAGEMENT BIAS\n- Harvest winners: PHW expired AND EV(hold) > 0 after \u03b8 AND BEST BID > 0 AND conviction \u22651 \u2192 scale partials and raise floors.\n- Cut laggards: EV(hold) \u2264 0 after \u03b8 OR exit_plan stop breached AND BEST BID > 0 AND conviction <1 \u2192 trim decisively or close (limit to <25% if \"new\").\n- Concentrate into conviction: reduce tiny tails (<5\u201310%) to free \u03b8/risk for higher-edge names (only if conviction <1 on tail).\n- Time-boxing: if thesis hasn't advanced by next recheck (next catalyst or next open), trim 25\u201350% (but skip if conviction \u22651 + fresh catalyst via perplexity).\n- Remainder discipline: pilots only with TA alignment + catalyst + explicit recheck time + conviction \u22651.\n- **Unhedge with conviction:** You may reduce/remove hedges (long puts, bear put spreads, collars) when conviction \u22651 (TA intact + catalyst via perplexity) and macro tailwind supports; log rationale and new net exposure in both Pm_Executor_coms and PM_Actions. PHW still applies.\n\nALLOWED EARLY-EXIT OVERRIDES (ALL must be satisfied)\n- Overrides are DISABLED during the first 24h for \"new\" plays; otherwise 3h after entry.\n1) EV(hold) \u2264 0 after theta AND R:R(exit) \u2265 1.5 (calculator.compute) \u2014but hold if conviction \u22651.\n2) TA break: key level invalidated (log \u2264120 chars) \u2014confirm via think() or perplexity.\n3) Fills: BEST BID > 0 (no width/OI gating on exits).\n4) Catalyst: perplexity confirms credible adverse catalyst (\u22652 reputable sources) or venue restriction (or tailwind for holds).\n5) Comms: append a DISAGREE note to Pm_Executor_coms explaining PHW break + time-bound plan + conviction score.\n\nCONVICTION THRESHOLD (New Section)\n- For each action: Compute score (0-2) via tools: +1 if TA intact (think()/perplexity), +1 if catalyst aligns (perplexity \u22651 call). \n- Hold/scale if \u22651; trim/exit only if <1 + EV\u22640. Log score in PM_Actions rationale.\n- Low DTE special: If DTE\u22647, require \u22651 tailwind catalyst to hold post-PHW; else trim \u226450%.\n\nLIQUIDITY & EXECUTION (exits)\n- Only requirement: BEST BID > 0.\n- Price ladder (fast): start mid \u2192 if no fill quickly, send marketable limit (sell \u2264 bid; buy \u2265 ask); allow 1\u20132 rapid re-quotes.\n- If NBBO stale but http.get_contract shows bid > 0, attempt with marketable limit; cancel/replace if rejected.\n- Entries/liquidity screening remain Executor's job; PM focuses on management/exits.\n\nBALANCED HIGH-THETA POLICY\n- Weeklies (DTE \u2264 7): trim 70\u201390% only if conviction <1 AND no catalyst in 1-2 days (confirm via perplexity \u22651 call) AT 3:50 Run for EOD once PHW expires \u2014hold/partial if conviction \u22651 + potential catalyst; pilots (10\u201330%) only if EV>0 after \u03b8 + TA + catalyst; log recheck time.\n- >1-week DTE: proactive partials to improve \u03b8 and concentration; retain remainder only if edge persists (conviction \u22651) and is logged.\n\nDEFAULTS\n- If no trade-specific plan: +45% profit / \u221240% loss governs manage decisions, still subject to PHW and conviction \u22651 for holds.\n\nTRADE HEALTH (internal; brief log only)\n- Edge (\u22122\u2026+2), Liquidity (bid>0=1 else 0), Theta burden (\u22121\u2026+1), Catalyst clarity (\u22121\u2026+1), Size vs conviction (\u22121\u2026+1). Add: Conviction (0-2).\n- Bias trims/closes when score \u2264 0 and conviction <1 and EV \u2264 0 after \u03b8; bias scale/hold when score \u2265 1 with EV > 0 and TA intact and conviction \u22651.\n\nORDERING GUARDS (pre-emit)\n- Cancel conflicting resting orders on the same series first (avoid held_for_orders/403/self-match). Use http.list_open_orders + http.cancel; if unavailable, skip the send.\n- Avoid market outside RTH; if you would send market, convert to a marketable limit at bid/ask (\u00b10.01 max).\n- Each output item must have method, url, body (object). Prices 2-dp; qty as string. All timestamps ISO-8601 with timezone.\n\n--------------------------------------------------------------------------------\nSHEETS (FIRST THREE ITEMS IN OUTPUT)\nAppend these three rows in this order (case & spacing must match tabs):\n\n1) Pm_Executor_coms \u2014 run summary for others\n   Columns: timestamp, who, ticker, action, expires, notes_for_other\n   Example row:\n   { \"timestamp\":\"<ISO>\", \"who\":\"PM\", \"ticker\":\"TSN\", \"action\":\"trim-25%\", \"expires\":\"2025-10-17\", \"notes_for_other\":\"post-PHW trim; VIX<18; bid>0 ; conviction=1\" }\n\n2) PM_Actions \u2014 internal notes and severity\n   Columns: notes_to_self, severity, date, time, rationale\n   Example row:\n   { \"notes_to_self\":\"raise floor; recheck 14:30 ET\", \"severity\":\"watch\", \"date\":\"2025-09-30\", \"time\":\"14:23:00-04:00\", \"rationale\":\"EV<=0 after \u03b8 or stop hit ; conviction=0; perplexity: no catalyst\" }\n\n3) Trade entry/exit Log \u2014 trade-level journal adherence\n   Columns: trade_id, symbol, strategy, direction, rationale, risk_rating, exit_plan\n   Example row:\n   { \"trade_id\":\"PM-20250930-TSN-ps-exit-2\", \"symbol\":\"TSN\", \"strategy\":\"bull_put_spread\", \"direction\":\"TRIM\", \"rationale\":\"near support; PHW expired; bid>0 ; conviction<1\", \"risk_rating\":\"MED\", \"exit_plan\":\"targets 40\u201360%; stop under L; recheck next open\" }\n\n--------------------------------------------------------------------------------\nALPACA REST (direct HTTP, options only)\n- Endpoint: https://paper-api.alpaca.markets/v2/orders\n- Singles: { \"type\":\"limit\", \"limit_price\":\"x.xx\", \"time_in_force\":\"day\" }\n- Multi-leg exits: { \"order_class\":\"mleg\", \"type\":\"limit\", \"limit_price\":\"x.xx\", \"time_in_force\":\"day\", \"legs\":[{ symbol, side, ratio_qty }] }\n- Do NOT include position_effect. (Optional position_intent not required.)\n\nFINAL OUTPUT (JSON array, no prose)\nRequired contract: emit THREE sheets.append items \u2014 \"Pm_Executor_coms\", \"PM_Actions\", \"Trade entry/exit Log\" \u2014 THEN 0\u2013N Alpaca options http.order items.\n\nEnvelope \u2014 SHEETS APPEND\n{\n  \"kind\": \"sheets.append\",\n  \"sheet\": \"Pm_Executor_coms | PM_Actions | Trade entry/exit Log\",\n  \"row\": { /* columns per section above */ }\n}\n\nEnvelope \u2014 ALPACA ORDER\n{\n  \"kind\": \"http.order\",\n  \"method\": \"POST\",\n  \"url\": \"https://paper-api.alpaca.markets/v2/orders\",\n  \"body\": { /* single-leg or mleg, see below */ }\n}\n\nBody \u2014 SINGLE-LEG\n{\n  \"symbol\":\"<OPRA>\",\n  \"qty\":\"<string e.g. \\\"3\\\">\",\n  \"side\":\"buy|sell\",\n  \"type\":\"limit\",\n  \"limit_price\":\"x.xx\",\n  \"time_in_force\":\"day\",\n  \"client_order_id\":\"PM-<yyyymmdd>-<root>-<action>-<qty>-<seq>\"\n}\n\nBody \u2014 MULTI-LEG\n{\n  \"order_class\":\"mleg\",\n  \"qty\":\"<string>\",\n  \"type\":\"limit\",\n  \"limit_price\":\"x.xx\",\n  \"time_in_force\":\"day\",\n  \"legs\":[\n    {\"symbol\":\"<OPRA1>\",\"side\":\"buy|sell\",\"ratio_qty\":\"1\"},\n    {\"symbol\":\"<OPRA2>\",\"side\":\"buy|sell\",\"ratio_qty\":\"1\"}\n  ],\n  \"client_order_id\":\"PM-<yyyymmdd>-<root>-<pair>-<qty>-<seq>\"\n}\n\nHard constraints\n- First three items MUST be sheets.append to: Pm_Executor_coms, PM_Actions, Trade entry/exit Log (in this order).\n- limit_price has 2 decimals. qty and legs[].ratio_qty are strings.\n- No position_effect. No market orders (use marketable limits). client_order_id \u2264 48 chars & unique.\n- Options endpoint only; do not send equity /v2/orders.\n\nExample output (3 appends + 1 order)\n[\n  {\"kind\":\"sheets.append\",\"sheet\":\"Pm_Executor_coms\",\"row\":{\"timestamp\":\"2025-09-30T14:35:00-04:00\",\"who\":\"PM\",\"ticker\":\"TSN\",\"action\":\"trim-25%\",\"expires\":\"2025-10-17\",\"notes_for_other\":\"post-PHW trim; VIX<18; bid>0 ; conviction=1\"}},\n  {\"kind\":\"sheets.append\",\"sheet\":\"PM_Actions\",\"row\":{\"notes_to_self\":\"raise floor; recheck 14:30 ET\",\"severity\":\"watch\",\"date\":\"2025-09-30\",\"time\":\"14:35:00-04:00\",\"rationale\":\"EV<=0 after \u03b8 or stop hit ; conviction=0; perplexity: no catalyst\"}},\n  {\"kind\":\"sheets.append\",\"sheet\":\"Trade entry/exit Log\",\"row\":{\"trade_id\":\"PM-20250930-TSN-ps-exit-2\",\"symbol\":\"TSN\",\"strategy\":\"bull_put_spread\",\"direction\":\"TRIM\",\"rationale\":\"near support; PHW expired; bid>0 ; conviction<1\",\"risk_rating\":\"MED\",\"exit_plan\":\"targets 40\u201360%; stop under L; recheck next open\"}},\n  {\"kind\":\"http.order\",\"method\":\"POST\",\"url\":\"https://paper-api.alpaca.markets/v2/orders\",\"body\":{\"order_class\":\"mleg\",\"qty\":\"2\",\"type\":\"limit\",\"limit_price\":\"0.45\",\"time_in_force\":\"day\",\"legs\":[{\"symbol\":\"TSN251017P00052500\",\"side\":\"buy\",\"ratio_qty\":\"1\"},{\"symbol\":\"TSN251017P00055000\",\"side\":\"sell\",\"ratio_qty\":\"1\"}],\"client_order_id\":\"PM-20250930-TSN-ps-exit-2\"}}\n]",
          "maxIterations": 15,
          "batching": {
            "batchSize": 1
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        3120,
        -1536
      ],
      "id": "5fb40848-1e73-42e6-b6e6-8b6420320d93",
      "name": "Portfolio Manager"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * Portfolio + Chains Snapshot Builder (v4.3 \u2014 robust merge-node ingestion)\n *\n * Fixes:\n *  1) Collects positions even when each position arrives as a single item (not inside `positions` array).\n *  2) Expands `snapshots` and `contracts` when they arrive as object maps keyed by OPRA; injects `opra`/`symbol`.\n *  3) Aggregates **vendor Greeks** for portfolio net exposures (delta/gamma/theta/vega) with qty & side & CM.\n *  4) Keeps Black\u2013Scholes as fallback (requires S, T, IV) and reports both vendor & BS where available.\n *  5) Pairs spreads from positions alone (no snapshot required for pairing), uses `current_price`/`avg_entry_price`.\n *\n * Config (seed.config):\n *  - contract_multiplier: number (default 100)\n *  - risk_free_rate: number annual (optional)\n *  - div_yield: number annual (optional)\n *  - asof: ISO date (YYYY-MM-DD, optional)\n *  - chain_scope: 'held' | 'universe'  (default 'held')\n *  - ta_scope:    'held' | 'all'       (default 'held')\n *  - include_universe_if_no_positions: boolean (default true)\n *  - dte_alert_days: number (default 3)\n */\n\n//////////////////////////// Utilities ////////////////////////////\n\nconst ROOT = (typeof $json !== 'undefined' && $json) ? $json\n           : (typeof globalThis !== 'undefined' && globalThis.__SEED__) ? globalThis.__SEED__\n           : {};\n\nconst CFG = (() => {\n  const cfg = ROOT.config || {};\n  const CM  = Number(cfg.contract_multiplier ?? 100);\n  const RFR = (cfg.risk_free_rate != null) ? Number(cfg.risk_free_rate) : null;\n  const DIV = (cfg.div_yield      != null) ? Number(cfg.div_yield)      : null;\n  const asof =\n    (cfg.asof && String(cfg.asof).slice(0,10)) ||\n    (Array.isArray(ROOT.accounts) && ROOT.accounts[0]?.balance_asof) ||\n    new Date().toISOString().slice(0,10);\n  const chain_scope = (cfg.chain_scope || 'held').toLowerCase();\n  const ta_scope    = (cfg.ta_scope    || 'held').toLowerCase();\n  const include_universe_if_no_positions = (cfg.include_universe_if_no_positions != null)\n    ? !!cfg.include_universe_if_no_positions : true; // default TRUE per real-world usage\n  const dte_alert_days = Number.isFinite(+cfg.dte_alert_days) ? +cfg.dte_alert_days : 3;\n\n  return { CM, RFR, DIV, asof, chain_scope, ta_scope, include_universe_if_no_positions, dte_alert_days };\n})();\n\nconst r  = (x, p=2) => (Number.isFinite(+x) ? Number((Math.round(+x*10**p)/10**p).toFixed(p)) : null);\nconst nz = (x, d=0)  => (Number.isFinite(+x)  ? +x : d);\nconst asc = (a,b)=> (a<b?-1:(a>b?1:0));\nconst sgn = (x)=> (x<0?-1:(x>0?1:0));\n\nfunction toISODateUTC(d){\n  if (!d || Number.isNaN(new Date(d).getTime())) return null;\n  const dt = new Date(d);\n  return new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate())).toISOString().slice(0,10);\n}\nfunction daysDiffUTC(aDate, bDate){\n  if (!aDate || !bDate) return null;\n  const a = new Date(aDate), b = new Date(bDate);\n  const ms = Date.UTC(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate()) -\n             Date.UTC(b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate());\n  return Math.round(ms / (1000*60*60*24));\n}\nfunction fmtUSD(x){ return x==null ? '-' : `$${r(x,2).toLocaleString()}`; }\nfunction sum(arr){ return arr.reduce((a,b)=> a + (Number.isFinite(b)?b:0), 0); }\nfunction median(arr){\n  const v = arr.filter(Number.isFinite).sort((a,b)=>a-b);\n  const n = v.length; if (!n) return null;\n  return (n%2? v[(n-1)/2] : (v[n/2-1]+v[n/2])/2);\n}\n\n/** OCC/OPRA: ABCDYYMMDDC|P######## \u2192 { under, expiry(UTC), type:'call'|'put', strike } */\nfunction parseOPRA(s){\n  if (!s || typeof s!=='string') return null;\n  const m = s.toUpperCase().match(/^([A-Z.]{1,6})(\\d{2})(\\d{2})(\\d{2})([CP])(\\d{8})$/);\n  if (!m) return null;\n  const under = m[1];\n  const yy = 2000 + Number(m[2]), mm = Number(m[3]), dd = Number(m[4]);\n  const type = m[5] === 'C' ? 'call' : 'put';\n  const strike = Number(m[6]) / 1000;\n  const expiry = toISODateUTC(new Date(Date.UTC(yy,mm-1,dd)));\n  return { under, expiry, type, strike };\n}\n\n//////////////////// Input collection + readers ////////////////////\n\nfunction collectTAFromAny(obj, out){\n  if (!obj) return;\n  if (Array.isArray(obj)) { for (const v of obj) collectTAFromAny(v, out); return; }\n  if (typeof obj === 'object'){\n    if (obj.symbol && obj.frames && (obj.frames.hour || obj.frames.day || obj.frames.week)) {\n      out.push({ symbol:String(obj.symbol).toUpperCase(), frames: obj.frames });\n    }\n    for (const v of Object.values(obj)) collectTAFromAny(v, out);\n  }\n}\n\nfunction readAccount(accts){\n  const a = (Array.isArray(accts) ? accts[0] : accts) || {};\n  return {\n    account_number: a.account_number || 'primary',\n    status: a.status || 'UNKNOWN',\n    currency: a.currency || 'USD',\n    equity: nz(a.equity),\n    cash: nz(a.cash),\n    buying_power: nz(a.buying_power || a.regt_buying_power || a.effective_buying_power),\n    options_buying_power: nz(a.options_buying_power),\n    portfolio_value: nz(a.portfolio_value),\n    long_market_value: nz(a.long_market_value),\n    short_market_value: nz(a.short_market_value),\n    sma: nz(a.sma),\n    pattern_day_trader: !!a.pattern_day_trader,\n    shorting_enabled: !!a.shorting_enabled,\n    created_at: a.created_at,\n    balance_asof: a.balance_asof || CFG.asof\n  };\n}\n\n// contracts: accept many shapes, synthesize opra if missing but all fields exist\nfunction readContractLike(obj){\n  const sym = obj.symbol || obj.contract || obj.opra || null;\n  const occ = parseOPRA(sym || '');\n  const under = (obj.underlying_symbol || obj.underlying || obj.under || occ?.under || '').toUpperCase() || null;\n  const typeRaw = (obj.type || obj.option_type || (occ?.type) || '').toString().toLowerCase();\n  const type = typeRaw.startsWith('c') ? 'call' : (typeRaw.startsWith('p') ? 'put' : (occ?.type || null));\n  const strike = (obj.strike_price ?? obj.strike ?? occ?.strike ?? null);\n  const expiry = toISODateUTC(obj.expiration_date || obj.expiry || occ?.expiry || null);\n  const status = obj.status || null;\n  const opra = (sym && parseOPRA(sym)) ? sym.toUpperCase()\n              : (under && type && strike!=null && expiry\n                 ? `${under}${String(new Date(expiry).getUTCFullYear()).slice(2)}${String(new Date(expiry).getUTCMonth()+1).padStart(2,'0')}${String(new Date(expiry).getUTCDate()).padStart(2,'0')}${type==='call'?'C':'P'}${String(Math.round(Number(strike)*1000)).padStart(8,'0')}` : null);\n  if (!(under && type && expiry && Number.isFinite(+strike))) return null;\n  return { opra, under, type, strike:Number(strike), expiry, status };\n}\n\n// snapshots: robust extraction + tolerate opra injected by map expander\nfunction readSnapshotLike(s){\n  const sym = s.opra || s.symbol || s.contract || s?.latestQuote?.symbol || null;\n  const occ = parseOPRA(sym || '');\n  if (!occ) return null;\n\n  const bestBid = (s.latestQuote && Number.isFinite(+s.latestQuote.bp)) ? +s.latestQuote.bp : null;\n  const bestAsk = (s.latestQuote && Number.isFinite(+s.latestQuote.ap)) ? +s.latestQuote.ap : null;\n  const midFromQuote = (bestBid!=null && bestAsk!=null) ? r((bestBid+bestAsk)/2, 4) : null;\n  const lastTrade = (s.latestTrade && Number.isFinite(+s.latestTrade.p)) ? +s.latestTrade.p : null;\n  const mid = (midFromQuote!=null) ? midFromQuote : lastTrade;\n\n  const spread_pct = (bestBid!=null && bestAsk!=null && bestAsk>0) ? r(((bestAsk-bestBid)/bestAsk)*100, 3) : null;\n  const liq = (bestBid!=null || bestAsk!=null || s.latestQuote?.bs!=null || s.latestQuote?.as!=null)\n    ? { bid:bestBid??null, ask:bestAsk??null, bs:s.latestQuote?.bs??null, as:s.latestQuote?.as??null,\n        bx:s.latestQuote?.bx??null, ax:s.latestQuote?.ax??null, spread_pct }\n    : null;\n\n  // Vendor greeks/IV\n  const iv = (s.greeks?.impliedVolatility != null) ? +s.greeks.impliedVolatility\n           : (s.impliedVolatility != null ? +s.impliedVolatility : null);\n  const greeks = s.greeks ? {\n    delta:  (s.greeks.delta  != null ? +s.greeks.delta  : null),\n    gamma:  (s.greeks.gamma  != null ? +s.greeks.gamma  : null),\n    theta:  (s.greeks.theta  != null ? +s.greeks.theta  : null),\n    vega:   (s.greeks.vega   != null ? +s.greeks.vega   : null),\n    rho:    (s.greeks.rho    != null ? +s.greeks.rho    : null)\n  } : null;\n\n  const bars = { minute: s.minuteBar || null, daily: s.dailyBar || null, prev: s.prevDailyBar || null };\n  const asof = s.latestQuote?.t || s.latestTrade?.t || s.dailyBar?.t || null;\n\n  return {\n    opra: sym.toUpperCase(),\n    under: occ.under, type: occ.type, strike: occ.strike, expiry: occ.expiry,\n    curr: mid ?? null, iv, liq, greeks, bars, asof\n  };\n}\n\n//////////////////////////// TA helpers ////////////////////////////\n\nfunction buildTAIndex(ta_frames, heldSet, scope='held'){\n  const restrict = (scope==='held');\n  const idx = new Map();\n  for (const f of ta_frames || []){\n    const sym = String(f.symbol || '').toUpperCase();\n    if (!sym || (restrict && heldSet && !heldSet.has(sym))) continue;\n    const frames = f.frames || {};\n    const pick = (name) => {\n      const fr = frames[name];\n      if (!fr) return null;\n      const sig = fr.signals || fr;\n      return {\n        direction: sig.direction || null,\n        score: sig.score ?? null,\n        reasons: Array.isArray(sig.reasons) ? sig.reasons : (sig.reasons ? [sig.reasons] : []),\n        currentPrice: fr.currentPrice ?? null,\n        support: fr.support ?? null,\n        resistance: fr.resistance ?? null,\n        expected_move_week: fr.expectedMoves?.oneWeek ?? null,\n        expected_move_month: fr.expectedMoves?.oneMonth ?? null\n      };\n    };\n    const rec = { symbol: sym, day: pick('day'), hour: pick('hour'), week: pick('week') };\n    const dominantDir = rec.day?.direction || rec.hour?.direction || rec.week?.direction || 'Neutral';\n    const dominantScore = rec.day?.score ?? rec.hour?.score ?? rec.week?.score ?? null;\n    const currentPrice = rec.day?.currentPrice ?? rec.hour?.currentPrice ?? rec.week?.currentPrice ?? null;\n    idx.set(sym, { symbol: sym, dominant: { direction: dominantDir, score: dominantScore }, frames: rec, currentPrice });\n  }\n  return idx;\n}\n\n///////////////////////// Black\u2013Scholes Greeks /////////////////////\n\nfunction erf(x){\n  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;\n  const sign = x<0 ? -1 : 1; x = Math.abs(x);\n  const t = 1/(1+p*x);\n  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);\n  return sign*y;\n}\nfunction normCdf(x){ return 0.5*(1+erf(x/Math.SQRT2)); }\nfunction normPdf(x){ return Math.exp(-0.5*x*x)/Math.sqrt(2*Math.PI); }\nfunction bsGreeks({ S, K, T, r=0, q=0, iv, type }){\n  if (!(S>0 && K>0 && T>=0 && iv>0)) return null;\n  const sqrtT = Math.sqrt(Math.max(T, 1e-8));\n  const d1 = (Math.log(S/K) + (r - q + 0.5*iv*iv)*T) / (iv*sqrtT);\n  const d2 = d1 - iv*sqrtT;\n  const delta = (type==='call') ? Math.exp(-q*T)*normCdf(d1) : -Math.exp(-q*T)*normCdf(-d1);\n  const gamma = Math.exp(-q*T)*normPdf(d1)/(S*iv*sqrtT);\n  const theta = -(S*normPdf(d1)*iv*Math.exp(-q*T))/(2*sqrtT)\n              - (type==='call'\n                  ? r*K*Math.exp(-r*T)*normCdf(d2) - q*S*Math.exp(-q*T)*normCdf(d1)\n                  : -r*K*Math.exp(-r*T)*normCdf(-d2) + q*S*Math.exp(-q*T)*normCdf(-d1));\n  const vega  = S*Math.exp(-q*T)*normPdf(d1)*sqrtT;\n  return { delta, gamma, theta, vega };\n}\n\n//////////////////////// Normalizers + pairing //////////////////////\n\nfunction normalizeLeg(p){\n  // Accept Alpaca/vendored option position OR already-normalized leg\n  const tryStrings = [String(p.opra||''), String(p.symbol||''), String(p.contract_symbol||'')].filter(Boolean);\n  let occ = null; for (const s of tryStrings){ occ = parseOPRA(s); if (occ) break; }\n\n  const under   = (occ?.under) || String(p.under || p.underlying || p.root_symbol || p.symbol || '').toUpperCase() || null;\n  const type    = (occ?.type)  || (p.type ? String(p.type).toLowerCase() : null);\n  const strike  = (occ?.strike)!=null ? Number(occ.strike) : (p.strike!=null ? Number(p.strike) : (p.strike_price!=null ? Number(p.strike_price) : null));\n  const expiry  = (occ?.expiry) || toISODateUTC(p.expiry || p.expiration_date);\n\n  const rawSide = String(p.side || p.position_side || '').toLowerCase();\n  let side = (rawSide==='long' || rawSide==='buy' ? 'long' : null);\n  if (!side){\n    const q = nz(p.qty ?? p.quantity);\n    side = (q >= 0 ? 'long' : 'short');\n  }\n  const qty = Math.abs(nz(p.qty ?? p.quantity, 0));\n\n  const avg_entry  = (p.avg_entry ?? p.avg_entry_price ?? p.average_entry_price ?? null);\n  const curr       = (p.curr ?? p.current_price ?? p.market_price ?? null);\n  const cost_basis = (p.cost_basis != null) ? Number(p.cost_basis)\n                    : (Number.isFinite(+avg_entry) ? +avg_entry * CFG.CM * qty * (side==='long'?+1:-1) : null);\n  const mkt_value  = (p.mkt_value != null) ? Number(p.mkt_value)\n                    : (Number.isFinite(+curr) ? +curr * CFG.CM * qty * (side==='long'?+1:-1) : null);\n  const unrealized_pl = (p.unrealized_pl != null) ? Number(p.unrealized_pl)\n                        : (Number.isFinite(mkt_value) && Number.isFinite(cost_basis) ? (mkt_value - cost_basis) : null);\n\n  if (!under || !type || !expiry || !Number.isFinite(strike) || !qty || !side) return null;\n\n  const iv = (p.iv_annual!=null) ? Number(p.iv_annual)\n           : (p.implied_volatility!=null) ? Number(p.implied_volatility)\n           : (p.iv!=null) ? Number(p.iv) : null;\n\n  return {\n    opra: occ ? tryStrings.find(s => !!parseOPRA(s)) : (p.opra || null),\n    under, type, strike, expiry, side, qty,\n    avg_entry: Number.isFinite(+avg_entry) ? +avg_entry : null,\n    curr:      Number.isFinite(+curr)      ? +curr      : null,\n    cost_basis: Number.isFinite(+cost_basis) ? +cost_basis : null,\n    mkt_value:  Number.isFinite(+mkt_value)  ? +mkt_value  : null,\n    unrealized_pl: Number.isFinite(+unrealized_pl) ? +unrealized_pl : null,\n    iv,\n    liq: p.liq || null\n  };\n}\n\nfunction pairVerticals(legs){\n  const key = L => `${L.under}|${L.type}|${L.expiry}`;\n  const groups = new Map();\n  for (const L of legs){ const k = key(L); if (!groups.has(k)) groups.set(k, []); groups.get(k).push(L); }\n  const spreads = []; const residualSingles = [];\n\n  for (const [, arr] of groups){\n    const longs  = arr.filter(x => x.side==='long').map(x => ({ leg:x, remain:x.qty }));\n    const shorts = arr.filter(x => x.side==='short').map(x => ({ leg:x, remain:x.qty }));\n\n    function pickShortFor(longLeg){\n      const typ = longLeg.leg.type, ls = longLeg.leg.strike;\n      let candsPrimary = [], candsSecondary = [];\n      if (typ==='call'){ candsPrimary = shorts.filter(s=>s.remain>0 && s.leg.strike>ls); candsSecondary=shorts.filter(s=>s.remain>0 && s.leg.strike<ls); }\n      else{ candsPrimary = shorts.filter(s=>s.remain>0 && s.leg.strike<ls); candsSecondary=shorts.filter(s=>s.remain>0 && s.leg.strike>ls); }\n      const sortNearest = (a,b)=> Math.abs(a.leg.strike-ls)-Math.abs(b.leg.strike-ls);\n      candsPrimary.sort(sortNearest); candsSecondary.sort(sortNearest);\n      return (candsPrimary[0] || candsSecondary[0] || null);\n    }\n\n    longs.sort((a,b)=> a.leg.strike - b.leg.strike);\n    for (const L of longs){\n      while (L.remain > 0){\n        const S = pickShortFor(L); if (!S) break;\n        const comboQty = Math.min(L.remain, S.remain); if (comboQty<=0) break;\n        const long = L.leg, short = S.leg;\n        const width = Math.abs(short.strike - long.strike);\n        let structure = null;\n        if (long.type==='call'){ structure = (long.strike < short.strike) ? 'Bull Call Spread' : 'Bear Call Spread'; }\n        else{ structure = (long.strike > short.strike) ? 'Bear Put Spread' : 'Bull Put Spread'; }\n\n        const pxL = Number.isFinite(+long.curr) ? +long.curr : (Number.isFinite(+long.avg_entry) ? +long.avg_entry : 0);\n        const pxS = Number.isFinite(+short.curr)? +short.curr: (Number.isFinite(+short.avg_entry)? +short.avg_entry: 0);\n        const net = r(pxL - pxS, 4);\n        const isDebit = net > 0, isCredit = net < 0;\n        let maxProfit=null, maxLoss=null;\n        if (isDebit){ maxProfit=r((width - Math.abs(net))*CFG.CM,2); maxLoss=r(Math.abs(net)*CFG.CM,2); }\n        else if (isCredit){ maxProfit=r(Math.abs(net)*CFG.CM,2); maxLoss=r((width - Math.abs(net))*CFG.CM,2); }\n        else { maxProfit=r(width*CFG.CM,2); maxLoss=r(width*CFG.CM,2); }\n\n        const pnlPerUnitLong  = Number.isFinite(+long.unrealized_pl)  && long.qty  ? (+long.unrealized_pl  / long.qty)  : 0;\n        const pnlPerUnitShort = Number.isFinite(+short.unrealized_pl) && short.qty ? (+short.unrealized_pl / short.qty) : 0;\n        const pnlPerUnitSpread = r(pnlPerUnitLong + pnlPerUnitShort, 2);\n        const pnlTotalSpread   = r(pnlPerUnitSpread * comboQty, 2);\n\n        const entryLong  = Number.isFinite(+long.avg_entry)  ? +long.avg_entry  : null;\n        const entryShort = Number.isFinite(+short.avg_entry) ? +short.avg_entry : null;\n        const basis_per_combo = (entryLong!=null && entryShort!=null) ? r((entryLong - entryShort) * CFG.CM, 2) : null;\n        const basis_total     = (basis_per_combo!=null) ? r(basis_per_combo * comboQty, 2) : null;\n\n        spreads.push({\n          under: long.under, type: long.type, expiry: long.expiry, structure, width, qty: comboQty,\n          long:  { opra: long.opra,  strike: long.strike,  side:'long',  avg_entry: long.avg_entry,  curr: long.curr,  liq: long.liq || null, iv: long.iv ?? null },\n          short: { opra: short.opra, strike: short.strike, side:'short', avg_entry: short.avg_entry, curr: short.curr, liq: short.liq || null, iv: short.iv ?? null },\n          net_mid_per_combo: net,\n          max_profit_per_combo: maxProfit, max_loss_per_combo:  maxLoss,\n          basis_per_combo, basis_total,\n          _pnl: { per_unit: pnlPerUnitSpread, total: pnlTotalSpread }\n        });\n\n        L.remain -= comboQty; S.remain -= comboQty;\n      }\n    }\n    for (const L of longs)  if (L.remain > 0) residualSingles.push({ ...L.leg, qty: L.remain });\n    for (const S of shorts) if (S.remain > 0) residualSingles.push({ ...S.leg, qty: S.remain });\n  }\n  return { spreads, singles: residualSingles };\n}\n\n//////////////////////////// Collector /////////////////////////////\n\nfunction collectInput(){\n  const items = (typeof $input !== 'undefined' && typeof $input.all === 'function')\n    ? $input.all().map(x => x.json || {})\n    : (typeof globalThis !== 'undefined' && Array.isArray(globalThis.__ITEMS__) ? globalThis.__ITEMS__ : []);\n  const seed  = ROOT;\n\n  const accounts=[]; const positions=[]; const ta_frames=[];\n  const contractsRaw=[]; const snapshotsRaw=[]; const orders_in = seed.orders || seed.open_orders || null;\n\n  const pushArr = (src, into) => { if (Array.isArray(src)) into.push(...src); else if (src) into.push(src); };\n\n  // seed-level\n  if (Array.isArray(seed.accounts) || seed.accounts) pushArr(seed.accounts, accounts);\n  if (Array.isArray(seed.positions)) pushArr(seed.positions, positions);\n  if (Array.isArray(seed.ta_frames)) pushArr(seed.ta_frames, ta_frames);\n  collectTAFromAny(seed, ta_frames);\n  if (seed.contracts || seed.results) pushArr(seed.contracts || seed.results, contractsRaw);\n  if (seed.snapshots) {\n    // accept array or map keyed by OPRA\n    if (Array.isArray(seed.snapshots)) pushArr(seed.snapshots, snapshotsRaw);\n    else if (typeof seed.snapshots === 'object'){\n      for (const [opra, snap] of Object.entries(seed.snapshots)) snapshotsRaw.push({ ...snap, opra });\n    }\n  }\n\n  // items-level\n  for (const it of items){\n    if (Array.isArray(it.accounts) || it.account_number) pushArr(it.accounts||it, accounts);\n\n    // positions: accept array OR single item that \"looks like\" an option position\n    if (Array.isArray(it.positions)) pushArr(it.positions, positions);\n    const looksLikePosition = !!(\n      (it.asset_class && String(it.asset_class).toLowerCase().includes('option')) ||\n      parseOPRA(it.symbol || it.contract_symbol || it.opra || '') ||\n      (it.qty!=null && (it.avg_entry_price!=null || it.current_price!=null || it.side))\n    );\n    if (looksLikePosition) positions.push(it);\n\n    // TA anywhere\n    if (Array.isArray(it.ta_frames)) pushArr(it.ta_frames, ta_frames);\n    collectTAFromAny(it, ta_frames);\n\n    // contracts as list/map\n    if (it.endpoint === 'contracts' && (it.results || it.contracts)) pushArr(it.results||it.contracts, contractsRaw);\n    if (it.contracts && typeof it.contracts === 'object' && !Array.isArray(it.contracts)){\n      for (const [symbol, c] of Object.entries(it.contracts)) contractsRaw.push({ ...c, symbol });\n    }\n    if (it.underlying_symbol || it.expiration_date || (it.symbol && parseOPRA(it.symbol))) contractsRaw.push(it);\n\n    // snapshots as one-per-item or as a map\n    if (it.latestQuote || it.greeks || it.dailyBar || it.minuteBar || it.prevDailyBar || it.opra) snapshotsRaw.push(it);\n    else if (it.endpoint==='snapshots' && (it.data || it.snapshots)) pushArr(it.data || it.snapshots, snapshotsRaw);\n    if (it.snapshots && typeof it.snapshots === 'object' && !Array.isArray(it.snapshots)){\n      for (const [opra, snap] of Object.entries(it.snapshots)) snapshotsRaw.push({ ...snap, opra });\n    }\n  }\n\n  // dedupe TA by symbol\n  const taUniq = []; const seenTA = new Set();\n  for (const t of ta_frames){\n    const sym = String(t.symbol||'').toUpperCase(); if (!sym || seenTA.has(sym)) continue;\n    seenTA.add(sym); taUniq.push({ symbol:sym, frames:t.frames||{} });\n  }\n\n  return { accounts, positions, ta_frames: taUniq, contractsRaw, snapshotsRaw, orders_in };\n}\n\n//////////////////////////// Build /////////////////////////////////\n\nfunction build(){\n  const { accounts, positions: rawPositions, ta_frames, contractsRaw, snapshotsRaw, orders_in } = collectInput();\n  const account = readAccount(accounts);\n  const asofISO = CFG.asof;\n\n  // Index contracts & snapshots\n  const CONTRACT = new Map();     // OPRA -> {opra, under, type, strike, expiry, status}\n  const BYUNDER  = new Map();     // UNDER -> Set(OPRA)\n  const seenBadContracts = [];\n\n  for (const c0 of contractsRaw){\n    const c = readContractLike(c0);\n    if (!c || !c.opra) { seenBadContracts.push(c0); continue; }\n    CONTRACT.set(c.opra, c);\n    const U = c.under.toUpperCase(); if (!BYUNDER.has(U)) BYUNDER.set(U, new Set());\n    BYUNDER.get(U).add(c.opra);\n  }\n\n  const SNAP = new Map(); // OPRA -> snapshot (liq, iv, greeks, curr, bars, asof)\n  for (const s0 of snapshotsRaw){\n    const s = readSnapshotLike(s0); if (!s || !s.opra) continue;\n    SNAP.set(s.opra, s);\n    if (!BYUNDER.has(s.under)) BYUNDER.set(s.under, new Set());\n    BYUNDER.get(s.under).add(s.opra);\n    if (!CONTRACT.has(s.opra)) {\n      CONTRACT.set(s.opra, { opra:s.opra, under:s.under, type:s.type, strike:s.strike, expiry:s.expiry, status:null });\n    }\n  }\n\n  // Canonicalize positions (options only)\n  const legsAll = [];\n  const positionsUnmatched = [];\n  for (const p of rawPositions || []){\n    const isOptionish = parseOPRA(String(p.opra||p.symbol||p.contract_symbol||'')) ||\n                        ((p.type && p.expiry && (p.strike!=null)) || (p.asset_class && String(p.asset_class).toLowerCase().includes('option')));\n    if (!isOptionish) continue;\n    const L = normalizeLeg(p);\n    if (!L) { positionsUnmatched.push(p); continue; }\n\n    // ensure OPRA\n    if (!L.opra){\n      const keyMatch = [...CONTRACT.values()].find(c =>\n        c.under===L.under && c.type===L.type && c.expiry===L.expiry && Number(c.strike)===Number(L.strike));\n      if (keyMatch) L.opra = keyMatch.opra;\n      else {\n        // synthesize OPRA if missing but fields exist\n        const y = String(new Date(L.expiry).getUTCFullYear()).slice(2);\n        const m = String(new Date(L.expiry).getUTCMonth()+1).padStart(2,'0');\n        const d = String(new Date(L.expiry).getUTCDate()).padStart(2,'0');\n        const t = (L.type==='call'?'C':'P');\n        const k = String(Math.round(Number(L.strike)*1000)).padStart(8,'0');\n        L.opra = `${L.under}${y}${m}${d}${t}${k}`;\n      }\n    }\n\n    // Merge snapshot if available\n    if (L.opra && SNAP.has(L.opra)){\n      const sn = SNAP.get(L.opra);\n      L.curr = (sn.curr ?? L.curr ?? null);\n      L.iv   = (sn.iv!=null) ? sn.iv : (L.iv ?? null);\n      L.liq  = sn.liq || L.liq || null;\n      L._asof = sn.asof || null;\n      if (sn.greeks) L._vendor_greeks = sn.greeks;  // attach vendor greeks for net aggregation\n    }\n\n    legsAll.push(L);\n  }\n\n  // Pair spreads from positions ONLY\n  const { spreads, singles } = pairVerticals(legsAll);\n\n  // Held set\n  const heldSet = new Set([\n    ...singles.map(L => L.under),\n    ...spreads.map(S => S.under)\n  ].map(s => String(s||'').toUpperCase()));\n\n  // TA index (scope)\n  const TA = buildTAIndex(ta_frames, heldSet, CFG.ta_scope);\n  const priceOf = sym => (TA.get(sym)?.currentPrice ?? null);\n\n  // DTE helper\n  const dteOf = (iso) => daysDiffUTC(iso, asofISO);\n\n  // DTE queue\n  const dteQueue = [\n    ...singles.map(L => ({ key:`${L.under} ${L.expiry} ${L.type} ${L.strike} ${L.side}`, under:L.under, expiry:L.expiry, dte:dteOf(L.expiry), type:L.type, strike:L.strike, side:L.side, qty:L.qty, warning:(dteOf(L.expiry)!=null && dteOf(L.expiry) < CFG.dte_alert_days)?'(warning)':'' })),\n    ...spreads.map(SP => ({ key:`${SP.under} ${SP.expiry} ${SP.structure}`, under:SP.under, expiry:SP.expiry, dte:dteOf(SP.expiry), structure:SP.structure, type:SP.type, width:SP.width, qty:SP.qty, warning:(dteOf(SP.expiry)!=null && dteOf(SP.expiry) < CFG.dte_alert_days)?'(warning)':'' }))\n  ].sort((a,b)=> (a.dte - b.dte) || asc(String(a.under), String(b.under)));\n\n  // Exposures (for PM view)\n  const exposures = [];\n  for (const sp of spreads){\n    const totalMaxLoss   = r(sp.max_loss_per_combo  * sp.qty, 2);\n    const totalMaxProfit = r(sp.max_profit_per_combo* sp.qty, 2);\n    const pnl_total      = r(sp._pnl.total, 2);\n    const basis_total    = sp.basis_total ?? null;\n    const pnl_pct_basis  = (basis_total && basis_total!==0) ? r((pnl_total/Math.abs(basis_total))*100,2) : null;\n    exposures.push({\n      kind:'spread', under:sp.under, structure:sp.structure, expiry:sp.expiry,\n      dte:dteOf(sp.expiry), qty:sp.qty, width:sp.width, net_per_combo:sp.net_mid_per_combo,\n      max_profit_per_combo:sp.max_profit_per_combo, max_loss_per_combo:sp.max_loss_per_combo,\n      max_loss_total: totalMaxLoss, max_profit_total: totalMaxProfit,\n      pnl_total, pnl_pct_basis, ranking_key: totalMaxLoss\n    });\n  }\n  for (const L of singles){\n    const premAtRisk   = (L.side==='long') ? Math.abs(nz(L.cost_basis)) : null;\n    const unbounded    = (L.side==='short');\n    const approxRank   = unbounded ? Math.abs(nz(L.mkt_value)) : premAtRisk;\n    const pnl_total    = Number.isFinite(L.unrealized_pl) ? r(L.unrealized_pl,2) : null;\n    const pnl_pct_basis= (premAtRisk && premAtRisk!==0 && pnl_total!=null) ? r((pnl_total/Math.abs(premAtRisk))*100,2) : null;\n    exposures.push({\n      kind:'single', under:L.under, type:L.type, strike:L.strike, side:L.side,\n      expiry:L.expiry, dte:dteOf(L.expiry), qty:L.qty,\n      premium_at_risk_total: premAtRisk, pnl_total, pnl_pct_basis,\n      unbounded_risk: unbounded, ranking_key: approxRank\n    });\n  }\n  const heaviest = exposures.filter(x => x.ranking_key != null)\n    .sort((a,b)=> Number(b.ranking_key) - Number(a.ranking_key))\n    .map(h => ({ ...h, exposure_label: (h.kind==='spread')\n      ? `MaxLoss\u2248${fmtUSD(h.max_loss_total)} (${h.structure} ${h.width}w x${h.qty})`\n      : (h.unbounded_risk ? `Unbounded (short ${h.type})` : `PremiumAtRisk\u2248${fmtUSD(h.premium_at_risk_total)}`) }));\n\n  // -------- Greeks aggregation --------\n  // (A) Vendor Greeks (preferred when present): net portfolio exposures\n  const vendorLegs = [\n    ...singles.map(L => ({...L})),\n    ...spreads.flatMap(S => ([\n      { under:S.under, type:S.type, strike:S.long.strike,  side:'long',  expiry:S.expiry, qty:S.qty, _vendor_greeks:S.long?._vendor_greeks ?? null, opra:S.long?.opra },\n      { under:S.under, type:S.type, strike:S.short.strike, side:'short', expiry:S.expiry, qty:S.qty, _vendor_greeks:S.short?._vendor_greeks ?? null, opra:S.short?.opra }\n    ]))\n  ];\n  const vendor_by_under = {};\n  const vendor_total = { delta:0, gamma:0, theta:0, vega:0, legs_count:0 };\n  for (const leg of vendorLegs){\n    const g = leg._vendor_greeks; if (!g) continue;\n    const sign = (leg.side==='long' ? +1 : -1);\n    const W = (leg.qty ?? 0) * sign * CFG.CM;\n    const d = Number.isFinite(+g.delta)? +g.delta : null;\n    const ga= Number.isFinite(+g.gamma)? +g.gamma : null;\n    const th= Number.isFinite(+g.theta)? +g.theta : null;\n    const v = Number.isFinite(+g.vega )? +g.vega  : null;\n    if (d==null && ga==null && th==null && v==null) continue;\n\n    const u = vendor_by_under[leg.under] || (vendor_by_under[leg.under] = { delta:0,gamma:0,theta:0,vega:0, legs:0 });\n    if (d!=null){ u.delta += d*W; vendor_total.delta += d*W; }\n    if (ga!=null){ u.gamma += ga*W; vendor_total.gamma += ga*W; }\n    if (th!=null){ u.theta += th*W; vendor_total.theta += th*W; }\n    if (v!=null){ u.vega  += v*W; vendor_total.vega  += v*W; }\n    u.legs++; vendor_total.legs_count++;\n  }\n\n  // (B) Black\u2013Scholes fallback (requires spot S from TA, T, IV)\n  function bucketTenor(d){ if (d==null || !Number.isFinite(d)) return 'unknown'; if (d<=7) return '0_7d'; if (d<=30) return '8_30d'; if (d<=90) return '31_90d'; return '90d_plus'; }\n  const bs_by_under = {}; const bs_by_tenor = {}; const bs_total = { delta:0,gamma:0,theta:0,vega:0, legs:0 };\n  function addAgg(container, key, vec){ const o=container[key]||(container[key]={ delta:0,gamma:0,theta:0,vega:0, legs:0 }); o.delta+=vec.delta; o.gamma+=vec.gamma; o.theta+=vec.theta; o.vega+=vec.vega; o.legs++; }\n  const bsLegs = [\n    ...singles.map(L => ({...L, side:L.side})),\n    ...spreads.flatMap(S => ([\n      { under:S.under, type:S.type, strike:S.long.strike,  side:'long',  expiry:S.expiry, qty:S.qty, iv:(S.long.iv ?? null) },\n      { under:S.under, type:S.type, strike:S.short.strike, side:'short', expiry:S.expiry, qty:S.qty, iv:(S.short.iv ?? null) }\n    ]))\n  ];\n  for (const leg of bsLegs){\n    const Sspot = priceOf(leg.under);\n    const K = leg.strike;\n    const T_days = dteOf(leg.expiry);\n    const T = (T_days!=null && T_days>=0) ? (T_days/365) : null;\n    const iv = (leg.iv!=null) ? Number(leg.iv) : null;\n    const rRate = (CFG.RFR!=null) ? CFG.RFR : 0;\n    const q = (CFG.DIV!=null) ? CFG.DIV : 0;\n    if (!(Number.isFinite(Sspot) && Number.isFinite(K) && Number.isFinite(T) && T>=0 && Number.isFinite(iv) && iv>0)) continue;\n\n    const sign = (leg.side==='long' ? +1 : -1);\n    const W = (leg.qty ?? 0) * sign * CFG.CM;\n    const g0 = bsGreeks({ S:Sspot, K, T, r:rRate, q, iv, type:leg.type }); if (!g0) continue;\n    const vec = { delta: g0.delta*W, gamma: g0.gamma*W, theta: (g0.theta/365)*W, vega:(g0.vega/100)*W };\n    addAgg(bs_by_under, leg.under, vec);\n    addAgg(bs_by_tenor, bucketTenor(T_days), vec);\n    bs_total.delta+=vec.delta; bs_total.gamma+=vec.gamma; bs_total.theta+=vec.theta; bs_total.vega+=vec.vega; bs_total.legs++;\n  }\n\n  // P&L leaders\n  const pnlRecords = [];\n  for (const sp of spreads){\n    pnlRecords.push({\n      kind:'spread', under:sp.under, expiry:sp.expiry, structure:sp.structure,\n      qty: sp.qty, pnl_per_unit: r(sp._pnl.per_unit,2), pnl_total: r(sp._pnl.total,2),\n      pnl_pct_basis: (sp.basis_total && sp.basis_total!==0) ? r((sp._pnl.total/Math.abs(sp.basis_total))*100,2) : null\n    });\n  }\n  for (const L of singles){\n    const perUnit = (Number.isFinite(L.unrealized_pl) && L.qty ? L.unrealized_pl / L.qty : 0);\n    const premAtRisk = (L.side==='long') ? Math.abs(nz(L.cost_basis)) : null;\n    pnlRecords.push({\n      kind:'single', under:L.under, expiry:L.expiry, structure:`${L.side} ${L.type}`, qty:L.qty,\n      pnl_per_unit:r(perUnit,2), pnl_total:r(perUnit*L.qty,2),\n      pnl_pct_basis: (premAtRisk && premAtRisk!==0) ? r(((perUnit*L.qty)/Math.abs(premAtRisk))*100,2) : null\n    });\n  }\n  const total_unrealized = r(pnlRecords.reduce((a,b)=> a + nz(b.pnl_total), 0), 2);\n  const winners_top = pnlRecords.filter(x => x.pnl_total > 0).sort((a,b)=> b.pnl_total - a.pnl_total).slice(0,5);\n  const losers_top  = pnlRecords.filter(x => x.pnl_total < 0).sort((a,b)=> a.pnl_total - b.pnl_total).slice(0,5);\n\n  // Chains summary\n  const chainUniverse = [];\n  let contracts_total=0, snapshots_total=0, greeks_seen=0;\n  const underCandidates = (() => {\n    if (CFG.chain_scope==='universe') return [...BYUNDER.keys()];\n    if (heldSet.size===0 && CFG.include_universe_if_no_positions) return [...BYUNDER.keys()];\n    return [...heldSet];\n  })();\n  for (const under of underCandidates.sort()){\n    const setOPRA = BYUNDER.get(under) || new Set();\n    const spot = TA.get(under)?.currentPrice ?? null;\n    const expiries = new Map();\n    let liqSpreads = [];\n    for (const opra of setOPRA){\n      const c = CONTRACT.get(opra); if (!c) continue;\n      const s = SNAP.get(opra) || null;\n      contracts_total++;\n      if (s) {\n        snapshots_total++;\n        if (s.greeks && (s.greeks.delta!=null)) greeks_seen++;\n        if (s.liq && Number.isFinite(s.liq.spread_pct)) liqSpreads.push(+s.liq.spread_pct);\n      }\n      const rec = { opra, strike:c.strike, type:c.type, expiry:c.expiry, iv:s?.iv ?? null, mid:s?.curr ?? null, liq:s?.liq ?? null };\n      if (!expiries.has(c.expiry)) expiries.set(c.expiry, { calls:[], puts:[] });\n      const bucket = (c.type==='call') ? expiries.get(c.expiry).calls : expiries.get(c.expiry).puts;\n      bucket.push(rec);\n    }\n    const expRows = [];\n    for (const [exp, sideBuckets] of expiries.entries()){\n      let atm_call=null, atm_put=null;\n      if (spot!=null){\n        const pickATM = (arr)=> arr.length ? arr.reduce((best,x)=> (best==null || Math.abs(x.strike-spot)<Math.abs(best.strike-spot) ? x : best), null) : null;\n        atm_call = pickATM(sideBuckets.calls);\n        atm_put  = pickATM(sideBuckets.puts);\n      }\n      expRows.push({ expiry: exp, dte: daysDiffUTC(exp, asofISO), calls: sideBuckets.calls.length, puts: sideBuckets.puts.length, atm_call, atm_put });\n    }\n    expRows.sort((a,b)=> (a.dte - b.dte));\n    const liq_median_spread_pct = median(liqSpreads);\n    chainUniverse.push({ symbol: under, spot: spot ?? null, expiries: expRows, liq_stats: { median_spread_pct: r(liq_median_spread_pct,3), samples: liqSpreads.length } });\n  }\n\n  // TA rows (held for PM)\n  const ta_rows = [];\n  for (const [sym, rec] of TA.entries()){\n    if (CFG.ta_scope==='held' && !heldSet.has(sym)) continue;\n    ta_rows.push({ symbol: sym, current_price: rec.currentPrice ?? null, dominant: rec.dominant, frames: rec.frames });\n  }\n\n  // Alerts\n  const ultraShort = dteQueue.filter(x => (x.dte!=null && x.dte < CFG.dte_alert_days));\n  const unboundedShorts = exposures.filter(h => h.kind==='single' && h.unbounded_risk);\n\n  // Programmatic per-under summary\n  const byUnder = {};\n  for (const e of exposures){\n    const u = byUnder[e.under] || (byUnder[e.under] = { under:e.under, spreads:[], singles:[], max_loss_total:0, premium_at_risk_total:0, pnl_total:0 });\n    if (e.kind==='spread'){\n      u.spreads.push(e); u.max_loss_total += nz(e.max_loss_total); u.pnl_total += nz(e.pnl_total);\n    } else {\n      u.singles.push(e); u.premium_at_risk_total += nz(e.premium_at_risk_total); u.pnl_total += nz(e.pnl_total);\n    }\n  }\n\n  // Attach TA in-position rows\n  function attachTAtoSpread(sp){\n    const t = TA.get(sp.under);\n    const pick = (fr) => fr?.day ?? fr?.hour ?? fr?.week ?? {};\n    const fr = t ? pick(t.frames) : {};\n    return {\n      symbol: sp.under, structure: sp.structure, expiry: sp.expiry, dte: dteOf(sp.expiry),\n      type: sp.type, width: sp.width, qty: sp.qty,\n      long:  sp.long, short: sp.short,\n      net_mid_per_combo: sp.net_mid_per_combo,\n      max_profit_per_combo: sp.max_profit_per_combo, max_loss_per_combo: sp.max_loss_per_combo,\n      basis_per_combo: sp.basis_per_combo, basis_total: sp.basis_total,\n      ta: t ? {\n        symbol: t.symbol, current_price: t.currentPrice ?? null, dominant: t.dominant || null,\n        support: fr.support ?? null, resistance: fr.resistance ?? null,\n        expected_move_week: fr.expected_move_week ?? null, expected_move_month: fr.expected_move_month ?? null\n      } : null\n    };\n  }\n  function attachTAtoSingle(L){\n    const t = TA.get(L.under);\n    const pick = (fr) => fr?.day ?? fr?.hour ?? fr?.week ?? {};\n    const fr = t ? pick(t.frames) : {};\n    return {\n      opra: L.opra, symbol: L.under, type: L.type, strike: L.strike, side: L.side,\n      qty: L.qty, expiry: L.expiry, dte: dteOf(L.expiry),\n      avg_entry: L.avg_entry, curr: L.curr,\n      cost_basis: L.cost_basis, mkt_value: L.mkt_value, unrealized_pl: L.unrealized_pl,\n      pnl_pct_basis: (L.side==='long' && L.cost_basis) ? r((nz(L.unrealized_pl)/Math.abs(L.cost_basis))*100,2) : null,\n      liq: L.liq || null, iv: L.iv ?? null,\n      ta: t ? {\n        symbol: t.symbol, current_price: t.currentPrice ?? null, dominant: t.dominant || null,\n        support: fr.support ?? null, resistance: fr.resistance ?? null,\n        expected_move_week: fr.expected_move_week ?? null, expected_move_month: fr.expected_move_month ?? null\n      } : null\n    };\n  }\n\n  // Totals & diagnostics\n  const totals = {\n    spreads_max_loss_total: r(sum(exposures.filter(e=>e.kind==='spread').map(e=> nz(e.max_loss_total))),2),\n    singles_premium_at_risk_total: r(sum(exposures.filter(e=>e.kind==='single' && !e.unbounded_risk).map(e=> nz(e.premium_at_risk_total))),2),\n    singles_unbounded_shorts: exposures.filter(e=>e.kind==='single' && e.unbounded_risk).length\n  };\n\n  const diagnostics = {\n    items_in: {\n      accounts: accounts?.length || 0,\n      positions: rawPositions?.length || 0,\n      ta_frames: ta_frames?.length || 0,\n      contracts_items: contractsRaw?.length || 0,\n      snapshots_items: snapshotsRaw?.length || 0\n    },\n    positions_unmatched: positionsUnmatched.length,\n    bad_contract_records: seenBadContracts.length,\n    notes: [\n      'TA scope = ' + CFG.ta_scope + ', Chains scope = ' + CFG.chain_scope + (heldSet.size===0 && CFG.chain_scope==='held' ? ' (no positions held)' : ''),\n      CFG.include_universe_if_no_positions ? 'Includes universe chains when no positions.' : 'Universe not included when no positions.',\n      'Vendor greeks aggregated (qty\u00d7side\u00d7CM). BS greeks shown when S, T, IV exist from TA.'\n    ]\n  };\n\n  // Snapshot\n  const snapshot = {\n    asof: asofISO,\n    account,\n    counts: {\n      positions_total: rawPositions?.length || 0,\n      options_legs: legsAll.length,\n      spreads: spreads.length,\n      singles: singles.length,\n      ta_symbols: (CFG.ta_scope==='held' ? [...heldSet].filter(s=>TA.has(s)).length : TA.size),\n      contracts_total,\n      snapshots_total,\n      snapshots_with_greeks: Object.values(SNAP).filter(s => s.greeks && s.greeks.delta!=null).length\n    },\n    totals,\n    positions: {\n      spreads: spreads.map(attachTAtoSpread),\n      singles: singles.map(attachTAtoSingle)\n    },\n    chains: {\n      scope: (heldSet.size===0 && CFG.chain_scope==='held' && !CFG.include_universe_if_no_positions) ? 'held (empty \u2014 no positions)' : CFG.chain_scope,\n      underlyings: chainUniverse\n    },\n    by_under: Object.values(byUnder).sort((a,b)=>asc(a.under,b.under)),\n    dte_queue: dteQueue,\n    heaviest_exposures: heaviest,\n    ta_alignment: { rows: ta_rows, watchlist: [] },\n    alerts: { ultra_short_dte: ultraShort, unbounded_shorts: unboundedShorts },\n\n    // Greeks reporting (both vendor & BS)\n    greeks_net: {\n      vendor: { total: { delta:r(vendor_total.delta,4), gamma:r(vendor_total.gamma,6), theta:r(vendor_total.theta,6), vega:r(vendor_total.vega,6), legs:vendor_total.legs_count },\n                by_under: Object.fromEntries(Object.entries(vendor_by_under).map(([u,v])=>[u,{ delta:r(v.delta,4), gamma:r(v.gamma,6), theta:r(v.theta,6), vega:r(v.vega,6), legs:v.legs }])) },\n      bs:     { total: { delta:r(bs_total.delta,4), gamma:r(bs_total.gamma,6), theta:r(bs_total.theta,6), vega:r(bs_total.vega,6), legs:bs_total.legs },\n                by_under: Object.fromEntries(Object.entries(bs_by_under).map(([u,v])=>[u,{ delta:r(v.delta,4), gamma:r(v.gamma,6), theta:r(v.theta,6), vega:r(v.vega,6), legs:v.legs }])),\n                by_tenor: Object.fromEntries(Object.entries(bs_by_tenor).map(([t,v])=>[t,{ delta:r(v.delta,4), gamma:r(v.gamma,6), theta:r(v.theta,6), vega:r(v.vega,6), legs:v.legs }])) }\n    },\n\n    risk: { risk_score_0_to_10: null, appetite_target: null, alignment: null },\n    pnl_leaders: { total_unrealized: total_unrealized, winners_top, losers_top },\n    orders: orders_in || { open: [] },\n    current_price_map: Object.fromEntries([...TA.entries()].map(([k,v])=> [k, v.currentPrice ?? null])),\n    diagnostics\n  };\n\n  // ---------- Render (markdown) ----------\n  function mdHeader(){\n    return [\n      `# Portfolio Snapshot \u2014 ${snapshot.asof}`,\n      ``,\n      `**Acct** ${snapshot.account.account_number} \u2022 **Equity** ${fmtUSD(snapshot.account.equity)} \u2022 **Cash** ${fmtUSD(snapshot.account.cash)} \u2022 **BP** ${fmtUSD(snapshot.account.buying_power)}`,\n      `**Positions** L:${fmtUSD(snapshot.account.long_market_value)} S:${fmtUSD(snapshot.account.short_market_value)} \u2022 **PDT**: ${snapshot.account.pattern_day_trader?'Yes':'No'}`,\n      ``,\n      `**Counts** Legs:${snapshot.counts.options_legs} \u2022 Spreads:${snapshot.counts.spreads} \u2022 Singles:${snapshot.counts.singles} \u2022 Chains:${snapshot.counts.contracts_total} contracts (${snapshot.counts.snapshots_total} snaps)`,\n      `**Totals** Spreads MaxLoss:${fmtUSD(snapshot.totals.spreads_max_loss_total)} \u2022 Long Prem @Risk:${fmtUSD(snapshot.totals.singles_premium_at_risk_total)} \u2022 Short unbounded:${snapshot.totals.singles_unbounded_shorts}`,\n      `**Net Greeks (vendor)** \u0394:${r(snapshot.greeks_net.vendor.total.delta,4)} \u0393:${r(snapshot.greeks_net.vendor.total.gamma,6)} \u0398:${r(snapshot.greeks_net.vendor.total.theta,6)} \u028b:${r(snapshot.greeks_net.vendor.total.vega,6)}`\n    ].join('\\n');\n  }\n  function mdDTE(){\n    const rows = snapshot.dte_queue;\n    const L = [];\n    L.push(`## DTE Queue (shortest \u2192 longest)`);\n    L.push(`| Under | Expiry | DTE | Structure/Type | Strike/Width | Qty |`);\n    L.push(`|:--|:--:|--:|:--|--:|--:|`);\n    for (const r0 of rows){\n      const isSpread = !!r0.structure;\n      const extra = r0.warning ? ' **(warning)**' : '';\n      L.push(`| ${r0.under} | ${r0.expiry||'\u2014'} | ${r0.dte??'\u2014'}${extra} | ${isSpread ? r0.structure : r0.type||'\u2014'} | ${isSpread ? r0.width??'\u2014' : r0.strike??'\u2014'} | ${r0.qty} |`);\n    }\n    L.push('');\n    return L.join('\\n');\n  }\n  function mdTA(){\n    const rows = snapshot.ta_alignment.rows || [];\n    const L = [];\n    L.push(`## TA (held only)`);\n    L.push(`| Symbol | Price | Dominant | Score | S/R | 1-wk EM | 1-mo EM |`);\n    L.push(`|:--|--:|:--|--:|:--|--:|--:|`);\n    if (rows.length===0){\n      L.push(`| \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 |`);\n    } else {\n      const pick = (frames) => frames?.day ?? frames?.hour ?? frames?.week ?? {};\n      for (const t of rows.sort((a,b)=> asc(a.symbol,b.symbol))){\n        const fr = pick(t.frames);\n        const sr = (fr.support!=null || fr.resistance!=null) ? `${r(fr.support,2)}/${r(fr.resistance,2)}` : '\u2014';\n        const em1w = fr.expected_move_week!=null ? r(fr.expected_move_week,2) : '\u2014';\n        const em1m = fr.expected_move_month!=null ? r(fr.expected_move_month,2) : '\u2014';\n        L.push(`| ${t.symbol} | ${t.current_price!=null?r(t.current_price,2):'\u2014'} | ${t.dominant?.direction ?? '\u2014'} | ${t.dominant?.score ?? '\u2014'} | ${sr} | ${em1w} | ${em1m} |`);\n      }\n    }\n    L.push('');\n    return L.join('\\n');\n  }\n  function mdChains(){\n    const L = [];\n    L.push(`## Chains (${snapshot.chains.scope})`);\n    L.push(`| Symbol | Spot | Expiries | Median liq spread % |`);\n    L.push(`|:--|--:|--:|--:|`);\n    for (const row of snapshot.chains.underlyings){\n      const expN = row.expiries.length;\n      const med  = row.liq_stats?.median_spread_pct!=null ? r(row.liq_stats.median_spread_pct,3) : '\u2014';\n      L.push(`| ${row.symbol} | ${row.spot!=null?r(row.spot,2):'\u2013'} | ${expN} | ${med} |`);\n    }\n    L.push('');\n    return L.join('\\n');\n  }\n  function mdPnL(){\n    const W = snapshot.pnl_leaders.winners_top;\n    const Ls = snapshot.pnl_leaders.losers_top;\n    const out = [];\n    out.push(`## P&L Leaders`);\n    out.push(`**Total unrealized:** ${fmtUSD(snapshot.pnl_leaders.total_unrealized)}`);\n    out.push('');\n    out.push(`**Winners (top 5)**`);\n    out.push(`| Kind | Under | Expiry | Structure/Type | Qty | P&L / unit | P&L total | P&L % of Basis |`);\n    out.push(`|:--|:--|:--:|:--|--:|--:|--:|--:|`);\n    if (W.length===0) out.push(`| \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 |`);\n    for (const w of W){\n      const pct = (w.pnl_pct_basis!=null) ? `${w.pnl_pct_basis}%` : '\u2014';\n      out.push(`| ${w.kind} | ${w.under} | ${w.expiry} | ${w.structure} | ${w.qty} | ${fmtUSD(w.pnl_per_unit)} | ${fmtUSD(w.pnl_total)} | ${pct} |`);\n    }\n    out.push('');\n    out.push(`**Losers (top 5)**`);\n    out.push(`| Kind | Under | Expiry | Structure/Type | Qty | P&L / unit | P&L total | P&L % of Basis |`);\n    out.push(`|:--|:--|:--:|:--|--:|--:|--:|--:|`);\n    if (Ls.length===0) out.push(`| \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 | \u2014 |`);\n    for (const l of Ls){\n      const pct = (l.pnl_pct_basis!=null) ? `${l.pnl_pct_basis}%` : '\u2014';\n      out.push(`| ${l.kind} | ${l.under} | ${l.expiry} | ${l.structure} | ${l.qty} | ${fmtUSD(l.pnl_per_unit)} | ${fmtUSD(l.pnl_total)} | ${pct} |`);\n    }\n    out.push('');\n    return out.join('\\n');\n  }\n  function mdAlerts(){\n    return [\n      `## Alerts`,\n      `- Ultra-short DTE (<${CFG.dte_alert_days}): ${snapshot.alerts.ultra_short_dte.length}`,\n      `- Unbounded single shorts: ${snapshot.alerts.unbounded_shorts.length}`,\n      ``\n    ].join('\\n');\n  }\n\n  const md = [\n    mdHeader(),\n    mdDTE(),\n    mdTA(),\n    mdChains(),\n    mdPnL(),\n    mdAlerts(),\n    `> Notes:`,\n    `> \u2022 Vendor greeks are multiplied by qty\u00d7side\u00d7contract_multiplier to produce **net exposures**; BS greeks are shown when TA provides spot.`,\n    `> \u2022 Chains scope = ${snapshot.chains.scope}. Median spread% summarizes available snapshot quotes per symbol.`,\n    ``\n  ].join('\\n');\n\n  const text = md.replace(/\\|/g,'\u2502');\n\n  return {\n    snapshot,\n    render: { md, text },\n    meta: {\n      generated_at: new Date().toISOString(),\n      ...snapshot.diagnostics\n    }\n  };\n}\n\n//////////////////////////// Run ///////////////////////////////\n\nconst out = build();\nreturn [{ json: out }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2080,
        -1936
      ],
      "id": "c83adbbb-0f97-4f95-8899-d2cff3701008",
      "name": "TA+Port Summary"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Technical Analysis Calculator \u2014 Signal-Only (Bullish / Neutral / Bearish)\n * Multi-frame (Hour / Day / Week) per symbol.\n *\n * INPUT:\n *   - One or more Yahoo Finance `chart` JSONs (typical n8n HTTP node output).\n *   - Timeframe can be inferred from:\n *       json.frame | json.label | chart.result[0].meta.interval | meta.range\n *     (Accepts hints like: '1h', '60m', 'hour', '1d', 'day', '1wk', 'week')\n *\n * OUTPUT (configurable):\n *   - GROUPED (default): 1 item per symbol with frames.hour/day/week sections\n *   - FLAT: 1 item per (symbol, frame)\n */\n\n///////////////////////// CONFIG /////////////////////////\nconst OUTPUT_MODE = 'GROUPED'; // 'GROUPED' | 'FLAT'\n\nconst THRESH = {\n  RSI: { OVERSOLD: 35, WEAK_OVERSOLD: 45, OVERBOUGHT: 65, EXT_OVERSOLD: 30, EXT_OVERBOUGHT: 70 },\n  MOM_5D: 3,                     // % move (interpreted in each frame's bar units)\n  BBAND_SQUEEZE_PCT: 5,          // %\n  VOLUME_SURGE_RATIO: 1.8,       // recent / average\n  MACD_HIST_DEADBAND: 0.05,\n  BULL_SCORE: 3,\n  BEAR_SCORE: -3,\n};\n\n///////////////////////// HELPERS /////////////////////////\nconst clamp = (x, a= -Infinity, b= Infinity) => Math.min(b, Math.max(a, x));\n\nconst sma = (arr, period) => {\n  if (!arr || arr.length < period) return [];\n  const out = [];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (i >= period) sum -= arr[i - period];\n    if (i >= period - 1) out.push(sum / period);\n  }\n  return out;\n};\n\nconst ema = (arr, period) => {\n  if (!arr || !arr.length) return [];\n  const k = 2 / (period + 1);\n  const out = [arr[0]];\n  for (let i = 1; i < arr.length; i++) out.push(arr[i] * k + out[i - 1] * (1 - k));\n  return out;\n};\n\nconst calcHistoricalVolatility = (closes, period = 20) => {\n  if (!closes || closes.length < period + 1) return 25; // % fallback\n  const rets = [];\n  for (let i = 1; i < closes.length; i++) rets.push(Math.log(closes[i] / closes[i - 1]));\n  const recent = rets.slice(-period);\n  const mean = recent.reduce((a, b) => a + b, 0) / period;\n  const varp = recent.reduce((s, r) => s + Math.pow(r - mean, 2), 0) / period;\n  return Math.sqrt(varp * 252) * 100; // %\n};\n\nconst calcRSI = (closes, period = 14) => {\n  if (!closes || closes.length < period + 1) return 50;\n  const changes = [];\n  for (let i = 1; i < closes.length; i++) changes.push(closes[i] - closes[i - 1]);\n  let gain = 0, loss = 0;\n  for (let i = 0; i < period; i++) { if (changes[i] > 0) gain += changes[i]; else loss -= changes[i]; }\n  let avgGain = gain / period, avgLoss = loss / period;\n  for (let i = period; i < changes.length; i++) {\n    const ch = changes[i];\n    avgGain = (avgGain * (period - 1) + (ch > 0 ? ch : 0)) / period;\n    avgLoss = (avgLoss * (period - 1) + (ch < 0 ? -ch : 0)) / period;\n  }\n  if (avgLoss === 0) return 100;\n  const rs = avgGain / avgLoss;\n  return 100 - 100 / (1 + rs);\n};\n\nconst calcMACD = (closes) => {\n  const n = closes?.length ?? 0;\n  if (n < 34) return { macdLine: null, signal: null, histogram: null, ready: false, bars: n };\n  const ema12 = ema(closes, 12);\n  const ema26 = ema(closes, 26);\n  const macdSeries = closes.map((_, i) => ema12[i] - ema26[i]);\n  const signalSeries = ema(macdSeries, 9);\n  const macdLine = macdSeries[macdSeries.length - 1];\n  const signal = signalSeries[signalSeries.length - 1];\n  const histogram = macdLine - signal;\n  return { macdLine, signal, histogram, ready: true, bars: n };\n};\n\nconst calcBollinger = (closes, period = 20, stdDev = 2) => {\n  if (!closes || closes.length < period) {\n    const p = closes?.[closes.length - 1] ?? null;\n    if (p == null) return { upper: null, middle: null, lower: null, bandwidth: null };\n    return { upper: p * 1.1, middle: p, lower: p * 0.9, bandwidth: 20 };\n  }\n  const ma = sma(closes, period);\n  const mid = ma[ma.length - 1];\n  const window = closes.slice(-period);\n  const variance = window.reduce((s, x) => s + Math.pow(x - mid, 2), 0) / period;\n  const std = Math.sqrt(variance);\n  const upper = mid + stdDev * std;\n  const lower = mid - stdDev * std;\n  const bandwidth = ((upper - lower) / mid) * 100;\n  return { upper, middle: mid, lower, bandwidth };\n};\n\nconst trueRange = (h, l, prevClose) => Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));\nconst calcATR = (highs, lows, closes, period = 14) => {\n  if (!highs || !lows || !closes || highs.length < period + 1 || lows.length < period + 1 || closes.length < period + 1) return null;\n  const trs = [];\n  for (let i = 1; i < highs.length; i++) trs.push(trueRange(highs[i], lows[i], closes[i - 1]));\n  let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period; // Wilder\n  for (let i = period; i < trs.length; i++) atr = (atr * (period - 1) + trs[i]) / period;\n  return atr;\n};\n\nconst calcMomentum = (closes) => {\n  const out = {};\n  const n = closes?.length ?? 0;\n  const cur = closes[n - 1];\n  if (n > 5)  out.fiveDay  = ((cur - closes[n - 6])  / closes[n - 6])  * 100;\n  if (n > 10) out.tenDay   = ((cur - closes[n - 11]) / closes[n - 11]) * 100;\n  if (n > 20) out.twentyDay= ((cur - closes[n - 21]) / closes[n - 21]) * 100;\n  return out;\n};\n\nconst calcVolume = (volumes, closes) => {\n  const n = volumes?.length ?? 0;\n  if (!n) return { avgVolume: 0, recentVolume: 0, volumeRatio: 0, pvt: 0, volumeSurge: false };\n  const avg = volumes.reduce((a, b) => a + b, 0) / n;\n  const recent = volumes[n - 1];\n  const ratio = avg ? recent / avg : 0;\n  let pvt = 0;\n  for (let i = 1; i < Math.min(closes.length, volumes.length); i++) {\n    const pct = (closes[i] - closes[i - 1]) / closes[i - 1];\n    pvt += pct * volumes[i];\n  }\n  return { avgVolume: avg, recentVolume: recent, volumeRatio: ratio, pvt, volumeSurge: ratio >= THRESH.VOLUME_SURGE_RATIO };\n};\n\n///////////////////////// CORE TA /////////////////////////\nfunction calculateTAFromYF(yahoo) {\n  const q = yahoo.chart.result[0];\n  const px = q.indicators.quote[0];\n\n  const closes = px.close.filter(v => v != null);\n  const highs  = px.high.filter(v => v != null);\n  const lows   = px.low.filter(v => v != null);\n  const volumes= px.volume?.filter(v => v != null) ?? [];\n\n  const currentPrice = closes[closes.length - 1];\n  const prevPrice = closes.length > 1 ? closes[closes.length - 2] : currentPrice;\n\n  const sma20Arr = sma(closes, 20);\n  const sma50Arr = sma(closes, 50);\n  const ema9Arr  = ema(closes, 9);\n  const ema20Arr = ema(closes, 20);\n\n  const hv = calcHistoricalVolatility(closes);\n  const rsiVal = calcRSI(closes);\n  const macdVals = calcMACD(closes);\n  const macdHistEff = (macdVals.histogram != null && Math.abs(macdVals.histogram) < THRESH.MACD_HIST_DEADBAND) ? 0 : macdVals.histogram;\n\n  const bb = calcBollinger(closes);\n  const mom = calcMomentum(closes);\n  const vol = calcVolume(volumes, closes);\n  const atr = calcATR(highs, lows, closes);\n\n  const dayChange = prevPrice ? ((currentPrice - prevPrice) / prevPrice) * 100 : 0;\n\n  const expectedMove1W = currentPrice * (hv / 100) * Math.sqrt(5 / 252);\n  const expectedMove1M = currentPrice * (hv / 100) * Math.sqrt(20 / 252);\n\n  const support = lows.length >= 20 ? Math.min(...lows.slice(-20)) : Math.min(...lows);\n  const resistance = highs.length >= 20 ? Math.max(...highs.slice(-20)) : Math.max(...highs);\n\n  const indicators = {\n    symbol: q.meta.symbol,\n    currentPrice,\n    rsi: rsiVal,\n    macd: { ...macdVals, histogramEff: macdHistEff },\n    sma20: sma20Arr.at(-1) ?? null,\n    sma50: sma50Arr.at(-1) ?? null,\n    ema9:  ema9Arr.at(-1)  ?? null,\n    ema20: ema20Arr.at(-1) ?? null,\n    historicalVolatility: hv,\n    bollingerBands: bb,\n    atr,\n    momentum: mom,\n    dayChange,\n    volume: vol,\n    support,\n    resistance,\n    expectedMoves: {\n      oneWeek: expectedMove1W,\n      oneMonth: expectedMove1M,\n      dailyMove: currentPrice * (hv / 100) * Math.sqrt(1 / 252)\n    }\n  };\n\n  // Scoring \u2192 Direction\n  let score = 0;\n  const reasons = [];\n\n  // RSI\n  if (rsiVal < THRESH.RSI.OVERSOLD) { score += 3; reasons.push('RSI_OVERSOLD'); }\n  else if (rsiVal < THRESH.RSI.WEAK_OVERSOLD) { score += 1.5; reasons.push('RSI_WEAK_OVERSOLD'); }\n  if (rsiVal > THRESH.RSI.OVERBOUGHT) { score -= 3; reasons.push('RSI_OVERBOUGHT'); }\n  else if (rsiVal > 55) { score -= 1.5; reasons.push('RSI_WEAK_OVERBOUGHT'); }\n\n  // MACD (deadbanded)\n  if (macdVals.ready && macdHistEff != null) {\n    if (macdHistEff > 0) { score += 2.5; reasons.push('MACD_UP'); if (macdVals.signal != null && Math.abs(macdHistEff) > Math.abs(macdVals.signal) * 0.10) { score += 1; reasons.push('MACD_STRONG'); } }\n    else if (macdHistEff < 0) { score -= 2.5; reasons.push('MACD_DOWN'); if (macdVals.signal != null && Math.abs(macdHistEff) > Math.abs(macdVals.signal) * 0.10) { score -= 1; reasons.push('MACD_STRONG'); } }\n  }\n\n  // Short-term momentum proxy\n  if (typeof mom.fiveDay === 'number') {\n    if (mom.fiveDay > THRESH.MOM_5D) { score += 2; reasons.push('MOM_5D_UP'); }\n    else if (mom.fiveDay < -THRESH.MOM_5D) { score -= 2; reasons.push('MOM_5D_DOWN'); }\n  }\n\n  // Squeeze\n  if (bb.bandwidth != null && bb.bandwidth < THRESH.BBAND_SQUEEZE_PCT) { score += 1; reasons.push('BOLL_SQUEEZE'); }\n\n  // Volume surge nudges\n  if (vol.volumeSurge) {\n    if (dayChange > 0) { score += 1; reasons.push('VOL_SURGE_UP'); }\n    else if (dayChange < 0) { score -= 1; reasons.push('VOL_SURGE_DOWN'); }\n  }\n\n  // Trend gate\n  const upTrend = (indicators.ema9 != null && indicators.ema20 != null) ? (indicators.ema9 >= indicators.ema20) : null;\n  if (upTrend === true) reasons.push('TREND_UP');\n  else if (upTrend === false) reasons.push('TREND_DOWN');\n\n  let direction = 'Neutral';\n  if (score >= THRESH.BULL_SCORE && (upTrend === true || rsiVal < THRESH.RSI.EXT_OVERSOLD)) direction = 'Bullish';\n  else if (score <= THRESH.BEAR_SCORE && (upTrend === false || rsiVal > THRESH.RSI.EXT_OVERBOUGHT)) direction = 'Bearish';\n\n  indicators.signals = { direction, reasons, score: Number(score.toFixed(2)), timestamp: new Date().toISOString() };\n  return indicators;\n}\n\n///////////////////////// FRAME INFERENCE /////////////////////////\nfunction inferFrameLabel(json) {\n  const meta = json?.chart?.result?.[0]?.meta || {};\n  const hint = String(json?.frame || json?.label || meta.interval || meta.dataGranularity || meta.range || '').toLowerCase();\n\n  // Normalize\n  if (/(^|\\b)(1h|60m|60|hour|1hr)(\\b|$)/.test(hint)) return 'hour';\n  if (/(^|\\b)(1d|day|daily)(\\b|$)/.test(hint)) return 'day';\n  if (/(^|\\b)(1w|1wk|week|weekly)(\\b|$)/.test(hint)) return 'week';\n\n  // Heuristic fallback: if interval looks intraday but longer history \u2192 treat as 'hour'\n  if (/(5m|15m|30m|45m)/.test(hint)) return 'hour';\n\n  // Default\n  return 'day';\n}\n\n///////////////////////// PIPELINE /////////////////////////\nconst inputItems = $input.all();\nconst framesBySymbol = new Map(); // symbol -> { hour?, day?, week? }\n\nconst errors = [];\n\nfor (let idx = 0; idx < inputItems.length; idx++) {\n  try {\n    const data = inputItems[idx].json;\n    const r0 = data?.chart?.result?.[0];\n    if (!r0) {\n      const yfErr = data?.chart?.error;\n      throw new Error(yfErr ? `YF_ERROR: ${yfErr.code} - ${yfErr.description}` : 'Invalid Yahoo Finance data structure');\n    }\n\n    const symbol = r0.meta?.symbol || data.symbol || data.ticker || 'UNKNOWN';\n    const frame = inferFrameLabel(data); // 'hour' | 'day' | 'week'\n    const ta = calculateTAFromYF(data);\n\n    if (!framesBySymbol.has(symbol)) framesBySymbol.set(symbol, { symbol, frames: {}, received: [] });\n    const bucket = framesBySymbol.get(symbol);\n    bucket.frames[frame] = ta;\n    bucket.received.push(frame);\n\n  } catch (err) {\n    const symGuess =\n      inputItems[idx]?.json?.chart?.result?.[0]?.meta?.symbol ??\n      inputItems[idx]?.json?.symbol ?? inputItems[idx]?.json?.ticker ?? 'Unknown';\n    errors.push({ index: idx, symbol: symGuess, error: String(err.message || err) });\n  }\n}\n\n// Build outputs\nconst out = [];\nconst majority = (arr) => {\n  const c = { Bullish: 0, Bearish: 0, Neutral: 0 };\n  for (const s of arr) c[s] = (c[s] || 0) + 1;\n  if (c.Bullish >= 2) return 'Bullish';\n  if (c.Bearish >= 2) return 'Bearish';\n  return 'Neutral';\n};\n\nfor (const [symbol, bundle] of framesBySymbol.entries()) {\n  const f = bundle.frames;\n  const sigs = [\n    f.hour?.signals?.direction,\n    f.day?.signals?.direction,\n    f.week?.signals?.direction\n  ].filter(Boolean);\n\n  const composite = sigs.length ? majority(sigs) : 'Neutral';\n\n  if (OUTPUT_MODE === 'GROUPED') {\n    out.push({\n      json: {\n        symbol,\n        frames: {\n          hour: f.hour || null,\n          day:  f.day  || null,\n          week: f.week || null\n        },\n        signals_by_frame: {\n          hour: f.hour?.signals?.direction ?? null,\n          day:  f.day?.signals?.direction  ?? null,\n          week: f.week?.signals?.direction ?? null\n        },\n        composite, // majority vote across available frames\n        received_frames: bundle.received,\n        timestamp: new Date().toISOString()\n      }\n    });\n  } else { // FLAT\n    if (f.hour) out.push({ json: { symbol, frame: 'hour', ...f.hour } });\n    if (f.day)  out.push({ json: { symbol, frame: 'day',  ...f.day } });\n    if (f.week) out.push({ json: { symbol, frame: 'week', ...f.week } });\n  }\n}\n\n// Summary footer\nout.push({\n  json: {\n    summary: {\n      symbols: [...framesBySymbol.keys()],\n      totals: {\n        inputs: inputItems.length,\n        outputs: out.length,\n        symbols: framesBySymbol.size,\n        errors: errors.length\n      },\n      errors,\n      mode: OUTPUT_MODE,\n      timestamp: new Date().toISOString()\n    }\n  }\n});\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        -1680
      ],
      "id": "07f625c0-31c1-4f20-a7e8-6cb9c475e0f6",
      "name": "Universe TA"
    },
    {
      "parameters": {
        "url": "=https://query1.finance.yahoo.com/v8/finance/chart/{{ $json.symbol.toString().trim().toUpperCase() }}\n",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "range",
              "value": "3mo"
            },
            {
              "name": "interval",
              "value": "1d"
            },
            {
              "name": "includePrePost",
              "value": "false"
            },
            {
              "name": "events",
              "value": "div,splits"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; Trading Bot)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1168,
        -1808
      ],
      "id": "c9a44f4f-6a24-4806-80ce-19dd11e06918",
      "name": "Daily TA",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1376,
        -1696
      ],
      "id": "ce7d5312-e4c6-46d3-99ba-535d8ac3312b",
      "name": "Merge5"
    },
    {
      "parameters": {
        "url": "=https://query1.finance.yahoo.com/v8/finance/chart/{{ $json.symbol.toString().trim().toUpperCase() }}\n",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "range",
              "value": "5d"
            },
            {
              "name": "interval",
              "value": "1h"
            },
            {
              "name": "includePrePost",
              "value": "false"
            },
            {
              "name": "events",
              "value": "div,splits"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; Trading Bot)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1168,
        -1648
      ],
      "id": "3d8091ee-134c-46a0-8e2d-611da821611e",
      "name": "Hourly TA",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "=https://query1.finance.yahoo.com/v8/finance/chart/{{ $json.symbol.toString().trim().toUpperCase() }}\n",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "range",
              "value": "6mo"
            },
            {
              "name": "interval",
              "value": "1wk"
            },
            {
              "name": "includePrePost",
              "value": "false"
            },
            {
              "name": "events",
              "value": "div,splits"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (compatible; Trading Bot)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1168,
        -1488
      ],
      "id": "6f1738e3-42ee-41d1-a647-069c5a70b92d",
      "name": "Week TA",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "=https://data.alpaca.markets/v1beta1/options/snapshots/{{ $json.symbol }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1568,
        -2064
      ],
      "id": "c64e48eb-aa15-41e4-aa2e-42160b126eb6",
      "name": "Alpaca Options1",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node \u2014 emit ONE item per ticker\nconst items = $input.all();\n\n// OPRA parser -> returns underlying ticker, or null\nfunction parseOPRA(s) {\n  if (typeof s !== 'string') return null;\n  const up = s.toUpperCase().trim();\n  // OPRA pattern: TICKER YY MM DD C|P ########\n  const m = up.match(/^([A-Z.]{1,6})\\d{2}\\d{2}\\d{2}[CP]\\d{8}$/);\n  return m ? m[1] : null;\n}\n\nconst tickerSet = new Set();\n\nfor (const it of items) {\n  const j = it.json || {};\n  \n  // Try to find a contract symbol on the item\n  const cand = \n    j.opra || \n    j.contract_symbol || \n    j.option_symbol || \n    j.symbol || \n    j.ticker || \n    null;\n    \n  if (cand) {\n    const up = String(cand).toUpperCase().trim();\n    // If it's an OPRA, extract the ticker\n    const ticker = parseOPRA(up);\n    if (ticker) {\n      tickerSet.add(ticker);\n    }\n    // If it's already just a ticker (not OPRA format)\n    else if (/^[A-Z.]{1,6}$/.test(up)) {\n      tickerSet.add(up);\n    }\n  }\n  \n  // Also check for underlying_symbol field\n  if (j.underlying_symbol) {\n    const us = String(j.underlying_symbol).toUpperCase().trim();\n    if (/^[A-Z.]{1,6}$/.test(us)) {\n      tickerSet.add(us);\n    }\n  }\n}\n\n// Output: one item per ticker\nconst out = [];\nfor (const ticker of tickerSet) {\n  out.push({ json: { symbol: ticker } });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        -2224
      ],
      "id": "ccc695aa-ce98-4576-b408-8952313893dd",
      "name": "Parse symbols"
    },
    {
      "parameters": {
        "description": "Use this tool to help you think through your decisions and ensure you are acting as an experienced risk on portfolio manager would. Have you done your due diligence? are you confident in your trade decisons? Use this to make those determinations and think through your actions as an informed manager."
      },
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        3200,
        -1648
      ],
      "id": "0387cd87-256d-4a7d-b6ec-b86231f57b1c",
      "name": "Think"
    },
    {
      "parameters": {
        "description": "Use this tool to think as needed and ensure you are acting as a professional trader would. This is your call!"
      },
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        4816,
        -288
      ],
      "id": "46534efa-67cb-48f2-abbf-48944ed785e3",
      "name": "Think1"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        3008,
        -1376
      ],
      "id": "f14ec3f1-cf9b-46ff-9d3e-0567ec560d23",
      "name": "Trade entry/exit log",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 1706049972,
          "mode": "list",
          "cachedResultName": "PM_Actions",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        3008,
        -1232
      ],
      "id": "404adebd-5713-417a-9b7d-c903bf59c262",
      "name": "View your memory",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "toolDescription": "Use this to fetch options chains that are needed by you the http request you should be using is ------ https://data.alpaca.markets/v1beta1/options/snapshots/{{ $json.symbol }}",
        "url": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('URL', ``, 'string') }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        3168,
        -1360
      ],
      "id": "bf165b1a-2837-45aa-8cd4-7a053d9224e7",
      "name": "Alpaca Options2",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "toolDescription": "Use this to place any trades that you might need that arent something you can send downstream-- if needed use perplexity to problem solve how to format it. THIS IS TO BE USED FOR PLAYS OUTSIDE OF ACTIVE PM THUROUGH RESEARCH MUST BE DONE",
        "method": "POST",
        "url": "https://paper-api.alpaca.markets/v2",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('JSON', ``, 'json') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.2,
      "position": [
        3456,
        -1360
      ],
      "id": "74cbb4ee-dcd9-49e7-97c2-7539988e8b93",
      "name": "Place Different Orders"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        5120,
        48
      ],
      "id": "a73acc19-9592-4112-8189-2f8a7f4113cc",
      "name": "View Trade Journal",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 1706049972,
          "mode": "list",
          "cachedResultName": "PM_Actions",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        5280,
        48
      ],
      "id": "067a4ebd-e915-4a9c-9eb3-beb6f16d62fa",
      "name": "Look at PM notes",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "description": "Use this tool to ensure you think like a true macro reporter. "
      },
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        3440,
        464
      ],
      "id": "da55a003-89c3-4f37-9ecd-8bed415df66b",
      "name": "Think2"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        3456,
        768
      ],
      "id": "f0506187-3e45-4dbc-b759-bd2b9a004e45",
      "name": "Analyze trade journal",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "// Code Node \u2014 ET-aware router for PM + Trade Executor\n// PM runs every 20 minutes (at :30, :50, :10, :30, :50 pattern)\n// Executor runs 5x daily: 9:50, 10:30, 11:30, 1:10, 2:50\nconst TZ = 'America/New_York';\nconst nowUtc = new Date();\n\n// Pull ET fields without extra libs\nconst parts = new Intl.DateTimeFormat('en-US', {\n  timeZone: TZ,\n  hour12: false,\n  weekday: 'short',\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit',\n}).formatToParts(nowUtc);\n\nconst get = (t) => parts.find(p => p.type === t)?.value;\nconst hour = Number(get('hour'));      // ET hour 0..23\nconst minute = Number(get('minute'));  // ET minute 0..59\nconst weekdayStr = get('weekday');\nconst dayOfWeek = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].indexOf(weekdayStr);\n\n// Market session (ET)\nlet marketSession = 'pre-market';\nif (hour === 9 && minute >= 30) {\n  marketSession = 'market-open';                 // 09:30\u201309:59\n} else if (hour >= 10 && hour < 12) {\n  marketSession = 'morning';                     // 10:00\u201311:59\n} else if (hour >= 12 && hour < 14) {\n  marketSession = 'midday';                      // 12:00\u201313:59\n} else if (hour === 14 || (hour === 15 && minute < 30)) {\n  marketSession = 'afternoon';                   // 14:00\u201315:29\n} else if (hour === 15 && minute >= 50) {\n  marketSession = 'pre-close';                   // 15:50\u201315:59\n} else if (hour === 15 && minute >= 30) {\n  marketSession = 'close';                       // 15:30\u201315:49\n} else if (hour >= 16) {\n  marketSession = 'after-hours';                 // 16:00+\n}\n\n// Market hours check: 9:30 \u2264 t < 16:00 ET\nconst isMarketOpen = ((hour > 9 || (hour === 9 && minute >= 30)) && hour < 16);\n\n// Check if we're on a 20-minute interval (matching cron schedule)\nconst is20MinInterval = (\n  (hour === 9 && [30, 50].includes(minute)) ||\n  (hour >= 10 && hour <= 14 && [10, 30, 50].includes(minute)) ||\n  (hour === 15 && [10, 30, 50].includes(minute))\n);\n\n// PM runs every 20 minutes during market hours (9:30 to 15:50)\nconst executePM = is20MinInterval && \n  ((hour === 9 && minute >= 30) ||  // 9:30, 9:50\n   (hour >= 10 && hour <= 14) ||    // 10:10-14:50 (all 20-min intervals)\n   (hour === 15 && minute <= 50));  // 15:10-15:50\n\n// Trade Executor runs 5x daily at specific times\nconst executeTrader = (\n  (hour === 9 && minute === 50) ||   // 9:50\n  (hour === 10 && minute === 30) ||  // 10:30 (NEW)\n  (hour === 11 && minute === 30) ||  // 11:30\n  (hour === 13 && minute === 10) ||  // 1:10 PM\n  (hour === 14 && minute === 50)     // 2:50 PM\n);\n\n// Determine run type\nlet runType = \"Neither\";\nif (executeTrader && executePM) {\n  runType = \"PM + Trade Executor\";\n} else if (executePM) {\n  runType = \"PM Only\";\n} else if (executeTrader) {\n  runType = \"Trade Executor Only\";\n}\n\nconst timeString = `${hour.toString().padStart(2,'0')}:${minute.toString().padStart(2,'0')}`;\n\n// Debug info for schedule validation\nconst debugInfo = {\n  nextPM: (() => {\n    // Next 20-min interval\n    const allIntervals = [\n      {h:9,m:30},{h:9,m:50},\n      {h:10,m:10},{h:10,m:30},{h:10,m:50},\n      {h:11,m:10},{h:11,m:30},{h:11,m:50},\n      {h:12,m:10},{h:12,m:30},{h:12,m:50},\n      {h:13,m:10},{h:13,m:30},{h:13,m:50},\n      {h:14,m:10},{h:14,m:30},{h:14,m:50},\n      {h:15,m:10},{h:15,m:30},{h:15,m:50}\n    ];\n    const next = allIntervals.find(t => t.h > hour || (t.h === hour && t.m > minute));\n    return next ? `${next.h}:${String(next.m).padStart(2,'0')}` : 'Next day 9:30';\n  })(),\n  nextExecutor: (() => {\n    const executorTimes = [{h:9,m:50},{h:10,m:30},{h:11,m:30},{h:13,m:10},{h:14,m:50}];\n    const next = executorTimes.find(t => t.h > hour || (t.h === hour && t.m > minute));\n    return next ? `${next.h}:${String(next.m).padStart(2,'0')}` : 'Next day 9:50';\n  })(),\n  scheduleValid: is20MinInterval || \"WARNING: Off-schedule execution\"\n};\n\nreturn [{\n  json: {\n    executeTrader,\n    executePM,\n    timestamp: nowUtc.toISOString(),  // UTC for traceability\n    time: timeString,                 // ET HH:MM for logs\n    hour,\n    minute,\n    dayOfWeek,\n    marketSession,\n    isMarketOpen,\n    is20MinInterval,\n    runType,\n    cronRun: true,\n    tz: TZ,\n    debug: debugInfo\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        -496
      ],
      "id": "c94fc7b5-00cc-45e8-a321-946a33a2dc7f",
      "name": "Time Check"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d20ded49-8193-4e4f-bc29-fbce1707ccd4",
              "leftValue": "={{ $json.executeTrader }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        352,
        -368
      ],
      "id": "e179e53f-2104-4ecf-845d-f2cb9f35c526",
      "name": "Validate Executor"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 2024356696,
          "mode": "list",
          "cachedResultName": "Pm_Executor_coms",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        4976,
        48
      ],
      "id": "0abfc524-5657-494b-b2f2-ace2e669144b",
      "name": "Get Coms",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 2024356696,
          "mode": "list",
          "cachedResultName": "Pm_Executor_coms",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        3168,
        -1232
      ],
      "id": "7b31c99c-7481-4caf-beb8-b729a591cf8b",
      "name": "View Coms with Executor",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "model": "grok-4-1-fast-reasoning",
        "options": {
          "timeout": 700000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        3312,
        736
      ],
      "id": "cb7d0c76-6d61-4a9b-a46d-468606ba0b52",
      "name": "Macro Builder",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "USE THIS TO ENSURE YOU UNDERSTAND CURRENT TIME",
        "outputFieldName": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Output_Field_Name', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.dateTimeTool",
      "typeVersion": 2,
      "position": [
        3312,
        -1216
      ],
      "id": "8dfa3002-6ee4-4771-b3a9-676b114a9cda",
      "name": "Date & Time"
    },
    {
      "parameters": {
        "outputFieldName": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Output_Field_Name', ``, 'string') }}",
        "options": {
          "timezone": ""
        }
      },
      "type": "n8n-nodes-base.dateTimeTool",
      "typeVersion": 2,
      "position": [
        4672,
        176
      ],
      "id": "e4231e03-b62f-482e-88e7-9f89a7b0b998",
      "name": "Date & Time1"
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "simplify": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Simplify_Output', ``, 'boolean') }}",
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        3312,
        -1360
      ],
      "id": "c93653b0-7777-4b3d-8d4d-d073be728b7a",
      "name": "PM Perplexity",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "model": "grok-4-1-fast-reasoning",
        "options": {
          "timeout": 700000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        2864,
        -1312
      ],
      "id": "56992306-8b74-4b98-9db3-b4ca0552cafc",
      "name": "xAI Grok Chat Model",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Code Node \u2014 Agent \u2192 Multi-Action Normalizer v2.2\n * Purpose:\n *  - Accept agent output (stringified array, array, or single item)\n *  - Fan-out to one item per ACTION with a routing hint:\n *      route:'http'           -> { method, url, body } (Alpaca)\n *      route:'sheets.append'  -> { sheet, spreadsheet_id?, row } (Google Sheets)\n *  - Normalize Alpaca orders (2dp limit_price, mleg legs ratio_qty as string)\n *  - Keep/clean optional position_intent; drop unsupported position_effect\n *  - NO tool calls \u2014 just shape data for nodes\n *\n * Supported KINDS from agent:\n *  - \"http.order\" (or anything with a url)  -> route:'http'\n *  - \"sheets.append\"                        -> route:'sheets.append'\n *  - \"memory.set\" (alias for PM state row)  -> route:'sheets.append' (sheet=\"PM_State\")\n *\n * Error => emits a single { error, message, sample }\n */\n\nfunction toArray(x){ if(Array.isArray(x)) return x; if(x==null) return []; return [x]; }\nfunction parseIfString(x){\n  if(typeof x==='string'){\n    try { return JSON.parse(x); }\n    catch(e){ throw new Error(`Bad JSON string: ${String(x).slice(0,200)}`); }\n  }\n  return x;\n}\n\nconst ALLOWED_INTENTS = new Set(['buy_to_open','buy_to_close','sell_to_open','sell_to_close']);\n\nfunction cleanIntentFields(obj){\n  if(!obj || typeof obj !== 'object') return obj;\n  const out = { ...obj };\n\n  // Remove unsupported/legacy field\n  if('position_effect' in out) delete out.position_effect;\n\n  // Sanitize optional position_intent\n  if('position_intent' in out){\n    const v = String(out.position_intent || '').trim().toLowerCase();\n    if(!ALLOWED_INTENTS.has(v)) delete out.position_intent; else out.position_intent = v;\n  }\n\n  // Recurse into legs\n  if(Array.isArray(out.legs)){\n    out.legs = out.legs.map((leg)=>{\n      const l = { ...leg };\n      if('position_effect' in l) delete l.position_effect;\n      if('position_intent' in l){\n        const v = String(l.position_intent || '').trim().toLowerCase();\n        if(!ALLOWED_INTENTS.has(v)) delete l.position_intent; else l.position_intent = v;\n      }\n      return l;\n    });\n  }\n  return out;\n}\n\nfunction normalizeLimitPrice(body){\n  if(!body || typeof body!=='object') return body;\n  if(String(body.type||'').toLowerCase()==='limit' && body.limit_price!=null){\n    const n = Number(String(body.limit_price).replace(/[\\s,]/g,''));\n    if(Number.isFinite(n) && n>0) body.limit_price = n.toFixed(2);\n  }\n  return body;\n}\n\nfunction normalizeQtys(body){\n  if(!body || typeof body!=='object') return body;\n\n  // Map \"multileg\" alias to \"mleg\"\n  if(String(body.order_class||'').toLowerCase()==='multileg') body.order_class = 'mleg';\n\n  // Ensure qty is a string if present\n  if(body.qty!=null){\n    const qs = String(body.qty).trim();\n    if(qs) body.qty = qs;\n  }\n\n  // For mleg, ensure legs[].ratio_qty is a non-empty positive string\n  if(String(body.order_class||'').toLowerCase()==='mleg' && Array.isArray(body.legs)){\n    body.legs = body.legs.map((leg)=>{\n      const out = { ...leg };\n      const rq = out.ratio_qty==null ? '1' : String(out.ratio_qty).trim() || '1';\n      out.ratio_qty = rq;\n      return out;\n    });\n  }\n  return body;\n}\n\nfunction validateMleg(body){\n  if(String(body.order_class||'').toLowerCase()!=='mleg') return;\n  if(!Array.isArray(body.legs) || body.legs.length===0) throw new Error('mleg order requires legs[]');\n  for(const [i,leg] of body.legs.entries()){\n    if(!leg || typeof leg!=='object') throw new Error(`mleg leg[${i}] must be object`);\n    if(!leg.symbol || typeof leg.symbol!=='string') throw new Error(`mleg leg[${i}].symbol missing`);\n    const side = String(leg.side||'').toLowerCase();\n    if(side!=='buy' && side!=='sell') throw new Error(`mleg leg[${i}].side must be \"buy\" or \"sell\"`);\n    const rq = String(leg.ratio_qty||'').trim();\n    if(!rq || isNaN(Number(rq)) || Number(rq)<=0) throw new Error(`mleg leg[${i}].ratio_qty must be positive`);\n  }\n}\n\ntry{\n  // 1) Ingest agent payload\n  let raw = $json;\n  if(Array.isArray(raw.output)) raw = raw.output;\n  else if(typeof raw.output === 'string') raw = parseIfString(raw.output);\n\n  // 2) Canonicalize \u2192 array of plain objects (unwrap {json:...} if present)\n  const items = toArray(raw).map(it => it?.json ?? it ?? {});\n\n  const out = [];\n\n  for(const it of items){\n    const kind = String(it.kind || '').toLowerCase();\n\n    // -------- HTTP ORDERS (route:'http') ----------\n    if(kind.startsWith('http') || typeof it.url === 'string'){\n      const method = it.method || 'POST';\n      const url = typeof it.url === 'string' ? it.url.trim() : it.url;\n      if(!url) throw new Error('HTTP item missing url');\n\n      let body = parseIfString(it.body);\n      if(!body || typeof body!=='object') throw new Error(`HTTP item body must be object (got ${typeof body})`);\n\n      // Normalize per Alpaca expectations\n      body = cleanIntentFields(body);\n      body = normalizeQtys(body);\n      body = normalizeLimitPrice(body);\n      validateMleg(body);\n\n      out.push({ json: { route:'http', method, url, body } });\n      continue;\n    }\n\n    // -------- MEMORY alias -> PM_State append (route:'sheets.append') ----------\n    if(kind === 'memory.set' || kind === 'pm_state'){\n      const sheet = it.sheet || 'PM_State';\n      const row = it.row || it.data || it.state || {};\n      if(!row || typeof row!=='object') throw new Error('memory.set requires a row object');\n      out.push({ json: { route:'sheets.append', sheet, row } });\n      continue;\n    }\n\n    // -------- SHEETS APPENDS (route:'sheets.append') ----------\n    if(kind==='sheets.append' || it.sheet || it.rows || it.row || it.data){\n      const sheet = it.sheet;\n      const spreadsheet_id = it.spreadsheet_id; // optional\n      let rows = it.rows ?? it.row ?? it.data;\n      rows = toArray(rows);\n      if(!sheet || rows.length===0) throw new Error('Sheets append requires { sheet, rows[] }');\n      for(const r of rows){\n        if(!r || typeof r!=='object') throw new Error('Each Sheets row must be an object');\n        out.push({ json: { route:'sheets.append', sheet, spreadsheet_id, row: r } });\n      }\n      continue;\n    }\n\n    throw new Error('Unrecognized item: expected http.* | sheets.append | memory.set');\n  }\n\n  return out;\n\n}catch(e){\n  return [{\n    json:{\n      error:'Normalizer failed',\n      message:String(e.message || e),\n      sample: typeof $json.output === 'string' ? $json.output.slice(0,200) : undefined\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3472,
        -1536
      ],
      "id": "df76dc77-61c8-4d01-a612-571668ec6700",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4640,
        -416
      ],
      "id": "4d225232-9df1-445f-a5e0-f5521a42aba9",
      "name": "Code2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1520,
        -1008
      ],
      "id": "0369f814-512f-4553-bb6c-7dac548bc389",
      "name": "Merge6"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{$json}}",
        "options": {
          "systemMessage": "## ROLE & CONTEXT\nYou are the **macro strategist** for an institutional options fund. Your briefings inform the **Portfolio Manager's** positioning decisions across a multi-sector, premium-selling book (150+ names: tech, consumer, crypto, industrials, restaurants). Think Goldman Sachs desk coverage: sophisticated, direct, zero fluff, accurate, and **execution-aware**.\n\nYour PM runs an aggressive, risk-on portfolio. They need portfolio-level context on **when to press, when to reduce, when to wait**\u2014not individual trade ideas. Frame your analysis as considerations and implications, not mandates. But be **clear about what today's action means for portfolio heat and near-term risk.**\n\n---\n\n## CRITICAL: TIMING & MARKET HOURS CONTEXT\n\n**MANDATORY FIRST STEPS:**\n1. **Use the date/time tool** to determine:\n   - Current ET timestamp\n   - Whether market is currently OPEN (9:30 AM - 4:00 PM ET, Mon-Fri)\n   - Data freshness (compare current time vs `meta.generated_at` from JSON)\n\n2. **Use the Think tool** to plan your approach:\n   - What information do you need from the trade journal?\n   - What catalyst timings need verification via Perplexity?\n   - What calculations need the calculator?\n   - Is the data fresh enough for real-time decisions?\n\n**Frame your entire brief around market status:**\n- **If market is OPEN:** Brief is for immediate positioning decisions. Use present tense: \"SPX is trading down 0.47% at 5,835 as of [HH:MM ET]\"\n- **If market is CLOSED:** Brief is for next-session positioning. Use past tense: \"SPX closed down 0.47% at 5,835\"\n- **If data is >30 mins stale during market hours:** Add prominent warning at top: \"\u26a0\ufe0f DATA ALERT: Analysis based on [time] data; market may have moved significantly since then. Use caution for immediate decisions.\"\n\n**Then batch your remaining tool calls together** in a single response: Sheets + Perplexity (for catalyst timing) + Calculator (for math).\n\n---\n\n## YOUR DATA INPUTS\n\nThe JSON input contains:\n- `sonar_macro`: Latest market news, catalysts, Fed commentary (with `created` timestamp and `search_results`)\n- `technical_analysis`: Array of 9 full TA objects (SPX, DJI, RUT, VIX, Gold, BTC, DXY, TNX, TIP)\n- `ta_by_symbol`: Quick lookup object (e.g., `ta_by_symbol[\"^VIX\"]`)\n- `meta.generated_at`: Timestamp of this data snapshot (CRITICAL: check freshness)\n\n**Extract the date from** `meta.generated_at` or `sonar_macro.search_results[0].date` - this is today's date for your analysis.\n\n---\n\n## YOUR TOOLS - USE STRATEGICALLY\n\n1. **Date/Time**: MANDATORY FIRST - Get current ET timestamp, determine market hours, check data freshness\n2. **Think**: Plan your tool calls before executing\n3. **Google Sheets (Trade Journal)**: Check current portfolio exposure, positions, Greeks, recent P&L\n4. **Perplexity**: ENCOURAGED - Verify exact catalyst timing (FOMC, earnings, data releases), clear up any ambiguous market developments, sector deep-dives, or breaking news not in stale data\n5. **Calculator**: MANDATORY for all percentage math - MA distances, expected moves, performance deltas\n\n**Do not hesitate to use Perplexity** if:\n- You need exact times for upcoming catalysts\n- Data seems stale and you need current market context\n- Major news may have broken since data generation\n- You need to verify ambiguous or conflicting information\n\n**Workflow:** Date/Time FIRST \u2192 Think \u2192 Batch tools (Sheets + Perplexity + Calculator as needed) \u2192 Deliver briefing\n\n---\n\n## OUTPUT FORMAT (700-900 words, natural prose)\n\n### BRIEFING HEADER\n**Current Context:**\n- **Time:** [HH:MM AM/PM ET, Day, Date]\n- **Market Status:** [OPEN | CLOSED | PRE-MARKET | AFTER-HOURS]\n- **Data Generated:** [timestamp from meta.generated_at]\n- **Data Age:** [X minutes/hours ago]\n- [IF STALE: **\u26a0\ufe0f DATA ALERT:** Market may have moved since data generation. Exercise caution.]\n\n---\n\n### WHAT MATTERS NOW\n\n**SESSION REALITY:**\n\n**[IF MARKET OPEN]**\n- **As of [HH:MM ET]:** State current levels (e.g., \"SPX trading at 5,835, down 0.47% | Russell at 2,415, down 0.61%\")\n- **Intraday path:** Opening level \u2192 current \u2192 momentum direction (grinding lower? stabilizing? accelerating?)\n- **Live breadth/vol:** If available: advancers/decliners, VIX current level and direction today\n- **For premium sellers NOW:** Are open short positions under immediate stress? Is realized vol expanding? Is this accelerating pressure or stabilizing?\n\n**[IF MARKET CLOSED]**\n- **Final settlement:** State closing levels (e.g., \"SPX closed at 5,835, down 0.47% | Russell closed at 2,415, down 0.61%\")\n- **Session recap:** Opening \u2192 intraday high/low \u2192 close character (steady grind, gap-and-fade, late-day acceleration?)\n- **Breadth/vol final:** Advancers/decliners ratio, VIX close and change\n- **For premium sellers:** How did Greeks finish? Mark-to-market on short positions? Overnight risk into tomorrow?\n\n**Contextualize against structure:** \"Pullback within uptrend\" vs \"breakdown threatening support\" vs \"breakdown confirmed below key level\"\n\n**KEY DRIVERS (next 1-5 days):**\n3-5 bullets on most important drivers with portfolio impact. Include SPX/RUT implied ranges using `expectedMove_1d_pct` and `expectedMove_5d_pct` from `optionsMetrics` (convert % to points via Calculator). Cite sources and TA signals.\n\n---\n\n### TECHNICAL-FUNDAMENTAL SYNTHESIS\n\n**Distinguish session action from structural positioning:**\n\n**TODAY'S ACTION:**\nDescribe in detail\u2014broad or narrow, sector-driven, volatility character, opening behavior, late-day acceleration/fade, volume profile.\n\n**For premium-selling book specifically:**\n- Is today creating gamma risk (big intraday swings)?\n- Is vega expanding (VIX spiking while short vol positions open)?\n- Are short strikes getting tested or breached?\n- Is realized vol (HV) rising faster than implied (VIX)?\n\n**STRUCTURAL POSITIONING:**\nUse S&P/Dow/Russell from `technical_analysis`:\n- Quote actual 20/50/200-day MA values from `movingAverages`\n- State distances using `analysis.priceVsRefMA` or calculate via Calculator\n- Tag TA signals: *(Strong Bullish, Russell 2000)*, *(Bearish, VIX)*, etc.\n\n**Frame correctly for premium sellers:**\n- **Down 40+ bps + VIX spike:** \"Short premium under pressure; structure still bullish but near-term momentum defensive\u2014gamma risk elevated\"\n- **Up with VIX fading:** \"Premium decay environment intact; structure supportive for short exposure\"\n- **Breakdown below key MA + vol expanding:** \"Structure invalidated; short exposure at significant risk of forced covering\"\n- **Shallow pullback + low vol:** \"Corrective within uptrend; premium decay environment undisturbed\"\n\n**CROSS-ASSET LAYERING:**\n- **Convergence:** MA stacks + supportive headlines + risk-on cross-assets \u2192 state plainly with conviction\n- **Divergence:** (e.g., equities down + dollar weak + bonds rallying) \u2192 explain both sides; note correlation breakdown implications for portfolio Greeks and hedging effectiveness\n- Integrate **DXY, Gold, BTC, TNX, TIP** from `technical_analysis`\n- If DXY has `meta.warnings`, note proxy usage: \"DXY data using DX=F/UUP proxy\"\n\n---\n\n### MARKET DYNAMICS\n\n**FED PULSE:**\nTop 2-3 Fed items from `sonar_macro.search_results` (today's timestamps only). If officials conflict, label **\"Conflict:\"** and present both views with citations **(source, YYYY-MM-DD HH:MM ET)**.\n\n**BREADTH/BETA:**\nCompare Russell vs S&P/Dow using `performance.weeklyChange` **and today's relative performance**. Implications:\n- Small-cap leadership = broadening, risk-on\n- Small-cap lagging = narrowing, defensive rotation\n- Impact on correlation regime and portfolio factor exposures\n\n**VOL REGIME** (critical for premium sellers):\n- **VIX:** Current level, trend from `technical_analysis`, position vs MAs\n- **HV:** Check `optionsMetrics.hv20_pct` across SPX/RUT\u2014is realized vol rising?\n- **Environment:** Compress-premium (low VIX, decaying HV) or expand-strikes (VIX spiking, HV rising)?\n- **Warning signs:** Realized vol (HV) expanding while implied (VIX) lags = potential gamma trap; VIX spike + broad selling = short premium getting marked, risk of forced covering\n\n**CROSS-ASSET CONFIRMATION:**\nOne line each: Dollar (DXY), real rates (TNX-TIP spread), risk proxy (BTC). Do they confirm or contradict today's equity action?\n\n**CREDIT TONE:**\nIf credit ETFs available in `technical_analysis` (HYG, LQD): position vs MAs, spread behavior. \n- Credit widening + equity selling = de-risking confirmation\n- Credit stable + equity selling = less systemic concern\n\n---\n\n### PORTFOLIO POSITIONING CONTEXT (Next 1-3 Sessions)\n\n**Synthesize: today's action + technical setup + vol environment + portfolio exposure (from Sheets) \u2192 clear positioning guidance**\n\n**FOR PREMIUM-SELLING BOOK:**\n\n**[IF MARKET DOWN 40+ BPS WITH VOL EXPANDING]**\nAssess whether short premium is under immediate threat:\n- **Profit-taking squeeze** (shallow, low/stable vol, credit stable, VIX calm) \u2192 \"Temporary pressure; premium decay thesis intact for patient holders\"\n- **Momentum shift** (accelerating decline, breadth deteriorating, late-day selling, VIX rising) \u2192 \"Conditions suggest reducing gross exposure or adding defensive hedges until stabilization\"\n- **Breakdown with vol event** (key level lost, VIX spiking, credit widening, HV > IV) \u2192 \"Short premium at risk; defensive posture warranted\u2014consider closing exposed strikes or hedging aggressively\"\n\n**[IF MARKET GRINDING HIGHER WITH VIX FADING]**\n\"Premium decay environment optimal; structure supports maintaining or selectively adding short exposure with defined stops\"\n\n**CRITICAL PORTFOLIO CONSIDERATIONS:**\n\n**Heat Management:**\n- Do stretched conditions + upcoming vol events warrant trimming gross or delta?\n- Example: VIX <12 + SPX >3% above 50-day + FOMC in 2 days = reduce exposure ahead of catalyst\n\n**Gamma Risk:**\n- Is today's intraday action creating realized vol that threatens short strikes?\n- Are we approaching pinning levels or major strikes with high open interest?\n\n**Vega Risk:**\n- Is implied vol rising faster than time decay benefits short positions?\n- Is VIX term structure flattening (near-term risk) or steep (favorable carry)?\n\n**Correlation Regime:**\n- Are cross-assets behaving normally?\n- Examples of concern: VIX low despite equity stretch; gold+equities+bonds all rallying = crowded trade that can unwind violently\n\n**Sector/Factor Tilts:**\nGiven portfolio exposures from Sheets:\n- What does regime suggest about small-cap beta exposure?\n- Growth vs value positioning?\n- Consumer discretionary concentration risk?\n- Tech single-name concentration if sector rolling over?\n\n**POSITIONING BIAS (be explicit):**\n\n**[IF MARKET OPEN]** State whether current conditions warrant:\n- **Immediate action:** \"Reduce gross NOW\u2014momentum accelerating against short exposure\"\n- **Monitor:** \"Let session play out; reassess before close\"\n- **Maintain:** \"Premium decay working; no action needed unless [specific level] breaks\"\n\n**[IF MARKET CLOSED]** State game plan for tomorrow:\n- **(a) Reduce gross / add hedges tomorrow morning** \u2192 when: momentum deteriorating, vol expanding, short premium marked significantly\n- **(b) Maintain short exposure / let decay work** \u2192 when: structure intact, shallow pullback, premium environment supportive  \n- **(c) Defensive posture / wait for clarity** \u2192 when: breakdown in progress, mixed signals, correlation regime breaking\n- **(d) Add short premium on strength tomorrow** \u2192 when: pullback corrective, structure intact, defined risk clear, vol environment optimal\n\nFrame as **\"conditions suggest\"** not \"you must.\" Be specific about confirmation signals or invalidation triggers.\n\n---\n\n### KEY LEVELS & CATALYSTS\n\n**LEVELS:**\nConcrete SPX/DJI/RUT supports/resistances:\n- Round numbers (e.g., 5,800, 5,850, 5,900 for SPX)\n- 20/50/200-day MAs from `movingAverages` (quote actual values)\n- Calculate % distances via Calculator\n\n**Critical:** Note whether today's action tested, held, or broke these levels\u2014essential for stop placement and strike selection for short positions.\n\n**CATALYSTS (next 1-5 days):**\nFor each: **Date, exact time ET, event name, portfolio relevance**\n\nPortfolio relevance = vol impact, directional risk, gamma event potential, whether to reduce exposure ahead or position for post-event opportunity.\n\n**Use Perplexity if exact times missing** from `sonar_macro`. Don't guess\u2014verify and cite: **(source, YYYY-MM-DD)**.\n\n---\n\n### BOTTOM LINE\n\n**Decisive synthesis for next 1-5 trading days:**\n\n**STRUCTURAL REGIME:**\n- Use data to determine: **Risk-On** (all 3 indices above 50/200-day + VIX bearish) | **Risk-Off** (inverse) | **Mixed** (otherwise)\n- **Always clarify distinction:** \"Structure remains risk-on (all indices above rising 50/200-day), but today's momentum is defensive\u2014short premium under near-term pressure.\"\n\n**PRIMARY NEAR-TERM RISKS:**\nGiven today's action, upcoming catalysts, vol environment, and portfolio exposure.\n\n**EXPLICIT FLIP CONDITIONS:**\nClear levels/conditions that would change structural regime:\n- Example: \"Regime shifts risk-off if Russell loses 2,400 and VIX reclaims 18 with expanding credit spreads\"\n- Example: \"Pullback becomes breakdown if SPX closes below 5,820 on expanding volume\"\n\n**FOR THE PM\u2014POSITIONING GUIDANCE:**\n\nGiven: today's action + portfolio exposure (from Sheets) + vol regime + upcoming catalysts\n\n**Conditions suggest:**\n\n**[IF MARKET OPEN - immediate guidance]**\n- Current momentum warrants [immediate action | continued monitoring | no change]\n- Specific: \"Reduce gross by [X]% before close\" or \"Maintain positions unless SPX breaks [level]\" or \"Add hedges if VIX reclaims [level]\"\n\n**[IF MARKET CLOSED - next session guidance]**\n- **(a) Reduce gross / add hedges** \u2192 when momentum deteriorating, vol expanding, short premium marked\n- **(b) Maintain / let decay work** \u2192 when structure intact, pullback shallow, premium environment supportive\n- **(c) Defensive / wait for clarity** \u2192 when breakdown in progress or mixed signals\n- **(d) Add short premium selectively** \u2192 when corrective pullback, defined risk, optimal vol environment\n\n**Key confirmation/invalidation levels:** Be specific about what price action tomorrow would confirm or invalidate your assessment.\n\nFrame as **\"conditions suggest\"** not \"you must.\"\n\n---\n\n## RULES & STANDARDS\n\n**Real-Time Awareness (CRITICAL):**\n- **ALWAYS use date/time tool FIRST** to establish market hours context and data freshness\n- Frame language appropriately: \"is trading at\" (open) vs \"closed at\" (closed)\n- If data >30 mins stale during market hours, add prominent warning\n- Distinguish immediate action needed (market open + momentum accelerating) from positioning for next session (market closed)\n- **Never suggest adding short premium exposure during open session if market momentum is accelerating against you and vol is expanding**\n\n**Analysis Standards:**\n- **Session vs Structure:** Don't say \"bullish regime\u2014premium decay environment\" when market is down 40 bps with VIX spiking\u2014say \"structurally bullish but near-term defensive; short premium under pressure; suggest reducing gross\"\n- **Premium-seller lens:** Vol expansion + drawdown = very different risk than directional book. Be explicit about gamma/vega implications\n- **Execution-aware:** PM needs to know if TODAY argues for reducing, maintaining, or adding\u2014not just descriptive market color\n- Extract date from `meta.generated_at`\u2014this is today\n- Focus on today's news from `sonar_macro.search_results` (filter by date field)\n- **Russell comparison mandatory**\u2014small-cap momentum = breadth/beta signal for overall risk appetite\n- **Convergence = confidence; divergence = explain both** + portfolio implications\n- Use provided numbers or Calculator\u2014**no hallucinations, no guessing**\n- **Use Perplexity liberally**\u2014don't guess catalyst times or leave ambiguity when verification is one search away\n\n**Tone & Format:**\n- Professional, direct, institutional-grade (Goldman Sachs desk coverage level)\n- Frame as \"environment suggests\" or \"conditions indicate\" not \"you must\"\n- Considerations and implications, but **clear about positioning bias**\n- Section headers as structured above\n- Inline citations: **(source, YYYY-MM-DD HH:MM ET)** or **(TA Signal, Index)**\n- Limit citations to 3-5 load-bearing claims\n- Natural prose\u2014no excessive formatting, no emojis\n\n**Regime Fallback Logic:**\n- **Risk-On:** All 3 indices (SPX, DJI, RUT) have `priceAboveSMA50 = true` AND `sma50AboveSMA200 = true`, with VIX in bearish structure\n- **Risk-Off:** Inverse of above\n- **Mixed:** Otherwise\n- **Always add context:** \"Structure is [X], but today's momentum suggests [Y] for near-term positioning\"\n\n---\n\n## FINAL CHECKLIST BEFORE DELIVERY\n\n\u2713 Used date/time tool to establish current context and data freshness  \n\u2713 Used Think tool to plan approach  \n\u2713 Used Perplexity to verify any ambiguous catalyst timing or breaking developments  \n\u2713 Used Calculator for all percentage math  \n\u2713 Checked trade journal (Sheets) for portfolio context  \n\u2713 Distinguished today's session action from structural positioning  \n\u2713 Provided clear positioning bias given market status (open vs closed)  \n\u2713 Included explicit flip conditions and confirmation levels  \n\u2713 Framed for premium-selling book (gamma/vega awareness)  \n\u2713 Limited citations to 3-5 load-bearing claims  \n\u2713 Professional, execution-aware tone throughout  \n\n**Deliver one Goldman-caliber briefing. Never suggest aggressive short premium selling when market is down 40+ bps with expanding vol during market hours.**",
          "batching": {
            "batchSize": 1
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2032,
        -1024
      ],
      "id": "2d1b4763-eb8f-4a2e-a1ff-c4ebd30f8bae",
      "name": "Macro Reporter1"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        2208,
        -704
      ],
      "id": "95984bd6-fe2e-4bca-9ad4-ea04045f63fa",
      "name": "Calculator3"
    },
    {
      "parameters": {
        "url": "={{ \"https://query1.finance.yahoo.com/v8/finance/chart/\" \n   + encodeURIComponent($json.symbol) \n   + \"?interval=1d&range=1y&includePrePost=false\" }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1104,
        -960
      ],
      "id": "fe80b37d-a1ba-48f3-a7cd-335c7222a0a6",
      "name": "Market Data1"
    },
    {
      "parameters": {
        "jsCode": "// Output list of tickers for Yahoo v8 chart calls\nreturn [\n  { json: { symbol: \"^GSPC\",   name: \"S&P 500\" } },\n  { json: { symbol: \"^DJI\",    name: \"Dow Jones\" } },\n  { json: { symbol: \"^RUT\",    name: \"Russell 2000\" } },\n  { json: { symbol: \"^VIX\",    name: \"VIX\" } },\n  { json: { symbol: \"GC=F\",    name: \"Gold Futures\" } },\n  { json: { symbol: \"BTC-USD\", name: \"Bitcoin (USD)\" } },\n  { json: { symbol: \"DX-Y.NYB\",name: \"US Dollar Index (DXY)\" } }, // if this errors, try \"DX=F\"\n  { json: { symbol: \"^TNX\",    name: \"US 10Y Treasury Yield (\u00d710)\" } },\n  { json: { symbol: \"TIP\",     name: \"iShares TIPS ETF\" } }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -960
      ],
      "id": "b9dbb265-1fb8-4b1f-bc22-e9664516991a",
      "name": "Indexes1"
    },
    {
      "parameters": {
        "jsCode": "// Robust index analyzer for n8n Code node (Yahoo v8 chart)\n// Adds options-focused metrics: HV20/HV60, 1d/5d expected move, ATR(14)/ATR%,\n// Bollinger (20,2) width/position, 52w distances/percentile, RVOL10.\n// Handles DXY quirks and yield scaling (^TNX/^TYX/^IRX).\n\nconst items = $input.all();\n\n/* ---------------- helpers ---------------- */\nfunction normalize(items) {\n  const out = [];\n  for (const it of items) {\n    const payload = it?.json ?? it;\n    if (Array.isArray(payload)) for (const el of payload) out.push(el?.json ?? el);\n    else out.push(payload);\n  }\n  return out;\n}\nfunction pickResult(node) {\n  const res = node?.chart?.result?.[0];\n  if (!res || !res.indicators?.quote?.[0]?.close || !res.timestamp) return null;\n  return res;\n}\nfunction normalizeSymbol(sym) {\n  if (!sym) return 'UNKNOWN';\n  if (sym === 'DX-F.NYB') return 'DX-Y.NYB'; // occasional server-side variant\n  return sym;\n}\nfunction nameFor(sym, meta) {\n  const map = {\n    '^GSPC':'S&P 500','^DJI':'Dow Jones','^RUT':'Russell 2000','^VIX':'VIX',\n    'GC=F':'Gold Futures','BTC-USD':'Bitcoin (USD)',\n    'DX-Y.NYB':'US Dollar Index (DXY)','DX=F':'US Dollar Index (futures)',\n    '^TNX':'US 10Y Treasury Yield','^TYX':'US 30Y Treasury Yield','^IRX':'US 13W T-Bill Yield',\n    'TIP':'iShares TIPS ETF'\n  };\n  return map[sym] || meta?.longName || meta?.shortName || sym;\n}\nconst YIELD_TICKERS = new Set(['^TNX','^TYX','^IRX']);\nfunction norm(n){ const x=Number(n); return isFinite(x)?x:null; }\n// Adaptive yield scaling (Yahoo sometimes returns \u00d710)\nfunction normClose(sym, c) {\n  const n = norm(c); if (n==null) return null;\n  return YIELD_TICKERS.has(sym) ? (n > 20 ? +(n/10).toFixed(3) : +n.toFixed(3)) : n;\n}\nfunction avg(arr){ const a=arr.filter(v=>v!=null); return a.length? a.reduce((s,x)=>s+x,0)/a.length : null; }\nfunction stddev(arr){\n  const a=arr.filter(v=>v!=null); if(a.length<2) return null;\n  const m=avg(a); const v=a.reduce((s,x)=>s+(x-m)*(x-m),0)/(a.length-1);\n  return Math.sqrt(v);\n}\nfunction calcSMA(data, p){ if(data.length<p) return null;\n  const out=new Array(data.length).fill(null); let sum=0;\n  for(let i=0;i<data.length;i++){ sum+=data[i].close; if(i>=p) sum-=data[i-p].close; if(i>=p-1) out[i]=+(sum/p).toFixed(2); }\n  return out;\n}\nfunction calcEMA(data, p){\n  if (data.length<p) return null;\n  const out=new Array(data.length).fill(null); const k=2/(p+1);\n  let sum=0; for(let i=0;i<p;i++) sum+=data[i].close;\n  let ema=sum/p; out[p-1]=+ema.toFixed(2);\n  for(let i=p;i<data.length;i++){ ema=data[i].close*k+ema*(1-k); out[i]=+ema.toFixed(2); }\n  return out;\n}\nfunction logReturns(prices){\n  const r=[]; for(let i=1;i<prices.length;i++){\n    const a=prices[i-1].close, b=prices[i].close;\n    if(a!=null && b!=null) r.push(Math.log(b/a));\n  } return r;\n}\nfunction trueRanges(prices){\n  const tr=[]; for(let i=0;i<prices.length;i++){\n    const h=prices[i].high, l=prices[i].low, pc=i>0?prices[i-1].close:null;\n    if(h==null||l==null||pc==null){ if(i>0) tr.push(h!=null&&l!=null? (h-l):null); continue; }\n    tr.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc)));\n  } return tr;\n}\n\n/* ---------------- main ---------------- */\nconst payloads = normalize(items);\nconst results = [];\n\nfor (const node of payloads) {\n  const res = pickResult(node);\n  if (!res) continue;\n\n  const sym  = normalizeSymbol(res.meta?.symbol ?? 'UNKNOWN');\n  const name = nameFor(sym, res.meta);\n\n  const q = res.indicators.quote?.[0] || {};\n  const ts = res.timestamp;\n\n  // Build series (O/H/L/C/V)\n  const prices = [];\n  for (let i=0;i<ts.length;i++){\n    const close = normClose(sym, q.close?.[i]);\n    if (close==null) continue;\n    prices.push({\n      date: new Date(ts[i]*1000).toISOString().slice(0,10),\n      ts: ts[i],\n      open:  normClose(sym, q.open?.[i]),\n      high:  normClose(sym, q.high?.[i]),\n      low:   normClose(sym, q.low?.[i]),\n      close,\n      volume: norm(q.volume?.[i])\n    });\n  }\n  if (prices.length < 10) continue;\n\n  // MAs\n  const SMA10=calcSMA(prices,10), SMA20=calcSMA(prices,20), SMA50=calcSMA(prices,50), SMA200=calcSMA(prices,200);\n  const EMA20=calcEMA(prices,20);\n  const last = prices[prices.length-1];\n  const last10=SMA10?.at(-1)??null, last20=SMA20?.at(-1)??null, last50=SMA50?.at(-1)??null, last200=SMA200?.at(-1)??null, lastE20=EMA20?.at(-1)??null;\n\n  // Trends\n  let shortTerm='INSUFFICIENT_DATA';\n  if(last10!=null && last20!=null){\n    shortTerm = (last.close>last10 && last10>last20) ? 'Bullish'\n            :  (last.close<last10 && last10<last20) ? 'Bearish' : 'Neutral';\n  }\n  let longTerm='INSUFFICIENT_DATA';\n  if(last50!=null && last200!=null) longTerm = last50>last200?'Bullish':(last50<last200?'Bearish':'Neutral');\n  else if(last20!=null && last50!=null) longTerm = last20>last50?'Bullish (20>50 fallback)':(last20<last50?'Bearish (20<50 fallback)':'Neutral');\n\n  let overall='Neutral';\n  if(last200!=null && last50!=null && last20!=null){\n    if(last.close>last20 && last20>last50 && last50>last200) overall='Strong Bullish';\n    else if(last.close<last20 && last20<last50 && last50<last200) overall='Strong Bearish';\n    else if(last.close>last50 && last50>last200) overall='Bullish';\n    else if(last.close<last50 && last50<last200) overall='Bearish';\n  } else if(last50!=null && last20!=null){\n    if(last.close>last20 && last20>last50) overall='Bullish';\n    else if(last.close<last20 && last20<last50) overall='Bearish';\n  }\n\n  let signal='Hold';\n  if(SMA20 && SMA50 && SMA20.length>=2 && SMA50.length>=2){\n    const prev20=SMA20[SMA20.length-2], prev50=SMA50[SMA50.length-2];\n    if(prev20!=null && prev50!=null){\n      if(prev20<=prev50 && last20>last50) signal='Golden Cross (20/50)';\n      if(prev20>=prev50 && last20<last50) signal='Death Cross (20/50)';\n    }\n  }\n\n  const refMA = last200 ?? last50 ?? last20 ?? null;\n  const refLabel = (last200!=null)?'200':(last50!=null?'50':'20');\n  let distPct=null, strength='INSUFFICIENT_DATA';\n  if(refMA!=null && refMA!==0){\n    distPct=+(((last.close-refMA)/refMA)*100).toFixed(2);\n    strength = distPct>10?'Very Strong': distPct>5?'Strong': distPct>0?'Above Average'\n            :  distPct>-5?'Below Average': distPct>-10?'Weak':'Very Weak';\n  }\n\n  // Perf windows\n  const dailyChange  = prices.length>1  ? +(((last.close - prices.at(-2).close)/prices.at(-2).close)*100).toFixed(2) : null;\n  const weeklyChange = prices.length>6  ? +(((last.close - prices.at(-6).close)/prices.at(-6).close)*100).toFixed(2) : null;\n  const monthlyChange= prices.length>21 ? +(((last.close - prices.at(-21).close)/prices.at(-21).close)*100).toFixed(2) : null;\n\n  // ---------- Options-oriented metrics ----------\n  const rets = logReturns(prices);\n  const sigma20 = rets.length>=20 ? stddev(rets.slice(-20)) : null;\n  const sigma60 = rets.length>=60 ? stddev(rets.slice(-60)) : null;\n  const hv20 = sigma20!=null ? +(sigma20*Math.sqrt(252)*100).toFixed(2) : null; // %\n  const hv60 = sigma60!=null ? +(sigma60*Math.sqrt(252)*100).toFixed(2) : null; // %\n\n  const em1d_pct = sigma20!=null ? +(sigma20*100).toFixed(2) : null;\n  const em5d_pct = sigma20!=null ? +((sigma20*Math.sqrt(5))*100).toFixed(2) : null;\n  const em1d_abs = (em1d_pct!=null) ? +((last.close*(em1d_pct/100))).toFixed(2) : null;\n  const em5d_abs = (em5d_pct!=null) ? +((last.close*(em5d_pct/100))).toFixed(2) : null;\n\n  // ATR(14)\n  const trs = trueRanges(prices);\n  const atr14 = trs.length>=14 ? +(avg(trs.slice(-14))?.toFixed(4)) : null;\n  const atrPct = (atr14!=null && last.close) ? +((atr14/last.close)*100).toFixed(2) : null;\n\n  // Bollinger (20, 2\u03c3)\n  const closes = prices.map(p=>p.close);\n  const last20Closes = closes.slice(-20);\n  const bbMid = (last20Closes.length===20) ? +(avg(last20Closes).toFixed(2)) : null;\n  const bbStd = (last20Closes.length===20) ? stddev(last20Closes) : null;\n  const bbUpper = (bbMid!=null && bbStd!=null) ? +(bbMid + 2*bbStd).toFixed(2) : null;\n  const bbLower = (bbMid!=null && bbStd!=null) ? +(bbMid - 2*bbStd).toFixed(2) : null;\n  const bbWidthPct = (bbUpper!=null && bbLower!=null && bbMid) ? +(((bbUpper-bbLower)/bbMid)*100).toFixed(2) : null;\n  let bbPos = null;\n  if (bbUpper!=null && bbLower!=null && (bbUpper-bbLower)!==0) {\n    bbPos = +(((last.close - bbLower)/(bbUpper - bbLower))).toFixed(2); // 0..1\n  }\n\n  // 52-week stats (use highs/lows if available, else closes)\n  const lookback = Math.min(prices.length, 252);\n  const highs = prices.slice(-lookback).map(p=>p.high ?? p.close);\n  const lows  = prices.slice(-lookback).map(p=>p.low  ?? p.close);\n  const hi52 = Math.max(...highs.filter(v=>v!=null));\n  const lo52 = Math.min(...lows.filter(v=>v!=null));\n  const distHiPct = (hi52 && last.close) ? +(((last.close-hi52)/hi52)*100).toFixed(2) : null; // negative if below high\n  const distLoPct = (lo52 && last.close) ? +(((last.close-lo52)/lo52)*100).toFixed(2) : null; // positive if above low\n  const range52 = (hi52!=null && lo52!=null) ? (hi52-lo52) : null;\n  const pctile52 = (range52 && range52!==0) ? +(((last.close - lo52)/range52).toFixed(2)) : null; // 0..1\n\n  // RVOL\n  const vols = prices.map(p=>p.volume).filter(v=>v!=null);\n  const avgVol10 = vols.length>=10 ? avg(vols.slice(-10)) : null;\n  const avgVol20 = vols.length>=20 ? avg(vols.slice(-20)) : null;\n  const rvol10 = (avgVol10 && last.volume!=null) ? +((last.volume/avgVol10)).toFixed(2) : null;\n\n  // DXY quality warning\n  const warnings = [];\n  if (sym==='DX-Y.NYB' && last200!=null) {\n    const dev = Math.abs((last.close - last200)/last200);\n    if (dev > 0.12) warnings.push('DXY_series_mismatch_consider_DX=F_or_UUP');\n  }\n\n  const units = YIELD_TICKERS.has(sym) ? 'yield_pct' : 'price';\n\n  results.push({\n    json: {\n      index: name,\n      symbol: sym,\n      units,\n      date: last.date,\n      currentPrice: +last.close.toFixed(2),\n      analysis: {\n        overallTrend: overall, shortTerm, longTerm, signal,\n        marketStrength: strength, referenceMA: refLabel, priceVsRefMA: distPct\n      },\n      movingAverages: { sma10:last10, sma20:last20, sma50:last50, sma200:last200, ema20:lastE20 },\n      technicals: {\n        priceAboveSMA20: last20!=null ? last.close > last20 : null,\n        priceAboveSMA50: last50!=null ? last.close > last50 : null,\n        priceAboveSMA200: last200!=null ? last.close > last200 : null,\n        sma20AboveSMA50: (last20!=null && last50!=null) ? last20>last50 : null,\n        sma50AboveSMA200: (last50!=null && last200!=null) ? last50>last200 : null\n      },\n      performance: { dailyChange, weeklyChange, monthlyChange },\n      optionsMetrics: {\n        hv20_pct: hv20, hv60_pct: hv60,\n        expectedMove_1d_pct: em1d_pct, expectedMove_5d_pct: em5d_pct,\n        expectedMove_1d_abs: em1d_abs, expectedMove_5d_abs: em5d_abs,\n        atr14: atr14, atrPct,\n        bollinger20: { mid: bbMid, upper: bbUpper, lower: bbLower, widthPct: bbWidthPct, position01: bbPos },\n        rvol10: rvol10, avgVol20: avgVol20!=null? +avgVol20.toFixed(0): null,\n        distTo52wHighPct: distHiPct, distTo52wLowPct: distLoPct, pctile52w_0to1: pctile52\n      },\n      meta: {\n        bars: prices.length,\n        nameFromMeta: res.meta?.longName || res.meta?.shortName || null,\n        rangeSufficientFor200: prices.length >= 200,\n        warnings: warnings.length ? warnings : null\n      }\n    }\n  });\n}\n\nreturn results.length\n  ? results\n  : [{ json: { error: 'NO_DATA', hint: 'Ensure URL uses encodeURIComponent(symbol), range >= 1y, items under .json, and handle chart.error.' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        -960
      ],
      "id": "d6b2ec2f-69cd-4dd6-a01f-27d2311d5c7b",
      "name": "Market Techicals1"
    },
    {
      "parameters": {
        "model": "sonar-reasoning",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "simplify": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Simplify_Output', ``, 'boolean') }}",
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        2256,
        -864
      ],
      "id": "e6062d63-99b6-45a5-8a99-f73dedae0b80",
      "name": "Perplexity Macro Tool1",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "description": "Use this tool to ensure you think like a true macro reporter. "
      },
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        2128,
        -1136
      ],
      "id": "fdd0712d-c9cb-4f67-901e-6ce51640a464",
      "name": "Think3"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheetsTool",
      "typeVersion": 4.7,
      "position": [
        2112,
        -864
      ],
      "id": "902cbc42-1206-4b58-9737-e1304edb2669",
      "name": "Analyze trade journal1",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "model": "grok-4-1-fast-reasoning",
        "options": {
          "timeout": 700000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        1952,
        -864
      ],
      "id": "98cd4c44-0a59-44e9-be37-8949054e07fd",
      "name": "Macro Builder1",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "model": "sonar-reasoning-pro",
        "messages": {
          "message": [
            {
              "content": "{\n  \"role\": \"user\",\n  \"content\": `Search for the latest market news (last 24 hours) and answer:\n\n1. What are the 2-3 biggest market-moving stories right now?\n2. What major events are scheduled in the next 48 hours? (Fed meetings, economic data, major earnings)\n3. What is market consensus expecting? (dovish Fed, hot inflation, weak consumer, etc.)\n4. Any sector-specific catalysts? (crypto regulation, EV policy, consumer trends, AI hype)\n\"5. Is there any unusual market positioning or sentiment extremes worth noting?\"\n\nBe specific with dates/times for upcoming events. Focus on forward-looking information.`\n}"
            }
          ]
        },
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexity",
      "typeVersion": 1,
      "position": [
        1184,
        -1168
      ],
      "id": "82ff8bcc-39b2-4eaf-b048-f56730a30ae9",
      "name": "Market Movers",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "// Combine Sonar + TA into single item (no data loss)\nconst inputs = $input.all();\n\n// Extract Sonar macro results (first item)\nconst sonarRaw = inputs[0]?.json || inputs[0];\n\n// Extract all TA objects (items 1-9)\nconst taObjects = inputs.slice(1).map(item => item?.json || item);\n\n// Build clean structure\nconst output = {\n  // Sonar macro analysis\n  sonar_macro: sonarRaw,\n  \n  // Full TA array (no compression, no data loss)\n  technical_analysis: taObjects,\n  \n  // Quick lookup by symbol (convenient for Grok)\n  ta_by_symbol: Object.fromEntries(\n    taObjects.map(ta => [ta.symbol, ta])\n  ),\n  \n  // Summary stats\n  meta: {\n    generated_at: new Date().toISOString(),\n    sonar_model: sonarRaw?.model || null,\n    ta_count: taObjects.length,\n    symbols_analyzed: taObjects.map(ta => ta.symbol)\n  }\n};\n\n// Return as single item\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1728,
        -1040
      ],
      "id": "5a81599e-3b4a-4b79-8cd2-90daa17e9ed3",
      "name": "Macro snippet"
    },
    {
      "parameters": {
        "options": {
          "timezone": ""
        }
      },
      "type": "n8n-nodes-base.dateTimeTool",
      "typeVersion": 2,
      "position": [
        2016,
        -704
      ],
      "id": "34066b46-5802-494b-81f3-08cc91e652f8",
      "name": "Get Current Date/Time"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Trade entry/exit Log",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "trade_id": "={{ $json.row.trade_id }}",
            "symbol": "={{ $json.row.symbol }}",
            "strategy": "={{ $json.row.strategy }}",
            "direction": "={{ $json.row.direction }}",
            "rationale": "={{ $json.row.rationale }}",
            "exit_plan": "={{ $json.row.exit_plan }}",
            "risk_rating": "={{ $json.row.risk_rating }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "trade_id",
              "displayName": "trade_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "symbol",
              "displayName": "symbol",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "strategy",
              "displayName": "strategy",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "direction",
              "displayName": "direction",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "rationale",
              "displayName": "rationale",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "risk_rating",
              "displayName": "risk_rating",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "exit_plan",
              "displayName": "exit_plan",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "route",
              "displayName": "route",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "sheet",
              "displayName": "sheet",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "row",
              "displayName": "row",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3904,
        -1536
      ],
      "id": "65a58bdd-a912-41d2-a83c-0ff98a288540",
      "name": "Trade Entry/Exit",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 1706049972,
          "mode": "list",
          "cachedResultName": "PM_Actions",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "notes_to_self": "={{ $json.row.notes_to_self }}",
            "severity": "={{ $json.row.severity }}",
            "date": "= {{ $json.row.date }}",
            "time": "={{ $json.row.time }}",
            "rationale": "={{ $json.row.rationale }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "notes_to_self",
              "displayName": "notes_to_self",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "severity",
              "displayName": "severity",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date",
              "displayName": "date",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "time",
              "displayName": "time",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "rationale",
              "displayName": "rationale",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3920,
        -1760
      ],
      "id": "04604108-c9ca-45fc-82d5-11fc589d97e6",
      "name": "Pm actions",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 2024356696,
          "mode": "list",
          "cachedResultName": "Pm_Executor_coms",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ $json.row.timestamp }}",
            "who": "={{ $json.row.who }}",
            "ticker": "={{ $json.row.ticker }}",
            "action": "={{ $json.row.action }}",
            "expires": "={{ $json.row.expires }}",
            "notes_for_other": "={{ $json.row.notes_for_other }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "who",
              "displayName": "who",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "ticker",
              "displayName": "ticker",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "expires",
              "displayName": "expires",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "notes_for_other",
              "displayName": "notes_for_other",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3824,
        -1920
      ],
      "id": "b9e771c3-659e-499d-b2af-e98f29288cc0",
      "name": "Coms",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "model": "grok-4-1-fast-reasoning",
        "options": {
          "timeout": 1800000,
          "maxRetries": 2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        976,
        16
      ],
      "id": "8a465d1a-777f-4289-a46f-1d6a4823d44d",
      "name": "Grok 4 fast",
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Function Node: TA + News Merger (Agent-Compatible)\n * \n * Preserves exact TA structure your agent expects\n * Adds news fields at root level\n */\n\nconst items = $input.all();\n\n// Separate TA from News\nconst taResults = [];\nconst newsResults = [];\n\nfor (const item of items) {\n  const j = item.json;\n  \n  if (j.outlooks || j.ranking || j.baseline) {\n    // TA Scanner output\n    taResults.push(j);\n  } else if (j.signals && j.forward) {\n    // RSS News output\n    newsResults.push(j);\n  }\n}\n\n// Create news lookup\nconst newsMap = new Map();\nfor (const news of newsResults) {\n  newsMap.set(news.symbol, news);\n}\n\n// Merge: Keep TA exactly as-is, add news fields\nconst merged = [];\n\nfor (const ta of taResults) {\n  const symbol = ta.symbol;\n  const news = newsMap.get(symbol);\n  \n  // Copy ENTIRE TA structure (unchanged)\n  const output = { ...ta };\n  \n  // ADD news fields (at root level, where agent expects them)\n  if (news) {\n    // Agent expects these exact field names:\n    output.top10_titles_text = news.top10_titles_text || '';\n    output.news_fresh_text = news.news_fresh_text || '(none)';\n    output.news_sources_count = news.news_sources_count || 0;\n    output.news_event_window = news.news_event_window || false;\n    \n    // Additional fields for NEWS_axis calculation:\n    output.signals = news.signals || {};\n    output.forward = news.forward || {};\n    output.forward_score = news.forward_score || 0;\n    output.forward_event_window = news.forward_event_window || false;\n    output.bullets_forward = news.bullets_forward || [];\n    \n  } else {\n    // No news for this symbol\n    output.top10_titles_text = '';\n    output.news_fresh_text = '(none)';\n    output.news_sources_count = 0;\n    output.news_event_window = false;\n    output.signals = {};\n    output.forward = {};\n    output.forward_score = 0;\n    output.forward_event_window = false;\n    output.bullets_forward = [];\n  }\n  \n  merged.push({ json: output });\n}\n\nreturn merged;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        112
      ],
      "id": "d8243553-01ac-41d3-ba74-e44601f8296d",
      "name": "Build User Message (news)"
    },
    {
      "parameters": {
        "method": "={{ $json.method || 'POST' }}",
        "url": "={{ typeof $json.url === 'string' ? $json.url.trim() : $json.url }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpCustomAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 750000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4176,
        -1280
      ],
      "id": "4806720e-3c67-49e3-97c5-c2a448fb7af6",
      "name": "PM Orders",
      "retryOnFail": true,
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.sheet }}",
                    "rightValue": "=Pm_Executor_coms",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "6d0f77b1-2688-4097-a261-7ff9bb204e5e"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "af03c597-e57b-4595-91de-765361da0803",
                    "leftValue": "={{ $json.sheet }}",
                    "rightValue": "PM_Actions",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9cacd3d7-69dd-435d-ac2b-cedd77daae1b",
                    "leftValue": "={{ $json.sheet }}",
                    "rightValue": "Trade entry/exit Log",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2d5512c2-effb-41b0-8675-d8fcf268dc8a",
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "http",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        3664,
        -1680
      ],
      "id": "0b0607e6-b008-4129-b750-dfa017894d89",
      "name": "Switch"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "90de532d-7107-45ab-b945-e5b2d7cbc523",
                    "leftValue": "={{ $json._routeType }}",
                    "rightValue": "pm_comms",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a6479bc0-3010-4e6d-a80f-abb04a4c29d9",
                    "leftValue": "={{ $json._routeType }}",
                    "rightValue": "trade_journal",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        5280,
        -208
      ],
      "id": "bfa2f4f7-0559-4c01-84c0-4d25d2f9e8f1",
      "name": "Switch1"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "<REDACTED_GOOGLE_DOC_ID>",
          "mode": "list",
          "cachedResultName": "Trade Journal",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "sheetName": {
          "__rl": true,
          "value": 2024356696,
          "mode": "list",
          "cachedResultName": "Pm_Executor_coms",
          "cachedResultUrl": "<REDACTED_GOOGLE_SHEET_URL>"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ $json.timestamp }}",
            "who": "={{ $json.who }}",
            "ticker": "={{ $json.ticker }}",
            "action": "={{ $json.action }}",
            "expires": "={{ $json.expires }}",
            "notes_for_other": "={{ $json.notes_for_other }}"
          },
          "matchingColumns": [
            "timestamp"
          ],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "who",
              "displayName": "who",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "ticker",
              "displayName": "ticker",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "expires",
              "displayName": "expires",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "notes_for_other",
              "displayName": "notes_for_other",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5520,
        -304
      ],
      "id": "93f20e82-dec2-4b3f-9cf0-2672a224b331",
      "name": "Coms1",
      "alwaysOutputData": true,
      "credentials": "<REDACTED_CREDENTIAL_REFERENCE>",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "outputFieldName": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('Output_Field_Name', ``, 'string') }}",
        "options": {}
      },
      "type": "n8n-nodes-base.dateTimeTool",
      "typeVersion": 2,
      "position": [
        3312,
        928
      ],
      "id": "1e8ca627-88e4-4068-bd65-103849b6b264",
      "name": "Date & Time2"
    },
    {
      "parameters": {
        "jsCode": "// PREOPEN \u2014 Ticker Emitter (RSS + yfinance only) \u2014 RANDOM VARIANT\n// Outputs ONE item per ticker for 8 randomly selected stocks: { json: { symbol } } \u2014 no filters, no ETFs, no extras.\nconst UNIVERSE = [\n  // Big Tech / Megacaps\n  \"AAPL\",\"MSFT\",\"NVDA\",\"AMZN\",\"META\",\"GOOGL\",\"TSLA\",\"AVGO\",\"ORCL\",\"CRM\",\n  // Semis / Chips\n  \"AMD\",\"INTC\",\"TSM\",\"QCOM\",\"MU\",\n  // Cloud / Security / SaaS\n  \"ADBE\",\"NOW\",\"PANW\",\"SNOW\",\"NET\",\"DDOG\",\"ZM\",\"AI\",\"BBAI\",\"PLTR\",\"DOCU\",\n  // Fintech / Payments / Crypto infra\n  \"XYZ\",\"PYPL\",\"AFRM\",\"SOFI\",\"CRCL\",\"UPST\",\"KLAR\",\"CHYM\",\"BLSH\",\"BULL\",\"NU\",\"TOST\",\n  // Rides / Travel / Trading / Crypto\n  \"UBER\",\"LYFT\",\"ABNB\",\"COIN\",\"HOOD\",\"MSTR\",\"RIOT\",\"MARA\",\"GEMI\",\"IREN\",\"CLSK\",\n  // Consumer / Retail / Apparel / CPG / Autos\n  \"WMT\",\"TGT\",\"COST\",\"NKE\",\"LULU\",\"AEO\",\"HSY\",\"BABA\",\"RL\",\"SJM\",\"BBW\",\"UAA\",\"CROX\",\"CVNA\",\"GPRO\",\n  // Beverage / Alt-protein / Food\n  \"KO\",\"PEP\",\"CELH\",\"MNST\",\"OTLY\",\"BYND\",\"CALM\",\"TSN\",\n  // Pets\n  \"WOOF\",\"FRPT\",\n  // EVs / Autos / Charging / Energy\n  \"NIO\",\"LI\",\"RIVN\",\"LCID\",\"RACE\",\"BLNK\",\"XPEV\",\"PLUG\",\n  // Media / Sports / Social / Gaming / Dating / Education\n  \"NFLX\",\"FOXA\",\"TKO\",\"YELP\",\"RDDT\",\"RBLX\",\"SNAP\",\"TTWO\",\"PENN\",\"DKNG\",\"FUBO\",\"WYNN\",\"FUN\",\n  \"MTCH\",\"GME\",\"CZR\",\"BMBL\",\"GRND\",\"CHGG\",\"DUOL\",\n  // Restaurants (core)\n  \"MCD\",\"SBUX\",\"BROS\",\"DPZ\",\"WING\",\"CAKE\",\"CMG\",\"CAVA\",\"SG\",\"RR\",\n  \"RRGB\",\"DNUT\",\"CBRL\",\"SHAK\",\"TXRH\",\"WEN\",\"PZZA\",\"DRI\",\"BJRI\",\"PLAY\",\"JACK\",\n  \"PTLO\",\"QSR\",\"EAT\",\"YUM\",\n  // Grocers & Club\n  \"ACI\",\"SFM\",\n  // Exchange / Platforms\n  \"CME\",\"DASH\",\"PGY\",\n  // Industrials / Utility\n  \"BA\",\"PCG\",\"ED\",\n  // Contract food service\n  \"ARMK\",\n  // Health & Wellness\n  \"PTON\",\"PLBY\",\"PLNT\",\"WW\",\"HIMS\",\n  // Design / Ordering rails\n  \"FIG\"\n];\n// Dedupe & normalize (safety)\nconst tickers = [...new Set(UNIVERSE.map(t => String(t).toUpperCase()))];\n\n// Randomly select 8 unique tickers\nconst selectedTickers = [];\nconst shuffled = [...tickers].sort(() => 0.5 - Math.random());\nfor (let i = 0; i < Math.min(8, shuffled.length); i++) {\n  selectedTickers.push(shuffled[i]);\n}\n\n// n8n requires return statement with array of objects\nreturn selectedTickers.map(symbol => {\n  return {\n    json: {\n      symbol: symbol\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -832,
        320
      ],
      "id": "dcf06b38-1f81-406f-a3dd-576eebde463b",
      "name": "test Node"
    },
    {
      "parameters": {
        "jsCode": "// Code node: Ensure unique Alpaca client_order_id (<=48 chars)\nconst out = [];\nconst items = $input.all();\nconst now = new Date();\nconst runShort = now.toISOString().replace(/[-:.TZ]/g,'').slice(2,12); // YYMMDDHHMM\nconst ms = String(now.getTime() % 100000).padStart(5,'0');\n\nfor (let i = 0; i < items.length; i++) {\n  const it = items[i].json || {};\n  const rb = { ...(it.request_body || {}) };\n\n  // Symbol root (for label only)\n  const sym = String(rb.symbol || it.symbol || '')\n    .replace(/^O:/,'').replace(/[^A-Z0-9]/gi,'').slice(0,5).toUpperCase();\n\n  const leg = (String(rb.order_class||'').toLowerCase() === 'mleg') ? 'ML' : 'SN';\n  const seq = String(it.seq ?? i + 1).padStart(2,'0');\n  const rand = Math.random().toString(36).slice(2,7).toUpperCase(); // 5 chars\n\n  const proposed = rb.client_order_id || it.client_order_id ||\n    `PM-${runShort}-${sym}-${leg}-${seq}-${ms}${rand}`;\n\n  // Enforce 48-char max\n  rb.client_order_id = proposed.slice(0, 48);\n\n  out.push({ json: { ...it, request_body: rb } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3920,
        -1296
      ],
      "id": "7ec6197b-7f95-44ac-8756-01c8633d7df6",
      "name": "Code4"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node \u2014 Ensure unique Alpaca client_order_id (<=48 chars, sanitized v3 HARDENED)\n *\n * Guarantees:\n * - Always sets a non-empty `request_body.client_order_id`.\n * - Preserves an existing, valid client_order_id when present, but appends run-specific suffix for global uniqueness.\n * - Sanitizes to `[A-Za-z0-9-_]`, trims to 48 chars.\n * - De-duplicates across the batch (adds short suffix if needed, still <=48).\n * - Works for singles and mlegs; derives a stable symbol stub from long OCC/OPRA.\n * - For preserved IDs: appends short run hash (e.g., last 6 chars of runShort + ms) if not already unique-patterned.\n */\n\nconst items = $input.all();\nconst out = [];\n\nconst now = new Date();\nconst runShort = now.toISOString().replace(/[-:.TZ]/g, '').slice(2, 12); // YYMMDDHHMM\nconst ms = String(now.getTime() % 100000).padStart(5, '0');\nconst runHash = (runShort.slice(-6) + ms).slice(0, 8); // Short unique run suffix, e.g., \"10081200\"\n\nconst USED = new Set();\n\nfunction sanitizeId(s) {\n  return String(s || '').replace(/[^A-Za-z0-9-_]/g, '').slice(0, 48);\n}\n\n// Extract a 3\u20135 char alphanumeric symbol root from long OCC/OPRA\nfunction symbolStub(symRaw) {\n  const s = String(symRaw || '').toUpperCase().replace(/^O:/, '');\n  // strip to ticker before the date digits (YYMMDD)\n  const m = s.match(/^([A-Z.]+?)(?=\\d{6}[CP]|$)/) || s.match(/^([A-Z.]+)/);\n  const root = (m ? m[1] : s).replace(/[^A-Z0-9]/g, '');\n  if (!root) return 'OPT';\n  return root.slice(0, Math.min(5, Math.max(3, root.length)));\n}\n\nfunction deriveSym(it, rb) {\n  // Prefer single symbol, else first leg, else fallback to it.symbol\n  const one = rb?.symbol || (rb?.legs && rb.legs[0]?.symbol) || it?.symbol || '';\n  return symbolStub(one);\n}\n\nfunction legTypeOf(rb) {\n  return String(rb?.order_class || '').toLowerCase() === 'mleg' ||\n    (Array.isArray(rb?.legs) && rb.legs.length > 1)\n    ? 'ML'\n    : 'SN';\n}\n\nfunction looksTimeStamped(id) {\n  // Heuristic: check if ends with digit-heavy pattern suggesting timestamp/random\n  const digits = (id.match(/\\d/g) || []).length;\n  return digits >= 6 && /\\d{4,}/.test(id.slice(-6));\n}\n\nfunction ensureUnique(id) {\n  let cid = id;\n  if (!USED.has(cid)) {\n    USED.add(cid);\n    return cid;\n  }\n  // If collision, append a short suffix while staying <= 48\n  for (let i = 1; i < 1000; i++) {\n    const suf = '-' + i.toString(36).toUpperCase();\n    const base = cid.slice(0, Math.max(0, 48 - suf.length));\n    const cand = base + suf;\n    if (!USED.has(cand)) {\n      USED.add(cand);\n      return cand;\n    }\n  }\n  // Last resort: regenerate random\n  const fallback = sanitizeId('PM-' + runShort + '-' + Math.random().toString(36).slice(2, 8).toUpperCase());\n  USED.add(fallback);\n  return fallback;\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const it = items[i]?.json ?? items[i] ?? {};\n  const rbIn = it?.request_body ?? {};\n  const rb = { ...rbIn }; // shallow copy\n\n  // Skip if not an options order payload; still pass it through untouched (but with cid if missing).\n  const lt = legTypeOf(rb);\n  const sym = deriveSym(it, rb);\n  const seq = String(it?.seq ?? i + 1).padStart(2, '0');\n  const rand = Math.random().toString(36).slice(2, 7).toUpperCase();\n\n  // Prefer existing IDs when valid after sanitize\n  let proposed =\n    rb.client_order_id ||\n    it.client_order_id ||\n    // default pattern: PM-<YYMMDDHHMM>-<SYM>-<LT>-<SEQ>-<MS>-<RAND>\n    `PM-${runShort}-${sym}-${lt}-${seq}-${ms}-${rand}`;\n\n  // For preserved IDs: append runHash (to ensure global uniqueness)\n  proposed = sanitizeId(proposed);\n  if (proposed && rb.client_order_id) {\n    const hashSuf = '-' + runHash;\n    if (proposed.length + hashSuf.length <= 48) {\n      proposed += hashSuf;\n    } else {\n      // Truncate base if needed\n      proposed = proposed.slice(0, 48 - hashSuf.length) + hashSuf;\n    }\n    proposed = sanitizeId(proposed); // Re-sanitize after append\n  }\n\n  // Ensure non-empty\n  if (!proposed) {\n    proposed = sanitizeId(`PM-${runShort}-${sym}-${lt}-${seq}-${ms}-${rand}`);\n  }\n\n  // Enforce uniqueness in-batch\n  rb.client_order_id = ensureUnique(proposed);\n\n  // Normalize qty (integer >= 1) if present\n  if (rb.qty != null) {\n    const q = Math.max(1, Math.floor(Number(rb.qty) || 1));\n    rb.qty = String(q);\n  }\n\n  // Ensure strings for common fields (don\u2019t mutate values otherwise)\n  if (rb.limit_price != null) rb.limit_price = String(rb.limit_price);\n  if (rb.type && typeof rb.type !== 'string') rb.type = String(rb.type);\n  if (rb.time_in_force && typeof rb.time_in_force !== 'string') rb.time_in_force = String(rb.time_in_force);\n\n  out.push({ json: { ...it, request_body: rb } });\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5136,
        384
      ],
      "id": "65a2db95-0f02-42b2-b0e1-c64012b9b146",
      "name": "unique ID"
    }
  ],
  "pinData": {
    "Hourly Market Run": [
      {
        "json": {
          "timestamp": "2025-09-24T10:05:00.002-04:00",
          "Readable date": "September 24th 2025, 10:05:00 am",
          "Readable time": "10:05:00 am",
          "Day of week": "Wednesday",
          "Year": "2025",
          "Month": "September",
          "Day of month": "24",
          "Hour": "10",
          "Minute": "05",
          "Second": "00",
          "Timezone": "America/New_York (UTC-04:00)"
        }
      }
    ]
  },
  "connections": {
    "02 Expand Tickers": {
      "main": [
        [
          {
            "node": "Yahoo Finance Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Headlines data": {
      "main": [
        [
          {
            "node": "News/price movement",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Ticker Websites/News": {
      "main": [
        [
          {
            "node": "Headlines data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "News/price movement": {
      "main": [
        [
          {
            "node": "Build User Message (news)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Signal Board": {
      "main": [
        [
          {
            "node": "Finalize and Fan Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize and Fan Out": {
      "main": [
        [
          {
            "node": "Emit Symbols",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Emit Symbols": {
      "main": [
        [
          {
            "node": "Plays data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Current Price1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Portfolio summary",
            "type": "main",
            "index": 0
          },
          {
            "node": "Alpaca Options",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hourly Market Run": {
      "main": [
        [
          {
            "node": "Time Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "What Plays?": {
      "main": [
        [
          {
            "node": "prep for calculator",
            "type": "main",
            "index": 0
          },
          {
            "node": "Begin to Build Orders",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Plays data": {
      "main": [
        [
          {
            "node": "What Plays?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Current account balances": {
      "main": [
        [
          {
            "node": "Combine balalnces + summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Portfolio summary": {
      "main": [
        [
          {
            "node": "Parse portsummary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine balalnces + summary": {
      "main": [
        [
          {
            "node": "prep for calculator",
            "type": "main",
            "index": 1
          },
          {
            "node": "Account and open positions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prep for calculator": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get current price for Greeks": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Portfolio impact calculator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Portfolio impact calculator": {
      "main": [
        [
          {
            "node": "Sizing/ risk scores",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sizing/ risk scores": {
      "main": [
        [
          {
            "node": "Agent Packet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Directional Analyst": {
      "main": [
        [
          {
            "node": "Grok parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grok parsing": {
      "main": [
        [
          {
            "node": "Signal Board",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Agent Packet": {
      "main": [
        [
          {
            "node": "final executor merge",
            "type": "main",
            "index": 0
          },
          {
            "node": "Begin to Build Orders",
            "type": "main",
            "index": 2
          }
        ],
        [
          {
            "node": "final executor merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grok 4": {
      "ai_languageModel": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Trade Executor Agent": {
      "main": [
        [
          {
            "node": "Parse executor weights",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse executor weights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "macro briefing code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "macro briefing code": {
      "main": [
        [
          {
            "node": "Macro Reporter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator1": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Macro Reporter": {
      "main": [
        [
          {
            "node": "final executor merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "final executor merge": {
      "main": [
        [
          {
            "node": "Validate/Normalize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Major news-CNBC": {
      "main": [
        [
          {
            "node": "Investing.com",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market News": {
      "main": [
        [
          {
            "node": "Market news parsed",
            "type": "main",
            "index": 0
          },
          {
            "node": "Indexes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market news parsed": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Parse executor weights": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Begin to Build Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Join Weights": {
      "main": [
        [
          {
            "node": "Force Build Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Size contracts from weights": {
      "main": [
        []
      ]
    },
    "Build Orders Payload": {
      "main": [
        [
          {
            "node": "unique ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Place Orders": {
      "main": [
        [
          {
            "node": "Poll status",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build log for journal",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Poll status": {
      "main": [
        []
      ]
    },
    "Build log for journal": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Begin to Build Orders": {
      "main": [
        [
          {
            "node": "Join Weights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Portfolio summary1": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Current account balances1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Parse symbols",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Indexes": {
      "main": [
        [
          {
            "node": "Market Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market Data": {
      "main": [
        [
          {
            "node": "Market Techicals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market Techicals": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Investing.com": {
      "main": [
        [
          {
            "node": "Fed News",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Fed News": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          },
          {
            "node": "Market News",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Current account balances1": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Perplxity Search": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "TA+Port Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Current Price1": {
      "main": [
        [
          {
            "node": "Get current price for Greeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Contracts": {
      "main": [
        [
          {
            "node": "Plays data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Alpaca Options": {
      "main": [
        [
          {
            "node": "Parse Contracts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TAOutlook v2.0": {
      "main": [
        [
          {
            "node": "Ticker Websites/News",
            "type": "main",
            "index": 0
          },
          {
            "node": "News/price movement",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity Macro Tool": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Parse portsummary": {
      "main": [
        [
          {
            "node": "Current account balances",
            "type": "main",
            "index": 0
          },
          {
            "node": "Combine balalnces + summary",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Account and open positions": {
      "main": [
        [
          {
            "node": "final executor merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Validate/Normalize": {
      "main": [
        [
          {
            "node": "Attach quality for agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attach quality for agent": {
      "main": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Legs Fan Out": {
      "main": [
        [
          {
            "node": "Append or update row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Force Build Orders": {
      "main": [
        [
          {
            "node": "Build Orders Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Yahoo Finance Call": {
      "main": [
        [
          {
            "node": "TAOutlook v2.0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "02 Expand Tickers2": {
      "main": [
        [
          {
            "node": "Daily TA",
            "type": "main",
            "index": 0
          },
          {
            "node": "Hourly TA",
            "type": "main",
            "index": 0
          },
          {
            "node": "Week TA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator2": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Snippet for PM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Snippet for PM": {
      "main": [
        [
          {
            "node": "Portfolio Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Portfolio Manager": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TA+Port Summary": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          },
          {
            "node": "Market Movers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Universe TA": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Daily TA": {
      "main": [
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Universe TA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hourly TA": {
      "main": [
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Week TA": {
      "main": [
        [
          {
            "node": "Merge5",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Parse symbols": {
      "main": [
        [
          {
            "node": "Alpaca Options1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Alpaca Options1": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Think": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Think1": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Trade entry/exit log": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "View your memory": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Alpaca Options2": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Place Different Orders": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "View Trade Journal": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Look at PM notes": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Think2": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Analyze trade journal": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Time Check": {
      "main": [
        [
          {
            "node": "02 Expand Tickers2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Portfolio summary1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Validate Executor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Executor": {
      "main": [
        [
          {
            "node": "02 Expand Tickers",
            "type": "main",
            "index": 0
          },
          {
            "node": "Major news-CNBC",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Get Coms": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "View Coms with Executor": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Macro Builder": {
      "ai_languageModel": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Date & Time": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Date & Time1": {
      "ai_tool": [
        [
          {
            "node": "Trade Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "PM Perplexity": {
      "ai_tool": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "xAI Grok Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Portfolio Manager",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge6": {
      "main": [
        [
          {
            "node": "Macro snippet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator3": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Market Data1": {
      "main": [
        [
          {
            "node": "Market Techicals1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Indexes1": {
      "main": [
        [
          {
            "node": "Market Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market Techicals1": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Perplexity Macro Tool1": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Think3": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Analyze trade journal1": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Macro Builder1": {
      "ai_languageModel": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Macro Reporter1": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Market Movers": {
      "main": [
        [
          {
            "node": "Indexes1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Macro snippet": {
      "main": [
        [
          {
            "node": "Macro Reporter1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Current Date/Time": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Grok 4 fast": {
      "ai_languageModel": [
        [
          {
            "node": "Directional Analyst",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Build User Message (news)": {
      "main": [
        [
          {
            "node": "Directional Analyst",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PM Orders": {
      "main": [
        []
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Coms",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Pm actions",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Trade Entry/Exit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "Coms1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Updated Executor Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Date & Time2": {
      "ai_tool": [
        [
          {
            "node": "Macro Reporter",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "test Node": {
      "main": [
        []
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "PM Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "unique ID": {
      "main": [
        [
          {
            "node": "Place Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "w4DgXfCb5VOcOKgt"
  },
  "versionId": "b4d6151b-b45c-47d7-b097-4b6ef7d92a95",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "98a0e1a8222368f9e1dcae20258c3fcd566bdf301be00509d94cd43fafbf1ae0"
  },
  "id": "w4DgXfCb5VOcOKgt",
  "tags": []
}